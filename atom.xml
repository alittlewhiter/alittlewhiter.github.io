<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alittlewhiter.github.io</id>
    <title>君の知らない物语</title>
    <updated>2020-05-21T01:30:11.313Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alittlewhiter.github.io"/>
    <link rel="self" href="https://alittlewhiter.github.io/atom.xml"/>
    <subtitle>Took the sourest lemon that life has to offer and turned it into something resembling lemonade.</subtitle>
    <logo>https://alittlewhiter.github.io/images/avatar.png</logo>
    <icon>https://alittlewhiter.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 君の知らない物语</rights>
    <entry>
        <title type="html"><![CDATA[正规集的表示工具 和 识别工具]]></title>
        <id>https://alittlewhiter.github.io/post/zheng-gui-ji-de-biao-shi-gong-ju-he-shi-bie-gong-ju/</id>
        <link href="https://alittlewhiter.github.io/post/zheng-gui-ji-de-biao-shi-gong-ju-he-shi-bie-gong-ju/">
        </link>
        <updated>2020-05-02T02:43:57.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：正规集，NFA，DFA，</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：正规集，NFA，DFA，</p>
<!-- more -->
<h2 id="正规集的表示工具和识别工具">正规集的表示工具和识别工具</h2>
<h3 id="正规集的表示工具和识别工具-2">正规集的表示工具和识别工具</h3>
<p>**任务性质：**选做任务，分值30分。要求独立完成，不接受团队成果。</p>
<p>**任务介绍：**将给定的正规表达式转换为等价的有限状态自动机。</p>
<h3 id="任务内容">任务内容</h3>
<ol>
<li>
<p>设计一个程序，对于输入的一个正规表达式和一个任意字符串，判定该字符串是否该正规式所表示的正规集的一个元素，输出<code>Yes</code> or <code>No</code>。</p>
</li>
<li>
<p>要求：</p>
<ul>
<li>
<p>**输入：**键盘输入，两行。第一行输入一个RE，教科书标准写法，不含扩展符号。第二行输入一个任意字符串，不含非法字符；</p>
</li>
<li>
<p><strong>输出：<strong>屏幕打印输出</strong>Yes</strong>或<strong>No</strong>，说明该串是否是该正规式所表示的语言的一个句子；</p>
</li>
<li>
<p>**处理过程：**要求在实验报告中说明对主要数据结构和算法的设计，包括：正规式和自动机的数据结构设计和核心处理过程（DFA对串的识别过程等）；</p>
</li>
<li>
<p>**程序代码：**要求以附件形式提供能编译运行的程序代码文件（包）；</p>
</li>
<li>
<p>RE需要<mark>先转换为NFA，再由NFA转换为DFA</mark>，不强制要求最小化DFA；</p>
</li>
<li>
<p>需要考虑e-closure函数的实现；</p>
</li>
<li>
<p>考虑数据结构，如RE的数据结构，NFA的数据结构，NFA的状态数据结构，以及DFA的数据结构。</p>
</li>
</ul>
</li>
</ol>
<h3 id="任务分析">任务分析</h3>
<ol>
<li>
<p>本任务是通过程序实现输入正规表达式（字符串），自动生成确定的有穷自动机（DFA），并能够通过该DFA去识别符合该正规式所定义语言的字符串。正规表达式是描述单词规则的工具，而有穷自动机能够对任意的一个单词，将其输入正规式的初始状态，自动机每次读入一个字母，根据单词的字母进行自动机中状态的转换，若其能够准确的到达自动机的终止状态，就说明该单词能够被自动机识别，也就满足了正规式所定义的规则。根据<mark>正规式与有穷自动机的等价性</mark>：<strong>对于Σ上的每个正规表达式<code>V</code>，都存在一个Σ上的DFA <code>M</code>，使得<code>L(M)=L(V)</code></strong>。</p>
<p>​        关于DFA与NFA之间的差异：对于某一个状态S，输入一个字符a，DFA能够到达的下一个状态有且仅有一个，而NFA所能到达的状态个数大于或等于一个（即不确定的）。因为NFA为不确定的，对于程序来说识别时无法准确判断下一个应转移到哪一个状态，因此识别一个正规式的最好的方式是DFA。</p>
</li>
<li>
<p>由于DFA非常方便实现字符串的模式匹配，且DFA可由NFA经一定算法确定化得到，因此可以先将正规式V转化为<code>X -&gt; Y</code>的NFA形式（其中X为初态，Y为终态，X通过正规式V可以转化为Y），并且根据以下规则对正规式逐步分解，加入新的节点和弧，直到每条弧的标记均为字符集Σ上的一个**<code>符号</code><strong>或者</strong><code>ε</code>**。这样就能构造出该正规表达式对应的非确定有穷自动机NFA，再考虑将NFA确定化为DFA、对DFA进行最小化（可选）即可。</p>
<figure data-type="image" tabindex="1"><img src="E:%5CDailylife%5C%E8%AE%A1%E5%9F%BA%E5%B0%8F%E5%8F%AF%E7%88%B1%E7%9A%84%E4%B8%93%E5%B1%9E%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E5%A4%A7%E4%B8%89%EF%BC%89%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%5C%E5%AE%9E%E9%AA%8C%5Creports%5Cex1%5C%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%BB%BB%E5%8A%A1%E5%9B%9B%E3%80%81%E6%AD%A3%E8%A7%84%E9%9B%86%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%B7%A5%E5%85%B7%E5%92%8C%E8%AF%86%E5%88%AB%E5%B7%A5%E5%85%B7.assets%5CREG2NFA.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>本任务中使用的正规表达式由两种符号组成：</p>
<ul>
<li>**操作符：**空运算符 <code>ε</code>（程序中用<code>^</code>表示），或运算符 <code>|</code>，括号<code>()</code>，闭包运算符 <code>*</code>，隐含的连接符（程序中用<code>#</code>表示）</li>
<li>**非操作符：**常见的除操作符以外的字符：如字母(<code>A-Z</code>、<code>a-z</code>)、数字(<code>0-9</code>)等符号。</li>
</ul>
<p>​        设计正规式转NFA的步骤中，有如下几种基础情况，并由这几种情况复合组合成更加复杂的正规表达式：</p>
<ol>
<li>
<p>输入为空：</p>
<figure data-type="image" tabindex="2"><img src="https://alittlewhiter.github.io/post-images/1588387671284.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>输入为单个字符 <code>a</code>：将字符<code>a</code>构造为一个NFA图<code>0-&gt;1</code></p>
<figure data-type="image" tabindex="3"><img src="https://alittlewhiter.github.io/post-images/1588387678477.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>输入为<code>a|b</code>：由<strong>a</strong>和<strong>b</strong>对应的NFA图<code>1-&gt;2</code>和<code>3-&gt;4</code>构造新的NFA图<code>0-&gt;5</code></p>
<figure data-type="image" tabindex="4"><img src="https://alittlewhiter.github.io/post-images/1588387693414.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>输入为<code>a*</code>：由原来a的NFA图<code>1-&gt;2</code>构造新的NFA图<code>0-&gt;3</code>，并添加转换弧和ε符号</p>
<figure data-type="image" tabindex="5"><img src="https://alittlewhiter.github.io/post-images/1588387698970.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>输入为<code>ab</code>：由原来的NFA图<code>1-&gt;2</code>和<code>3-&gt;4</code>构造新的NFA图<code>0-&gt;5</code></p>
<figure data-type="image" tabindex="6"><img src="https://alittlewhiter.github.io/post-images/1588387705080.png" alt="" loading="lazy"></figure>
</li>
</ol>
<p>​        对以上操作符有优先级：**<code>()</code> &gt; <code>*</code> &gt; <code>#(连接)</code>&gt;<code>|</code> **，且每种操作符到NFA都有固定的转换逻辑，都可以在1、2两种基础情况下，通过添加头尾节点和状态转换方向导出新的NFA。</p>
</li>
<li>
<p>NFA与DFA相比，其不确定性表现在<strong>多值映射</strong>和<strong>带空转移</strong>，为了解决这个问题，设计状态的空闭包函数<code>e_closure()</code>，它可以计算出：对给定NFA图中的某一状态的结点，由其出发经过任意条ε弧能够到达的全部状态。这样NFA中<mark>由一个状态经字符a导出新的状态</mark>可以变形为：从该状态的空闭包所含的全部“等价”状态结点<code>s</code>出发，经过一条a弧能够到达状态节点<code>t</code>，全部这样的<code>t</code>的空闭包导出状态集的并集即为<strong>下一个状态</strong>（可构造为一个DFA结点）。</p>
<p>​        NFA的确定化：设Σ为正规式全部非操作符字符集，对NFA初态结点x进行空闭包操作得到初态集<code>X=e_closure(x)</code>，并以此作为初态DFA结点。构造一张二维表，其第一行第一列为DFA初态结点X，其余列分别为对X输入Σ中的每个字符所导出的<strong>下一个状态</strong>构成的新的DFA结点，将新导出的DFA结点加入到新的行的第一列中去，并重复进行上述操作，直至不再有新的状态集合出现为止。</p>
<p>​        因为NFA的状态数是有限的，其状态集组合也是有限的，故上述过程必在有限步骤内停止。对上述过程产生的DFA结点进行重新编号，二维表即成为一个状态矩阵，该矩阵表示了一个确定的有穷自动机，其唯一的初态为X，终态为任意包含NFA的终态结点y的状态集合。</p>
<p>​        至此，该有穷自动机便可以用来表示正规式并识别任意字符串是否符合该正规式语言，进一步化简可以合并等价DFA状态，将DFA最小化 <sub>这里就不予实现</sub>。</p>
</li>
<li>
<p>数据结构与算法设计：</p>
<p>**NFA：**包括NFA结点集和NFA图<code>NFA_GRAPH</code>，每个NFA结点的状态编号<code>state</code>都为指向结点集<code>NFAset</code>的索引指针，其后继节点链表<code>next</code>中的“指针”也为指向结点集中对应<code>NFA_NODE</code>的索引，NFA图中的头、尾结点同理。</p>
<p>此外，在正规式字符串扫描过程中，通过不断的读入字符增加首尾节点和状态转换后转化为一张NFA图，为此还需要一个NFA栈和一个符号栈。从左至右读入正规式的字符时对字符进行判断：</p>
<ul>
<li>若其为<strong>操作符 <code>*</code></strong>，将NFA栈顶弹出后进行闭包操作，操作后产生新的NFA压回NFA栈；若下一个字符为非操作符或<code>(</code>，符号栈压入一个连接符<code>#</code>；</li>
<li>若为<strong>操作符 <code>|</code></strong>，逐个弹出符号栈顶部的全部<code>#</code>操作符，并每次从NFA栈弹出两个NFA作连接操作后压回NFA栈，直到符号栈顶符号不是<code>#</code>为止，这时压入一个<code>|</code>；</li>
<li>若为<strong>操作符 <code>(</code></strong>，直接压入符号栈中；</li>
<li>若为<strong>操作符 <code>)</code></strong>，依次弹出栈顶符号（<code>|</code>或<code>#</code>），并从NFA栈弹出两个NFA对其进行该操作后，得到新NFA压回NFA栈，直到符号栈栈顶为<code>(</code>为止，弹出<code>(</code>；若下一个字符为非操作符或<code>(</code>，符号栈压入一个连接符<code>#</code>；</li>
<li>若为<strong>非操作符</strong>，则将该字符转换为NFA后压入NFA栈中；若下一个字符仍为非操作符或<code>(</code>，符号栈压入一个连接符<code>#</code>；</li>
</ul>
<p>​        当读完最后一个字符后将符号栈中的操作符逐个弹出，弹出一个操作符跟着弹出两个NFA栈的栈顶NFA，根据相应的操作符对两个NFA进行处理后转换为新的NFA压入NFA栈中。当处理完所有的符号栈中的符号后弹出NFA栈中的唯一元素即为所求的NFA。</p>
<pre><code class="language-c++">class NFA_NODE {                    // NFA结点
public:
    int state;                      // 结点状态编号(也为指向状态集的索引)
    char inchar;                    // 转移到该结点的输入字符
    list&lt;int&gt; next;                 // 该结点的后继结点链表
    NFA_NODE(int s, char in) : state(s), inchar(in) {}
};

class NFA_GRAPH {                   // NFA图
public:
    int head, tail;                 // 头、尾结点状态编号
    NFA_GRAPH(int h, int t) : head(h), tail(t) {} 
};
vector&lt;NFA_NODE&gt; NFAset;            // NFA状态结点集
</code></pre>
<p>**DFA：**包括DFA结点集和状态转换表。每个DFA结点都统一存储在<code>DFAset</code>中，属性有状态编号<code>num</code>、结点类型<code>0，1，2</code>，输入字符以及该结点代表的等价的NFA状态集；每行第一列为一个DFA状态，后续列为第一列结点能够输入某字符导出的新状态集（可能为空）。</p>
<p><strong>从NFA图转化为DFA算法：</strong></p>
<ul>
<li>首先，由NFA图获取初态结点<code>START</code>和终态结点<code>END</code>，求<code>e_closure(START)</code>并构造DFA初态结点<code>DFA_Start</code>，放进DFAset集合；</li>
<li>建立一个DFA栈，初态结点入栈，建立一个DFA状态转换表；</li>
<li>栈非空的情况下，取出栈顶元素放入状态转换表中（新建一行）；</li>
<li>对正规式字符集（全部非操作符）中每个字符作输入字符，求当前DFA结点（等价的NFA状态集）导出的新NFA状态集闭包；
<ul>
<li>若状态集为空；则跳过该字符；</li>
<li>若状态集已经在DFAset某一DFA结点代表的状态集出现过，则将原DFA结点加入到状态转换表中当前行后面；</li>
<li>若状态集未出现过，且其包含终态结点<code>END</code>，则生成一个新的DFA终态结点（type=2），否则生成一个新的DFA中间节点（type=1），并将该结点加入到状态转换表中当前行后面，且入DFA栈；</li>
</ul>
</li>
<li>若DFA栈非空，转第三步重复操作，直至不再产生新的状态集为止。</li>
</ul>
<pre><code class="language-c++">class DFA_NODE {                // DFA结点
public: 
    int num;                    // 结点状态编号(指向DFA结点集的指针)
    int type;                   // 结点类型：初始状态0、中间状态1、终态2
    char inchar;                // 转化到此DFA结点的输入字符
    set&lt;int&gt; equiv;             // 等价的NFA结点状态集合
    
    DFA_NODE(int n, int t, char c, set&lt;int&gt;&amp; s): num(n), type(t),inchar(c),equiv(s) { }
};
vector&lt;DFA_NODE&gt; DFAset;            // DFA状态结点集
vector&lt;vector&lt;int&gt;&gt; DFA;            // DFA状态转换表
</code></pre>
</li>
<li>
<p><strong>运用DFA状态转换表匹配字符串：</strong></p>
<ul>
<li>
<p>由状态转换表第0行（DFA初态结点）开始，从字符串读入一个字符ch；</p>
</li>
<li>
<p>判断该行后面是否含有能匹配该字符<code>(即inchar=ch)</code>的结点：</p>
<ul>
<li>若有，转移到状态转换表中该结点为首的行，扫描下一个字符ch，重复第二步；</li>
<li>若没有，则匹配失败；</li>
</ul>
</li>
<li>
<p>若全部字符扫描成功，判断最后结点是否为终态结点（<code>type==2</code>）,若是，则匹配成功；否则，匹配失败。</p>
</li>
</ul>
</li>
<li>
<p>实验程序代码及注释见附件：</p>
<ul>
<li>编译环境：Windows10 + Code::Blocks17.12，mingw32 g++，-std=c++11，编码：UTF-8</li>
<li><sub>这里就懒得上传了</sub></li>
</ul>
</li>
</ol>
<h3 id="备注">备注</h3>
<p><strong>完成日期：</strong> 2020-05-01</p>
<p><strong>报告格式：</strong> Markdown</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言·文法定义]]></title>
        <id>https://alittlewhiter.github.io/post/c-yu-yan-wen-fa-ding-yi/</id>
        <link href="https://alittlewhiter.github.io/post/c-yu-yan-wen-fa-ding-yi/">
        </link>
        <updated>2020-04-23T23:31:54.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：C语言文法、LEX、词法分析</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：C语言文法、LEX、词法分析</p>
<!-- more -->
<h2 id="我的简单版本">我的简单版本</h2>
<pre><code class="language-xquery">&lt;PROC&gt;→&lt;DECLS&gt;|&lt;PROC&gt;&lt;DECLS&gt;
&lt;DECLS&gt;→&lt;FUNCS&gt;|&lt;DECL_STAT&gt;

&lt;FUNCS&gt;→&lt;FUNC&gt;&lt;BLOCK&gt;
&lt;FUNC&gt;→&lt;TYPE&gt;&lt;IDEN&gt;&lt;(&gt;&lt;ARG_LIST&gt;&lt;)&gt;

&lt;DECL_STAT&gt;→&lt;DECLARE&gt;&lt;;&gt;|&lt;DECLARE&gt;&lt;=&gt;&lt;CONST_EXPR&gt;&lt;;&gt;	//声明语句
&lt;DECLARE&gt;→&lt;TYPE&gt;&lt;DIRECT_DECL&gt;

&lt;DIRECT_DECL&gt;→&lt;UNARY_EXPR&gt;|&lt;DIRECT_DECL&gt;&lt;,&gt;&lt;UNARY_EXPR&gt;
&lt;UNARY_EXPR&gt;→&lt;IDEN&gt;|&lt;ARRAY&gt;

&lt;ARRAY&gt;→&lt;ARRAY&gt;&lt;[&gt;&lt;INTEGER&gt;&lt;]&gt;|&lt;IDEN&gt;&lt;[&gt;&lt;INTEGER&gt;&lt;]&gt;	//数组
&lt;ARG_LIST&gt;→&lt;DECLARE&gt;|&lt;ARG_LIST&gt;&lt;,&gt;&lt;DECLARE&gt;		// 参数列表
&lt;IDEN_LIST&gt;→&lt;IDEN&gt;|&lt;IDEN_LIST&gt;&lt;,&gt;&lt;IDEN&gt;			//标识符列表

&lt;IDEN&gt;→&lt;LETTER&gt;&lt;IDEN_SUFFIX&gt;			//标识符
&lt;IDEN_SUFFIX&gt;→&lt;LET_DIG&gt;&lt;IDEN_SUFFIX&gt;|^
&lt;LET_DIG&gt;→&lt;LETTER&gt;|&lt;DIGIT&gt;
&lt;CONST_EXPR&gt;→&lt;INTEGER&gt;|&lt;CHARACTER&gt;|&lt;STRING&gt; 	//常量表达式
&lt;INTEGER&gt;→&lt;DIGIT&gt;|&lt;DIGIT&gt;&lt;INTEGER&gt;  //整数值
&lt;LETTER&gt;→[A-Z]|[a_z]|_
&lt;DIGIT&gt;→0|1|2|3|4|5|6|7|8|9

&lt;DECL_LIST&gt;→&lt;DECL_STAT&gt;|&lt;DECL_LIST&gt;&lt;DECL_STAT&gt;			//声明列表
&lt;STAT_LIST&gt;→&lt;STAT&gt;|&lt;STAT_LIST&gt;&lt;STAT&gt;					//语句列表

&lt;STAT&gt;→&lt;BLOCK&gt;|&lt;EXPR_STAT&gt;|&lt;SELECT_STAT&gt;|&lt;LOOP_STAT&gt;|&lt;JUMP_STAT&gt;//语句

&lt;BLOCK&gt;→&lt;{&gt;&lt;}&gt;|&lt;{&gt;&lt;STAT_LIST&gt;&lt;}&gt;|&lt;{&gt;&lt;DECL_LIST&gt;&lt;STAT_LIST&gt;&lt;}&gt;	//复合语句
&lt;EXPR_STAT&gt;→&lt;;&gt;|&lt;UNARY_EXPR&gt;&lt;=&gt;&lt;EXPR&gt;&lt;;&gt;		//表达式语句
&lt;EXPR&gt;→&lt;ARITHMETIC&gt;|&lt;LOGIC&gt;						//表达式

//算术表达式
&lt;ARITHMETIC&gt;→&lt;ARM_EXPR&gt;
&lt;ARM_EXPR&gt;→&lt;ARM_EXPR&gt;&lt;+&gt;&lt;ADD_FACT&gt;|&lt;ARM_EXPR&gt;&lt;-&gt;&lt;ADD_FACT&gt;|&lt;ADD_FACT&gt;
&lt;ADD_FACT&gt;→&lt;ADD_FACT&gt;&lt;*&gt;&lt;MUL_FACT&gt;|&lt;ADD_FACT&gt;&lt;/&gt;&lt;MUL_FACT&gt;|&lt;ADD_FACT&gt;&lt;%&gt;&lt;MUL_FACT&gt;|&lt;MUL_FACT&gt;
&lt;MUL_FACT&gt;→&lt;SIGN&gt;&lt;UNARY_EXPR&gt;|&lt;SIGN&gt;&lt;INTEGER&gt;
&lt;SIGN&gt;→&lt;-&gt;|^		// 正/负号

//布尔表达式
&lt;LOGIC&gt;→&lt;BOOL&gt;
&lt;BOOL&gt;→&lt;BOOL&gt;&lt;||&gt;&lt;OR_FACT&gt;|&lt;OR_FACT&gt;
&lt;OR_FACT&gt;→&lt;OR_FACT&gt;&lt;&amp;&amp;&gt;&lt;AND_FACT&gt;|&lt;AND_FACT&gt;
&lt;AND_FACT&gt;→&lt;!&gt;&lt;BOOL_VALUE&gt;|&lt;BOOL_VALUE&gt;
&lt;BOOL_VALUE&gt;→&lt;ARITHMETIC&gt;&lt;ROP&gt;&lt;ARITHMETIC&gt;|&lt;UNARY_EXPR&gt;
&lt;ROP&gt;→&gt;|&lt;|&gt;=|&lt;=|==|!=

//选择语句、循环语句、跳转语句
&lt;SELECT_STAT&gt;→&lt;if&gt;&lt;(&gt;&lt;BOOL&gt;&lt;)&gt;&lt;STAT&gt;|&lt;if&gt;&lt;(&gt;&lt;BOOL&gt;&lt;)&gt;&lt;STAT&gt;&lt;else&gt;&lt;STAT&gt;
&lt;LOOP_STAT&gt;→&lt;while&gt;&lt;(&gt;&lt;BOOL&gt;&lt;)&gt;&lt;STAT&gt;|&lt;for&gt;&lt;(&gt;&lt;EXPR_STAT&gt;&lt;EXPR_STAT&gt;&lt;EXPR_STAT&gt;&lt;)&gt;&lt;STAT&gt;
&lt;JUMP_STAT&gt;→&lt;continue&gt;&lt;;&gt;|&lt;break&gt;&lt;;&gt;|&lt;return&gt;&lt;;&gt;|&lt;return&gt;&lt;EXPR&gt;&lt;;&gt;
</code></pre>
<h2 id="另一个定义如下">另一个定义如下：</h2>
<pre><code class="language-c++">  &lt;程序&gt;→&lt;外部声明&gt;|&lt;程序&gt;&lt;外部声明&gt;

  &lt;外部声明&gt;→&lt;函数定义&gt;|&lt;声明&gt;

  &lt;函数定义&gt;→&lt;类型说明&gt;&lt;声明&gt;&lt;复合语句&gt;

  &lt;类型说明&gt;→void|char|int |float

  &lt;声明&gt;→&lt;指针直接说明符&gt;|&lt;直接说明符&gt;

  &lt;指针&gt;→’*‘|'*'指针

  &lt;直接说明符&gt;→&lt;标识符&gt;|&lt;直接说明符‘[’‘]’&gt;|&lt;直接说明符‘[’常数表达式‘]’&gt; |&lt;标识符‘（’参数列表‘）’&gt;|&lt;标识符&gt;&lt;‘（’‘）’&gt;&gt;|&lt;直接说明符&gt;&lt;'，'&gt;&lt;标识符列表&gt;

  &lt;标识符列表&gt;→&lt;:标识符&gt;|&lt;标识符列表&gt;&lt;'，'&gt;&lt;标识符&gt;

  &lt;常数表达式&gt;→&lt;条件表达式&gt;

  &lt;参数列表&gt;→&lt;参数声明&gt;|&lt;参数列表&gt;&lt;','&gt;&lt;参数声明&gt;

  &lt;参数声明&gt;→&lt;声明说明符&gt;&lt;标识符&gt;

  &lt;复合语句&gt;→&lt;‘{’&gt;&lt;‘}’&gt;|&lt;'{'&gt;&lt;语句列表&gt;&lt;'}'&gt;|&lt;'{'&gt;&lt;声明列表&gt;&lt;语句列表&gt;&lt;'}'&gt;

  &lt;声明列表&gt;→&lt;声明&gt;|&lt;声明列表&gt;&lt;声明&gt;

  &lt;声明&gt;→&lt;初始化声明&gt;|&lt;初始化声明列表&gt;&lt;‘，’&gt;&lt;初始化声明&gt;

  &lt;初始化声明&gt;→&lt;声明&gt;|&lt;声明&gt;&lt;‘=’&gt;&lt;初始化程序&gt;

  &lt;初始化程序&gt;→&lt;赋值表达式&gt;|&lt;‘{’&gt;&lt;初始化程序列表&gt;&lt;‘}’&gt;|&lt;'{'&gt;&lt;初始化程序列表&gt;&lt;','&gt;&lt;'}'&gt;

  &lt;初始化程序列表&gt;→&lt;初始化程序&gt;|&lt;初始化程序列表&gt;&lt;‘，’&gt;&lt;初始化程序&gt;

  &lt;语句列表&gt;→&lt;语句&gt;|&lt;语句列表&gt;&lt;语句&gt;

  &lt;语句&gt;→&lt;复合语句&gt;|&lt;表达式语句&gt;|&lt;选择语句&gt;|&lt;循环语句&gt;|&lt;跳跃语句&gt;

  &lt;表达式语句&gt;→&lt;';'&gt;|&lt;表达式&gt;&lt;'；'&gt;

  &lt;选择语句&gt;→&lt;:&gt;&lt;if&gt;&lt;'('&gt;&lt;表达式&gt;&lt;')'&gt;&lt;语句&gt;|&lt;if&gt;&lt;'('&gt;&lt;表达式&gt;&lt;')'&gt;&lt;语句&gt;&lt;else&gt;&lt;语句&gt;

  &lt;循环语句&gt;→&lt;while&gt;&lt;'('&gt;&lt;表达式&gt;&lt;')'&gt;&lt;语句&gt;|&lt;for&gt;&lt;'('&gt;&lt;表达式语句&gt;&lt;表达式语句&gt;&lt;')'&gt;&lt;语句&gt;|&lt;for&gt;&lt;'('&gt;&lt;表达式语句&gt;&lt;表达式语句&gt;&lt;表达式&gt;&lt;')'&gt;&lt;语句&gt;

  &lt;跳跃语句&gt;→ CONTINUE&lt; ';'&gt;| BREAK &lt;';'&gt;| RETURN &lt;';'&gt;| RETURN &lt;表达式&gt; &lt;';'&gt;

  &lt;表达式&gt;→&lt;：&gt;&lt;赋值表达式&gt;|&lt;表达式&gt;&lt;','&gt;&lt;赋值表达式&gt;

  &lt;赋值表达式&gt;→&lt;条件表达式&gt;|&lt;一元表达式&gt;&lt;赋值操作符&gt;&lt;赋值表达式&gt;

  &lt;条件表达式&gt;→&lt;逻辑或表达&gt; | &lt;逻辑或表达&gt;&lt;‘?‘&gt; &lt;表达式&gt;&lt; ‘:‘&gt;&lt;条件表达式&gt;

&lt;逻辑或表达&gt;→&lt;逻辑与表达&gt;  |&lt; 逻辑或表达 或运算&gt;&lt;逻辑表达式&gt;

 &lt; 逻辑与表达&gt;：&lt;或表达式&gt; |&lt; 逻辑表达式 &gt;和&lt;运算或表达式&gt;

&lt; 或运算表达式&gt;→&lt;异或表达式&gt; |&lt; 或运算表达式 &gt;&lt;‘&gt;|&lt;‘&gt;&lt; 异或表达式&gt;

&lt; 异或表达式&gt;：&lt;与表达式&gt; | &lt; 异或表达式&gt;&lt;‘^‘&gt;&lt;与表达式&gt;

&lt; 与表达式&gt;：&lt;相等表达式&gt; |&lt; 与表达式&gt;&lt;‘&amp;‘&gt;&lt;相等表达式&gt;

&lt; 相等表达式&gt;：&lt;关系表达式&gt; |&lt; 相等表达式等于运算关系表达式&gt; | &lt;相等表达式不等于运算关系表达式&gt;

&lt; 关系表达式&gt;：&lt;移位表达式&gt; | &lt;关系表达式&gt;&lt;‘&lt;‘&gt;&lt;移位表达式 &gt;|&lt; 关系表达式&gt;&lt;‘&gt;‘&gt;&lt;移位表达式&gt;  |&lt;  关系表达式小于等于运算移位表达式&gt; |&lt; 关系表达式大于等于运算移位表达式&gt;

&lt; 移位表达式&gt;：&lt;加法表达式&gt; | &lt;移位表达式左运算加法表达式&gt;  |&lt; 移位表达式右运算加法表达式&gt;

&lt; 加法表达式：&lt;乘法表达式&gt; |&lt; 加法表达式&gt;&lt;‘+‘&gt;&lt;乘法表达式&gt; |&lt; 加法表达式&gt;&lt;‘-‘&gt;&lt;乘法表达式&gt;

&lt; 乘法表达式&gt;：&lt;强制转换表达式&gt; | &lt;乘法表达式&gt;&lt;‘*‘&gt;&lt;强制转换表达式&gt; | &lt;乘法表达式&gt;&lt;‘/‘&gt;&lt;强制转换表达式 &gt;| &lt;乘法表达式&gt;&lt;‘%‘&gt;&lt;强制转换表达式&gt;

&lt;  强制转换表达式&gt;：&lt;一元表达式&gt;  |&lt;  ‘(‘&gt;&lt; 类型名称 &gt;&lt;‘)‘&gt;&lt;强制转换表达式&gt;

&lt;一元表达式&gt;：&lt;后缀表达式&gt; | &lt;INC运算一元表达式&gt; |&lt; DEC运算一元表达式&gt; |&lt; 一元运算符将表达式&gt; | &lt; 结构体变量的一元表达式 &gt;| &lt; 结构体变量的&gt;&lt;‘(‘&gt;&lt; 类型名称&gt;&lt; ‘)‘&gt;

&lt;后缀表达式&gt;：&lt;基本表达式&gt; | &lt;后缀表达式&gt;&lt;‘[‘&gt;&lt;表达式&gt;&lt;‘]‘&gt;  |&lt; 后缀表达式&gt;&lt;‘(‘ &gt;&lt;‘)'&gt; | &lt;后缀表达式&gt;&lt; ‘(‘&gt;&lt;参数表达式列表&gt;&lt;‘)‘ &gt;  | &lt;后缀表达式&gt;&lt;‘.‘&gt;&lt; 标识符 &gt;| &lt;后缀表达式指针运算标识符&gt;    |&lt; 后缀表达式INC运算&gt;  |&lt; 后缀表达式DEC运算&gt;

&lt;基本表达式&gt;→&lt;标识符&gt;  |&lt;常量 &gt;| &lt;字符串常量&gt; | &lt; ‘(‘&gt;&lt;表达式&gt;&lt;‘)‘&gt;

&lt;参数表达式列表&gt;:&lt; 赋值表达式 &gt;| &lt;参数表达式列表&gt;&lt;‘,‘&gt;&lt;赋值表达式&gt;

&lt;一元运算符&gt;:&lt; ‘&amp;‘&gt;  | &lt; ‘*‘&gt;  | &lt; ‘+‘&gt;  | &lt; ‘-‘&gt;  | &lt; ‘~‘&gt;  |&lt;  ‘!‘&gt;

&lt;赋值运算符&gt;→&lt;‘=‘&gt;  |&lt; 乘法分配&gt; | &lt;DIV分配&gt; |&lt; MOD分配&gt; | &lt;加法分配&gt;  | &lt; SUB分配&gt;  |&lt; 左分配 &gt;| &lt;右分配与分配&gt;|&lt; 异或分配 &gt;|&lt;或分配&gt;

&lt;存储类说明符&gt;→&lt;定义类型&gt; |&lt; 外部变量&gt; |&lt; 静态  &gt;|&lt; 自动&gt;  | &lt;寄存器&gt; 

&lt;结构或联合说明符&gt;：&lt;结构或联合标识符&gt;&lt;‘{‘&gt;&lt;结构体声明列表&gt;&lt;‘}‘&gt;  |&lt; 结构或联合&gt;&lt;‘{'&gt;&lt;结构体声明列表&gt;&lt;‘}‘ &gt; |&lt; 结构或联合标识符&gt;

&lt;结构或联合&gt;：&lt;结构体&gt; |&lt; 联合&gt;

&lt;结构体声明列表&gt;：&lt;结构体声明&gt; |&lt; 结构体列表声明结构体声明&gt;

&lt;结构体声明&gt;：&lt;说明符限定符列表结构说明符&gt;&lt;‘;‘&gt;

&lt;说明符说明符限定符列表&gt; →&lt;类型说明符说明符限定符列表&gt; |&lt; 类型说明符&gt;  |&lt; 类型限定符说明符限定符列表 &gt;| &lt;类型限定符&gt;

&lt;结构说明符列表&gt;→&lt;结构体声明&gt; |&lt; 结构说明符列表&gt;&lt;‘,‘&gt;&lt;结构体声明&gt;

&lt;结构体声明&gt;→&lt;：&gt;&lt;声明 &gt;| &lt; ‘:‘&gt;&lt;常量表达式&gt; |&lt; 声明&gt;&lt;‘:‘&gt;&lt;常量表达式&gt;

&lt;枚举声明&gt;→&lt;枚举&gt;&lt;‘{‘&gt;&lt;枚举器列表&gt;&lt;‘}‘&gt;  | &lt;枚举标识符&gt;&lt;‘{‘&gt;&lt;枚举器列表&gt;&lt;‘}‘&gt;  | &lt;枚举标识符&gt;

&lt;枚举器列表&gt;→&lt;枚举器&gt; | &lt;枚举器列表&gt;&lt;‘,‘&gt;

  &lt;枚举器枚举器&gt;→&lt;标识符 &gt;|&lt; 标识符&gt;&lt;‘=‘&gt;&lt;常量表达式&gt;

  &lt;类型限定符&gt;→&lt;常量 &gt;|&lt; 易失的&gt;

  &lt;类型限定符列表&gt;→&lt;类型限定符&gt; | &lt;类型限定符列表&gt;&lt;  类型限定符&gt;

  &lt;参数类型列表&gt;→&lt;参数列表&gt; | &lt;参数列表&gt;&lt;‘,‘&gt;&lt;省略符号&gt;

  &lt;参数列表&gt;→&lt;：&gt;&lt;声明参数&gt; |&lt; 参数列表&gt;&lt;‘,‘&gt;&lt;声明参数&gt;

  &lt;抽象说明符&gt;→&lt;指针&gt; | &lt;直接抽象说明符&gt; | &lt;指针直接抽象说明符&gt;

  &lt;直接抽象说明符&gt;→ &lt;‘(‘&gt; &lt;抽象说明符 &gt;&lt;‘)‘ &gt; |&lt;  ‘[‘ &gt;&lt;‘]‘  &gt;| &lt; ‘[‘&gt;&lt; 常量表达式&gt;&lt;‘]‘&gt;| &lt;直接抽象说明符&gt;&lt;‘[‘&gt;&lt; ‘]‘&gt;  | &lt;直接抽象说明符&gt;&lt;‘[‘&gt;&lt; 常量表达式&gt;&lt; ‘]‘&gt;  | &lt; ‘(‘&gt;&lt; ‘)‘&gt;  | &lt; ‘(‘&gt;&lt;参数类型列表&gt;&lt;‘)‘&gt;  |&lt;  直接抽象说明符&gt;&lt;‘(‘&gt;&lt; ‘)‘&gt;  | &lt;直接抽象说明符&gt;&lt;‘(‘&gt;&lt;参数类型列表&gt;&lt;‘)‘&gt;

&lt;有标号语句&gt;→&lt;标识符&gt;&lt;‘:&gt;&lt;‘语句&gt; |  &lt;CASE常量表达式&gt;&lt;‘:‘&gt;&lt;语句 &gt; | &lt; DEFAULT&gt;&lt;‘:‘&gt;&lt;语句&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何白嫖到学习通上的课件（]]></title>
        <id>https://alittlewhiter.github.io/post/ru-he-bai-piao-dao-xue-xi-tong-shang-de-ke-jian-ppt/</id>
        <link href="https://alittlewhiter.github.io/post/ru-he-bai-piao-dao-xue-xi-tong-shang-de-ke-jian-ppt/">
        </link>
        <updated>2020-04-11T10:55:06.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：超星学习通，课件下载，PPT下载</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：超星学习通，课件下载，PPT下载</p>
<!-- more -->
<ol>
<li>手机客户端？木大木大、Sayonara。。。（可以查查软件数据缓存目录。。</li>
</ol>
<div style="width: 90px; text-align:center;" >
<figure data-type="image" tabindex="1"><img src="https://alittlewhiter.github.io/post-images/1586603813353.jpg" alt="" loading="lazy"></figure>
</div>
<ol start="2">
<li>
<p>网页端打开超星学习通个人主页，点击课程进入想要下载课件的章节任务点、<br>
<img src="https://alittlewhiter.github.io/post-images/1586603166659.png" alt="" loading="lazy"></p>
</li>
<li>
<p>按下F12键显示源代码界面；按下Ctrl+F键出现一个搜索的小框，在里面输入objectid，回车查找。<br>
<img src="https://alittlewhiter.github.io/post-images/1586603173958.png" alt="" loading="lazy"></p>
</li>
<li>
<p>.复制这个objectid后面对应的id字符串，此页面上放了几个课件就有几个id。一个简单方法：找到mArg，并点击这块区域，在控制台输入<code>mArg.attachments[0].property.objectid</code>， 回车即可返回objectid字符串，操作如下：<br>
<img src="https://alittlewhiter.github.io/post-images/1590024213108.png" alt="" loading="lazy"><br>
<img src="https://alittlewhiter.github.io/post-images/1590024357287.png" alt="" loading="lazy"></p>
</li>
<li>
<p>在浏览器的地址栏输入<code>http://d0.ananas.chaoxing.com/download/YOUR_ID</code> ，将复制的id连接在后面，回车会弹出该课件的下载框（一般为ppt, pdf 文档格式或mp4视频格式），选择你保存课件的位置，点击保存即可。<br>
<img src="https://alittlewhiter.github.io/post-images/1586603382563.png" alt="" loading="lazy"><br>
<img src="https://alittlewhiter.github.io/post-images/1586603371738.png" alt="" loading="lazy"></p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[瞎几把扯下排序...]]></title>
        <id>https://alittlewhiter.github.io/post/xia-ji-ba-che-xia-pai-xu/</id>
        <link href="https://alittlewhiter.github.io/post/xia-ji-ba-che-xia-pai-xu/">
        </link>
        <updated>2020-04-03T08:13:25.000Z</updated>
        <summary type="html"><![CDATA[<p>keywords: 经典排序算法，C/C++，笔记备忘</p>
<p>pro, 太pro了！</p>
]]></summary>
        <content type="html"><![CDATA[<p>keywords: 经典排序算法，C/C++，笔记备忘</p>
<p>pro, 太pro了！</p>
<!-- more -->
<h2 id="排序的概念">排序的概念</h2>
<p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。</p>
<p>排序分为内部排序和外部排序。</p>
<p>若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。</p>
<p>反之，若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序。</p>
<h2 id="排序的分类">排序的分类</h2>
<p>这里主要介绍的八种排序算法均属于<code>内部排序</code>。如果按照策略来分类，大致可分为：交换排序、插入排序、选择排序、归并排序和基数排序。如下图所示：<br>
<img src="https://alittlewhiter.github.io/post-images/1585901877572.jpg" alt="" loading="lazy"></p>
<h2 id="算法概述">算法概述</h2>
<ol>
<li>
<p>插入排序<br>
<strong>直接插入排序</strong><br>
将第一个和第二个元素排好序，然后将第3个元素插入到已经排好序的元素中，依次类推（插入排序最好的情况就是数组已经有序了）</p>
<p><strong>希尔排序</strong><br>
因为插入排序每次只能操作一个元素，效率低。希尔排序对待排序的N个元素，取奇数k=N/2，将下标差值为k的数分为一组（一组元素个数看总元素个数决定），在组内构成有序序列，再取k=k/2，将下标差值为k的数分为一组，构成有序序列，直到k=1，然后再进行直接插入排序。</p>
</li>
<li>
<p>选择排序<br>
<strong>简单选择排序</strong><br>
选出最小的数和第一个数交换，再在剩余的数中又选择最小的和第二个数交换，依次类推。</p>
<p><strong>堆排序</strong><br>
以升序排序为例，利用<code>小根堆</code>或<code>大根堆</code>的性质，不断输出最小元素或移动最大元素，直到堆中元素全部有序。</p>
</li>
<li>
<p>交换排序<br>
<strong>冒泡排序</strong><br>
改进1：如果某次冒泡不存在数据交换，则说明已经排序好了，可以直接退出排序。<br>
改进2：头尾进行冒泡，每次把最大的沉底，最小的浮上去，两边往中间靠1。</p>
<p><strong>快速排序</strong><br>
选择一个基准元素，比基准元素小的放基准元素的前面，比基准元素大的放基准元素的后面，这种动作叫分区，每次分区都把一个数列分成了两部分，每次分区都使得一个数字有序，然后将基准元素前面部分和后面部分继续分区，一直分区直到分区的区间中只有一个元素</p>
</li>
<li>
<p>归并排序<br>
<strong>一般归并排序</strong><br>
将一个无序的数列一直一分为二，直到分到序列中只有一个数的时候，这个序列肯定是有序的，因为只有一个数，然后将两个只含有一个数字的序列合并为含有两个数字的有序序列，这样一直进行下去，最后就变成了一个全部的有序数列，合并时一般需要额外的内存空间用于存放临时数组。</p>
<p><strong>在位归并排序</strong><br>
不需要辅助数组即可实现分区的合并。</p>
</li>
<li>
<p>基数排序<br>
找到最大的数，开个比最大的数大一点的数组，遍历每个元素，某个元素为k，则a[k]++,最好遍历数组a，a[k]等于多少就输出多少个k，只能处理整型数。</p>
</li>
<li>
<p>计数排序。。。</p>
</li>
</ol>
<p>又或者按照排序稳定性：</p>
<p><strong>不稳定排序</strong>：简单选择排序，快速排序，希尔排序，堆排序<br>
<strong>稳定排序</strong>：冒泡排序，直接插入排序，归并排序，基数排序</p>
<h2 id="代码分析">代码分析</h2>
<ol>
<li>
<p>直接插入排序（Insertion Sort)<br>
<strong>算法思想</strong>：直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过 因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成：<br>
<mark>第一层循环</mark>：遍历待比较的所有数组元素<br>
<mark>第二层循环</mark>：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。如果：selected &gt; ordered，那么将二者交换。</p>
<pre><code class="language-c++">void InsertSort(int a[], int n) {
    for(int i= 1; i&lt;n; i++) {
        if(a[i] &lt; a[i-1]) {   //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
            int j= i-1;  
            int x = a[i];     //复制为哨兵，即存储待排序元素
            a[i] = a[i-1];           //先后移一个元素
            while(x &lt; a[j]){   //查找在有序表的插入位置
                a[j+1] = a[j];
                j--;     //元素后移
            }
            a[j+1] = x;     //插入到正确位置
        }
    }
}
</code></pre>
</li>
<li>
<p>希尔排序（Shell‘s Sort）</p>
<p><strong>算法思想</strong>：希尔排序也称 <code>递减增量排序</code> 算法，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法。希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p>算法步骤：</p>
<ul>
<li>
<p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</p>
</li>
<li>
<p>按增量序列个数k，对序列进行k 趟排序；</p>
</li>
<li>
<p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ul>
<p>图<img src="https://alittlewhiter.github.io/post-images/1585911980835.png" alt="" loading="lazy"></p>
<pre><code class="language-c++">void ShellInsertSort(int a[], int n, int dk) {
    for(int i= dk; i&lt;n; ++i) {
        if(a[i] &lt; a[i-dk]) {      //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
            int j = i-dk;  
            int x = a[i];      //复制为哨兵，即存储待排序元素
            a[i] = a[i-dk];      //首先后移一个元素
            while(x &lt; a[j]) {    //查找在有序表的插入位置
                a[j+dk] = a[j];
                j -= dk;       //元素后移
            }
            a[j+dk] = x;      //插入到正确位置
        }
    }
}

 // 先按增量d（n/2,n为要排序数的个数进行希尔排序
void shellSort(int a[], int n) {
    int dk = n/2;
    while( dk &gt;= 1  ){
        ShellInsertSort(a, n, dk);
        dk = dk/2;
    }
}
</code></pre>
<p>关于增量序列的选择：</p>
<ul>
<li></li>
</ul>
</li>
</ol>
<p>​</p>
<ol start="3">
<li>
<p><strong>简单选择排序（Selection Sort）</strong></p>
<p>算法思想：简单选择排序的实现思想：<code>比较+交换</code></p>
<ol>
<li>从待排序序列中，找到关键字最小的元素；</li>
<li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li>
<li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。因此我们可以发现，简单选择排序也是通过两层循环实现。第一层循环：依次遍历序列当中的每一个元素 第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。</li>
</ol>
<pre><code class="language-c++">int SelectMinKey(int a[], int n, int i) {
    int k = i;
    for(int j=i+1 ; j&lt; n; ++j) 
        if(a[k] &gt; a[j])
            k = j;
    return k;
}

void selectSort(int a[], int n) {
    int key, tmp;
    for(int i = 0; i&lt; n; ++i) {
        key = SelectMinKey(a, n,i);           //选择最小的元素
        if(key != i) {
            tmp = a[i];
            a[i] = a[key];
            a[key] = tmp; 			//最小元素与第i位置元素互换
        }
    }
}
</code></pre>
</li>
<li>
<p>堆排序（Heap Sort）</p>
<p><strong>堆的概念</strong>：<mark>堆</mark>本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆：</p>
<ul>
<li>
<p>大顶堆要求节点的元素都要大于其孩子。</p>
</li>
<li>
<p>小顶堆要求节点元素都小于其左右孩子。</p>
</li>
</ul>
<p>两者对左右孩子的大小关系不做任何要求。</p>
<p>利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法，下面通过大顶堆来实现。</p>
<p>基本思想：堆排序可以按照以下步骤来完成：</p>
<ol>
<li>
<p>首先将序列构建称为大顶堆；（这样满足了大顶堆的性质：位于根节点的元素一定是当前序列的最大值）</p>
</li>
<li>
<p>取出当前大顶堆的根节点，将其与序列末尾元素进行交换；（此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质）</p>
</li>
<li>
<p>对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质；</p>
</li>
<li>
<p>重复2.3步骤，直至堆中只有1个元素为止</p>
</li>
</ol>
<pre><code class="language-c++">/**
 * 已知H[s…m]除了H[s] 外均满足堆的定义
 * 调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选,
 *
 * @param H是待调整的堆数组
 * @param s是待调整的数组元素的位置
 * @param length是数组的长度
 */
void HeapAdjust(int H[],int s, int length) {
    int tmp  = H[s];
    int child = 2*s+1; //左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置)
    while (child &lt; length) {
        if(child+1 &lt;length &amp;&amp; H[child]&lt;H[child+1]) { // 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点)
            ++child ;
        }
        if(H[s]&lt;H[child]) {     // 如果较大的子结点大于父结点
            H[s] = H[child];    // 那么把较大的子结点往上移动，替换它的父结点
            s = child;          // 重新设置s ,即待调整的下一个结点的位置
            child = 2*s+1;
        }  else {               // 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出
            break;
        }
        H[s] = tmp;             // 当前待调整的结点放到比其大的孩子结点位置上
    }
}

void HeapSort(int H[],int length) {
    //建立初始堆
    //最后一个有孩子的节点的位置 i=  (length -1) / 2
    for (int i = (length -1) / 2 ; i &gt;= 0; --i)
        HeapAdjust(H,i,length);
    
    //从最后一个元素开始对序列进行调整
    for (int i = length - 1; i &gt; 0; --i) {
        //交换堆顶元素H[0]和堆中最后一个元素
        int temp = H[i];
        H[i] = H[0];
        H[0] = temp;
        //每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整
        HeapAdjust(H,0,i);
    }
}

</code></pre>
</li>
<li>
<p>冒泡排序（Bubble Sort）</p>
<p><strong>算法思想</strong>：冒泡遍历所有的数据，每次对相邻元素进行两两比较，如果顺序和预先规定的顺序不一致，则进行位置交换；这样一次遍历会将最大或最小的数据上浮到顶端，之后再重复同样的操作，直到所有的数据有序。</p>
<p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，冒泡排序算法的运作如下：</p>
<ul>
<li>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li>
<p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li>
<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
</li>
</ul>
<pre><code class="language-c++">void bubbleSort(int a[], int n) {
    for(int i =0 ; i&lt; n-1; ++i) {
        for(int j = 0; j &lt; n-i-1; ++j) {
            if(a[j] &gt; a[j+1]) {
                int tmp = a[j] ;
                a[j] = a[j+1] ;
                a[j+1] = tmp;
            }
        }
    }
}
</code></pre>
</li>
<li>
<p><strong>快速排序（Quick Sort）</strong></p>
<p><strong>算法思想</strong>：快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n logn)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。</p>
<p>事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>算法步骤：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）。</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。</li>
</ol>
<pre><code class="language-c++">void swap(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int partition(int a[], int low, int high) {
    int privotKey = a[low];                //基准元素
    while(low &lt; high) {                   //从表的两端交替地向中间扫描
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey)
            --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端
        swap(&amp;a[low], &amp;a[high]);
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey )
            ++low;
        swap(&amp;a[low], &amp;a[high]);
    }
    return low;
}


void quickSort(int a[], int low, int high) {
    if(low &lt; high) {
        int privotLoc = partition(a,  low,  high);  //将表一分为二
        quickSort(a,  low,  privotLoc -1);      //递归对低子表递归排序
        quickSort(a,   privotLoc + 1, high);    //递归对高子表递归排序
    }
}
</code></pre>
</li>
<li>
<p><strong>归并排序（Merge Sort）</strong></p>
<p><strong>算法思想</strong>：归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>算法步骤：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤3直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<pre><code class="language-c++">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]
void Merge(ElemType *r,ElemType *rf, int i, int m, int n) {
    int j,k;
    for(j=m+1,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k) {
        if(r[j] &lt; r[i])
            rf[k] = r[j++];
        else
            rf[k] = r[i++];
    }
    while(i &lt;= m)
        rf[k++] = r[i++];
    while(j &lt;= n)
        rf[k++] = r[j++];
}

void MergeSort(ElemType *r, ElemType *rf, int lenght) {
    int len = 1;
    ElemType *q = r ;
    ElemType *tmp ;
    while(len &lt; lenght) {
        int s = len;
        len = 2 * s ;
        int i = 0;
        while(i+ len &lt;lenght) {
            Merge(q, rf,  i, i+ s-1, i+ len-1 ); //对等长的两个子表合并
            i = i+ len;
        }
        if(i + s &lt; lenght) {
            Merge(q, rf,  i, i+ s -1, lenght -1); //对不等长的两个子表合并
        }
        tmp = q;
        q = rf;
        rf = tmp; //交换q,rf，以保证下一趟归并时，仍从q 归并到rf
    }
}
</code></pre>
<p>一般在提到<a href="http://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a>时，大都想到上面分治Divide-and-Conqure算法, 它一般是O(nlgn)的时间复杂度以及额外的O(n)空间。，但实际上<strong>O(n)的额外空间</strong>这一缺点是完全可以克服的，完全<code>可以实现O(nlgn) 时间效率以及 O(1) 额外空间</code> 的归并排序。对于这种不用额外空间(即<code>常数大小的额外空间</code>)的算法，有一个通用的名字叫做In-place Algorithms，因此我们称该归并算法为 <code>In-place merge sort</code> ，也就是<code>在位归并排序</code> 。</p>
<p><strong>在位归并排序</strong>：</p>
<p>在C++头文件中有在位归并排序的模板实现：<code>#include&lt;algorithm&gt;</code>  ，<code>void std::inplace_merge(_BIter, _BIter, _BIter);</code></p>
<pre><code class="language-c++">#include&lt;algorithm&gt;

int num[arrayLength];

mergesort(0, arrayLength-1);		// main()函数调用

void mergesort(int left,int right) {
    if(left&gt;=right)
        return;
    int mid=(left+right)/2;
    mergesort(left,mid);
    mergesort(mid+1,right);
    inplace_merge(number+left, number+mid+1, number+right+1);
}
</code></pre>
<p>另外，还可以通过 <code>循环左移</code> 来实现归并操作：</p>
<pre><code class="language-c++">//将长度为n的数组逆序
void reverse(int *arr,int n) {
    int i=0,j=n-1;
    while(i&lt;j) {
        swap(arr[i],arr[j]);
        i++;
        j--;
    }
}

//将数组向左循环移位i个位置
void exchange(int *arr,int n,int i) {
    reverse(arr,i);
    reverse(arr+i,n-i);
    reverse(arr,n);
}

//数组两个有序部分的归并
void merge(int *arr,int begin,int mid,int end) {
    int i=begin,j=mid,k=end;
    while(i&lt;j &amp;&amp; j&lt;=k) {
        int step=0;
        while(i&lt;j &amp;&amp; arr[i]&lt;=arr[j])
            ++i;
        while(j&lt;=k &amp;&amp; arr[j]&lt;=arr[i]) {
            ++j;
            ++step;
        }
        exchange(arr+i,j-i,j-i-step);
        i=i+step;
    }
}

void MergeSort(int *arr,int l,int r) {
    if(l&lt;r) {
        int mid=(l+r)/2;
        MergeSort(arr,l,mid);
        MergeSort(arr,mid+1,r);
        merge(arr,l,mid+1,r);
    }
}
</code></pre>
</li>
<li>
<p><strong>基数排序(Radix Sort)</strong></p>
<p><strong>算法思想</strong>：基数排序 通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p>
<p>分配：将 L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中 。</p>
<p>收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列 L[ ] 。</p>
<p>对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束。</p>
<pre><code class="language-c++">void RadixSort(Node L[],length,maxradix) {
    int m,n,k,lsp;
    k=1;
    m=1;
    int temp[10][length-1];
    Empty(temp); //清空临时空间
    while(k&lt;maxradix) { //遍历所有关键字
        for(int i=0; i&lt;length; i++) { //分配过程
            if(L[i]&lt;m)
                Temp[0][n]=L[i];
            else
                Lsp=(L[i]/m)%10; //确定关键字
            Temp[lsp][n]=L[i];
            n++;
        }
        CollectElement(L,Temp); //收集
        n=0;
        m=m*10;
        k++;
    }
}

</code></pre>
</li>
</ol>
<h2 id="总结分析">总结分析</h2>
<p>各算法の时间复杂度函数O(n)的增长情况如图：<br>
<img src="https://alittlewhiter.github.io/post-images/1585912012375.png" alt="" loading="lazy"></p>
<p>所以对n较大的排序记录，一般的选择都是时间复杂度为O(nlog2n)的排序方法。</p>
<ol>
<li>
<p>平方阶(O(n2))排序</p>
<p>各类简单排序:直接插入、直接选择和冒泡排序；</p>
</li>
<li>
<p>线性对数阶(O(nlog2n))排序</p>
<p>快速排序、堆排序和归并排序；</p>
</li>
<li>
<p>O(n1+§))排序,§是介于0和1之间的常数。</p>
<p>希尔排序</p>
</li>
<li>
<p>线性阶(O(n))排序</p>
<p>基数排序，此外还有桶排序、箱排序。</p>
</li>
</ol>
<p><em><strong>因此</strong></em>：</p>
<ul>
<li>
<p>当原表有序或基本有序时，<code>直接插入排序</code>和<code>冒泡排序</code>将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</p>
</li>
<li>
<p>而<code>快速排序</code>则相反，<mark>当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）</mark>；</p>
</li>
<li>
<p>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</p>
</li>
</ul>
<p><strong>排序算法的稳定性</strong>: 若待排序的序列中，存在多个<code>具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变</code>，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。</p>
<p><strong>稳定性的好处</strong>：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。</p>
<ul>
<li>
<p>基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；</p>
</li>
<li>
<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</p>
</li>
<li>
<p>不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</p>
</li>
</ul>
<h2 id="何种排序算法">何种排序算法？</h2>
<p>考虑的因素有以下四点：</p>
<ol>
<li>
<p>待排序的记录数目n的大小；</p>
</li>
<li>
<p>记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</p>
</li>
<li>
<p>关键字的结构及其分布情况；</p>
</li>
<li>
<p>对排序稳定性的要求。</p>
</li>
</ol>
<p>具体来说：设待排序元素的个数为n</p>
<p>1）当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：<code>快速排序</code>、<code>堆排序</code>或<code>归并排序</code>。</p>
<ul>
<li>
<p>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p>
</li>
<li>
<p>堆排序 ： 如果内存空间允许且要求稳定性的，</p>
</li>
<li>
<p>归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</p>
</li>
</ul>
<p>2） 当n较大，内存空间允许，且要求稳定性：归并排序</p>
<p>3）当n较小，可采用直接插入或直接选择排序。</p>
<ul>
<li>
<p>直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。</p>
</li>
<li>
<p>直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序</p>
</li>
</ul>
<p>4）一般不使用或不直接使用传统的冒泡排序。</p>
<p>5）基数排序</p>
<ul>
<li>它是一种稳定的排序算法，但有一定的局限性：
<ol>
<li>关键字可分解。</li>
<li>记录的关键字位数较少，如果密集更好。</li>
<li>如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P r o v e r]]></title>
        <id>https://alittlewhiter.github.io/post/prover/</id>
        <link href="https://alittlewhiter.github.io/post/prover/">
        </link>
        <updated>2020-03-31T09:11:03.000Z</updated>
        <summary type="html"><![CDATA[<p>证明。。。</p>
]]></summary>
        <content type="html"><![CDATA[<p>证明。。。</p>
<!-- more -->
<h2 id="floyd算法的正确性证明">Floyd算法的正确性证明</h2>
<ul>
<li>用数学归纳法证明： 假设存在一条最短路径为i,d1,d2,d3,…,dk,j (i,j,dt均为点的标号)，也就是说从i到j的最短路径就是这一条，并且其中任意两点距离也都是最短的（反证法）。</li>
<li>我们现在需要证明，这条路径的权值在外层循环k=max(d1,d2,d3,…,dk),我们记成max(i to j),被填入到矩阵D中。</li>
<li>设P为i与j的最短路径中还需要经过的点的个数
<ul>
<li>当P=0的时候显然成立，因为i与j的最短路径为直接相连的那条边</li>
<li>当P=1的时候也成立，因为当外层循环k等于那个点的时候，就可以得到D[i][k]+D[k][j]并填入到D中</li>
<li>假设P&lt;=m时成立，即对于任意两点路径，若它们之间经过的点小于等于m，则有k=max(d1,d2,…,dP)时，i,j最短路径权值被填入到矩阵D中。</li>
<li>当P=m+1时，找到这经过的m+1个点中标号最大的点dt，也就是说dt=max(d1,d2,…,dm+1),那么dt与j或i之间最多只有m个点，按照前面的假设，我们知道在k=max(i to dt)和k=max(dt to j)的时候，D[i][dt]和D[dt][j]会获得最短的路径权值，又因为dt &gt; max(i to dt) 且 dt &gt; max(dt to j)，所以当k=dt的时候，我们知道D[i][j]=D[i][dt]+D[dt][j]一定是最后的结果了，这时，P=m+1情况成立。</li>
</ul>
</li>
</ul>
<h2 id="next">next...</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最左&最右推导、语法树]]></title>
        <id>https://alittlewhiter.github.io/post/zui-zuo-andzui-you-tui-dao-yu-fa-shu/</id>
        <link href="https://alittlewhiter.github.io/post/zui-zuo-andzui-you-tui-dao-yu-fa-shu/">
        </link>
        <updated>2020-03-26T10:36:42.000Z</updated>
        <summary type="html"><![CDATA[<p>keywords：最左推导、最右推导、语法树、二义性</p>
]]></summary>
        <content type="html"><![CDATA[<p>keywords：最左推导、最右推导、语法树、二义性</p>
<!-- more -->
<h2 id="最左推导和最右推导">最左推导和最右推导</h2>
<ul>
<li>
<p><strong>最左推导</strong>：任何一步α =&gt; β都是对α中的最左一个非终结符进行替换</p>
</li>
<li>
<p><strong>最右推导</strong>：任何一步α =&gt; β都是对α中的最右一个非终结符进行替换</p>
</li>
<li>
<p>例如：<br>
文法G(E)为：</p>
<ul>
<li>
<p>E -&gt; T | E + T |E - T</p>
</li>
<li>
<p>T -&gt; F | T * F | T / F</p>
</li>
<li>
<p>F -&gt; (E) | i</p>
</li>
</ul>
<p>给出i * (i + i)的最左推导和最右推导。</p>
<pre><code class="language-nohighlight">最左推导：
从文法的起始符号开始：
E -&gt; T
-&gt; T * F
-&gt; F * F
-&gt; i * F
-&gt; i * (E)
-&gt; i * (E + T)
-&gt; i * (T +T)
-&gt; i * (F + T)
-&gt; i * (i + T)
-&gt; i * (i + F)
-&gt; i * (i + i)
最右推导：
从文法的开始符号开始：
E -&gt; T
-&gt; T * F
-&gt; T * (E)
-&gt; T * (E + T)
-&gt; T * (E + F)
-&gt; T * (E + i)
-&gt; T * (T + i)
-&gt; T * (F + i)
-&gt; T * (i + i)
-&gt; F * (i + i)
-&gt; i * (i + 1)
</code></pre>
</li>
</ul>
<h2 id="文法的二义性">文法的二义性</h2>
<ul>
<li>给定一个文法G，如果L（G）中存在一个具有两棵或两棵以上分析树的句子， 我们就称该文法为二义性的，G也叫二义性文法。<br>
<strong>造成二义性的原因</strong>：文法中没有体现出结合率和优先级<br>
<img src="https://alittlewhiter.github.io/post-images/1585262146917.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[某科学のPrime]]></title>
        <id>https://alittlewhiter.github.io/post/mou-ke-xue-noprime/</id>
        <link href="https://alittlewhiter.github.io/post/mou-ke-xue-noprime/">
        </link>
        <updated>2020-03-21T11:15:20.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：判断质数、求素数</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：判断质数、求素数</p>
<!-- more -->
<ol>
<li>
<p>判断素数的效率算法：</p>
<pre><code class="language-c++">bool isprime(long x){
    if(x==2 || x==3 || x==5)
        return true;
    if(x%2==0 || x%3==0 || x%5==0 || x&lt;2)
        return false;
    long c = 7, mc = int(sqrt(x));
    while(c &lt;= mc){
        if(x%c == 0)
            return false;
        c += 4;
        if(x%c == 0)
            return false;
        c += 2;
        if(x%c == 0)
            return false;
        c += 4;
        if(x%c == 0)
            return false;
        c += 2;
        if(x%c == 0)
            return false;
        c += 4;
        if(x%c == 0)
            return false;
        c += 6;
        if(x%c == 0)
            return false;
        c += 2;
        if(x%c == 0)
            return false;
        c += 6;
    }
    return true;
}
</code></pre>
</li>
<li>
<p>求取n以内的素数：</p>
<pre><code class="language-java">int countPrimes(int n) {
    if(!n||n==1)  return 0;
    vector&lt;bool&gt; isPrime(n,true);
    for(int i=2;i*i&lt;n;++i) {
        if(!isPrime[i]) continue;
        //填表起点i*i，如3*3，因为3*2已填，步长+i
        for(int j=i*i;j&lt;n;j+=i) {
            isPrime[j]=false;
        }
    }
    int count=0;
    for(int i=2;i&lt;n;++i) {
        if(isPrime[i])  ++count;
    }
    return count;
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DFS & BFS]]></title>
        <id>https://alittlewhiter.github.io/post/dfs-and-bfs/</id>
        <link href="https://alittlewhiter.github.io/post/dfs-and-bfs/">
        </link>
        <updated>2020-03-18T08:36:25.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：dfs，bfs</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：dfs，bfs</p>
<!-- more -->
<h2 id="深度优先搜索dfs">深度优先搜索（DFS）</h2>
<h2 id="广度优先搜索bfs">广度优先搜索（BFS）</h2>
<h2 id="二者的比较">二者的比较 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2>
<ul>
<li>
<p>一般来说，BFS常用于找单一的最短路线，或者是规模小的路径搜索，它的特点是”搜到就是最优解”， 而DFS用于找多个解或者是”步数已知（好比3步就必需达到前提）”的标题，它的空间效率高，然则找到的不必定是最优解，必需记实并完成全数搜索，故一般情况下，深搜需要很是高效的剪枝（优化）.</p>
</li>
<li>
<p>搜索最短路径这些的很显著是用广搜，因为广搜的特征就是一层一层往下搜的，保证当前搜到的都是最优解，当然，最短路径只是一方面的操作，像什么起码状态转换也是可以操作的。</p>
</li>
<li>
<p>深搜就是优先搜索一棵子树，然后是另一棵，它和广搜对比，有着内存需要相对较少的所长，八皇后标题就是典范楷模的操作，这类标题很显著是不能用广搜往解决的。或者像图论里面的找圈的算法，数的前序中序后序遍历等，都是深搜。</p>
<p>深搜的实现近似于栈，广搜则是操作了队列，边进队，边出队。</p>
</li>
<li>
<p><strong>优缺点</strong>：BFS:对于解决最短或最少问题特别有效，而且寻找深度小，但缺点是内存耗费量大（需要开大量的数组单元用来存储状态）。<br>
DFS：对于解决遍历和求所有问题有效，对于问题搜索深度小的时候处理速度迅速，然而在深度很大的情况下效率不高</p>
</li>
<li>
<p>不管是BFS还是DFS，它们虽然好用，但由于时间和空间的局限性，以至于它们只能解决数据量小的问题。</p>
</li>
</ul>
<p><strong>坐标类型搜索</strong> ：这种类型的搜索题目通常来说简单的比较简单，复杂的通常在边界的处理和情况的讨论方面会比较复杂，分析这类问题，我们首先要抓住题目的意思，看具体是怎么建立坐标系（特别重要），然后仔细分析到搜索的每一个阶段是如何通过条件转移到下一个阶段的。确定每一次递归（对于DFS）的回溯和深入条件，对于BFS，要注意每一次入队的条件同时注意判重。要牢牢把握目标状态是一个什么状态，在什么时候结束搜索。还有，DFS过程的参数如何设定，是带参数还是不带参数，带的话各个参数一定要保证能完全的表示一个状态，不会出现一个状态对应多个参数，而这一点对于BFS来说就稍简单些，只需要多设置些变量就可以了。</p>
<p><strong>数值类型搜索</strong>：这种类型的搜索就需要仔细分析分析了，一般来说采用DFS，而且它的终止条件一般都是很明显的，难就难在对于过程的把握，过程的把握类似于坐标类型的搜索（判重、深入、枚举），注意这种类型的搜索通常还要用到剪枝优化，对于那些明显不符合要求的特殊状态我们一定要在之前就去掉它，否则它会像滚雪球一样越滚越大，浪费我们的时间 。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>版权声明：此处文段选自CSDN博主「osDetach」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41681241/article/details/81432634 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Win10定制deskthemepack主题包]]></title>
        <id>https://alittlewhiter.github.io/post/win10-ding-zhi-deskthemepack-zhu-ti-bao/</id>
        <link href="https://alittlewhiter.github.io/post/win10-ding-zhi-deskthemepack-zhu-ti-bao/">
        </link>
        <updated>2020-03-11T01:59:13.000Z</updated>
        <summary type="html"><![CDATA[<p>额、其实真没什么。。😅<br>
500怜さいこう！！ /封面</p>
]]></summary>
        <content type="html"><![CDATA[<p>额、其实真没什么。。😅<br>
500怜さいこう！！ /封面</p>
<!-- more -->
<p>偶然来找找怎么制作Win10的主题包deskthemepack文件（Win7上应该是themepack），一些小记录<sub>就懒得放图了</sub><br>
走起✨✨</p>
<ol>
<li>
<p>进入-&gt;设置 - 个性化 - 主题，依次设置自己的主题的“背景、颜色、声音、鼠标光标”。</p>
</li>
<li>
<p>进入-&gt;背景，选择背景为 <code>幻灯片放映</code> ，点击浏览以选中自己需要的壁纸文件夹作为幻灯片相册。可以更改切换频率（10min）、设置是否无序播放、选择契合度为拉伸</p>
</li>
<li>
<p>进入-&gt;颜色，首先选择颜色为深色/浅色/自定义（这里选深色），打开透明效果，主题色可以选择 自动从背景提取，或自定义一种固定颜色，‘在以下区域显示主题色’按需勾选（建议不用）。</p>
</li>
<li>
<p>进入-&gt;声音，这里一般不用修改，但也可以根据自己需要下载其他合适的音效进行配置。</p>
</li>
<li>
<p>进入-&gt;鼠标光标，这里可以更改鼠标方案，win10 1809版本已有一些内置的选项（我选Windows黑色 系统方案），可以勾选启用阴影效果。</p>
</li>
<li>
<p>最后点击保存主题、并为主题命名，这时Windows其实是保存了我们当前所自定义的一些配置，配置文件（filename.theme）位置位于：<code>C:\Users\你的用户名\AppData\Local\Microsoft\Windows\Themes</code> 。</p>
</li>
<li>
<p>如果想将主题保存为 <code>.deskthemepack</code> 文件并用于分享给其他人，可以在该主题上点击右键，即可弹出“保存用于共享的主题”按钮，点击该按钮即可弹出“另存为”对话窗口，输入文件名，选择路径保存即可。<br>
<img src="https://alittlewhiter.github.io/post-images/1583893408283.png" alt="" loading="lazy"></p>
</li>
</ol>
<p>其实只是个壁纸主题包，各种深度定制还是直接建议网上搜索。。。<sub>定制越深似乎都涉及修改注册表等啥的、打扰了😓</sub><br>
如果喜欢动态壁纸当然还是WE大法好！国内也有很多一些诸如火萤、星空、UPUPOO等<br>
不想太麻烦、也可以找一些轻量化的插件进行美化。如 <a href="http://www.startisback.com/">StartIsBack</a> (备梯付费、建议baipiao)和<a href="https://rocketdock.en.softonic.com/">RocketDock</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C/C++ 捡漏(っ °Д °;)っ]]></title>
        <id>https://alittlewhiter.github.io/post/cc-jian-lou-tu-degd-degtu/</id>
        <link href="https://alittlewhiter.github.io/post/cc-jian-lou-tu-degd-degtu/">
        </link>
        <updated>2020-03-06T07:27:40.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Keywords：C/C++、语法扫雷、使用误区</strong><br>
常常雷区蹦迪的我无(hai)所(pa)畏(ji)惧(le)🤣🤣🤣<br>
~ <sub>记得之前写过类似的、哪去了😑😵😵</sub> ~</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Keywords：C/C++、语法扫雷、使用误区</strong><br>
常常雷区蹦迪的我无(hai)所(pa)畏(ji)惧(le)🤣🤣🤣<br>
~ <sub>记得之前写过类似的、哪去了😑😵😵</sub> ~</p>
<!-- more -->
<h2 id="函数fill与memset的区别">函数fill与memset的区别</h2>
<p><strong>memset函数</strong>：memset(arr, int, sizeof(arr));</p>
<ul>
<li>
<p>按照字节填充数字，由于其机制为对指定内存区域逐字节地复制，而与数组<sub>(指针)</sub>arr指向的数据类型无关。建议仅在需要填充全0 <code>(memset(arr, 0, sizeof arr);)</code> 或全1 <code>（memset(a, -1, sizeof a);）</code> 时使用。</p>
</li>
<li>
<p>包含在在C头文件<code>string.h</code> 或 <code>&lt;cstring&gt;</code> 里面，有时包含 <code>&lt;stdlib.h&gt;</code> 也可。</p>
</li>
</ul>
<p><strong>fill函数</strong>：fill(arr, arr + sizeof(arr), dataType);</p>
<ul>
<li>
<p>按照指针arr实际类型逐个单元进行赋值，将一个区间的元素都赋同一个值（可以是字符、整数、布尔、浮点等类型）。</p>
</li>
<li>
<p>包含在C++头文件 <code>&lt;algorithm&gt;</code>里面，</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>因为memset函数按照字节填充，所以一般memset只能用来填充char型数组（只有char型占一个字节），如果填充int型数组，除了0和-1，其他的会导致填充时期望的值与实际读取的值不相同，而fill函数可以赋值任何类型。</li>
<li><strong>注</strong>：C++使用fill初始化二维数组时应该 <code>fill(dis[0], dis[0]+maxn*maxn, INF);</code> ,因为 dis[0]才是dis的首元素 dis[0][0] 的地址。</li>
</ul>
<h2 id="输入字符和字符串">输入字符和字符串</h2>
<ol>
<li>首先C语言有多个函数可以从键盘获得用户输入，分别是：</li>
</ol>
<ul>
<li>scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据，格式化控制，非常强大！</li>
<li>getchar()、getche()、getch()：这三个函数都用于输入单个字符。</li>
<li>gets()：获取一行数据，并作为字符串处理。</li>
</ul>
<ol start="2">
<li>输入单个字符</li>
</ol>
<ul>
<li>
<p><strong>getchar()</strong></p>
<p>函数getchar()包含在 <code>&lt;stdio.h&gt;</code> 头文件中，它几乎是 <code>scanf(&quot;%c&quot;, c)</code> 的替代品，相比之更加简洁，一次从缓冲区读入一个字符。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
    char c = getchar();
    printf(&quot;c = %c\n&quot;, c);
    return 0;
}
</code></pre>
<pre><code class="language-nohighlight">@↙
c = @
</code></pre>
</li>
<li>
<p><strong>getche()</strong></p>
<p>此函数没有缓冲区，输入一个字符后会立即读取并继续执行，而不用等待用户按下回车键，这是它和 scanf()、getchar() 的最大区别。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
int main() {
    char c = getche();
    printf(&quot;c: %c\n&quot;, c);
    return 0;
}
</code></pre>
<pre><code class="language-c">@c = @
</code></pre>
<p>输入<code>@</code>后，getche() 立即读取完毕，接着继续执行 printf() 将字符输出，所以没有按下回车键程序就运行结束了。</p>
<p><strong>注意</strong>：getche() 位于 <code>conio.h</code> 头文件中，而这个头文件是 Windows 特有的，Linux 和 Mac OS 下没有包含该头文件，因此getche() 并不是标准函数，默认只能在 Windows 下使用，不能在 Linux 和 Mac OS 下使用。</p>
</li>
<li>
<p><strong>getch()</strong></p>
<p>getch() 也没有缓冲区，输入一个字符后会立即读取，不用按下回车键。getch() 的特别之处是它没有回显，看不到输入的字符。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
int main() {
    char c = getch();
    printf(&quot;c: %c\n&quot;, c);
    return 0;
}
</code></pre>
<pre><code class="language-c">c = @
</code></pre>
<p><strong>注</strong>：getch() 也位于 conio.h 头文件中，也不是标准函数。</p>
</li>
</ul>
<ol start="3">
<li>输入字符串</li>
</ol>
<ul>
<li>
<p>输入字符串当然可以使用 scanf() 这个通用的输入函数，对应的格式控制符为<code>%s</code> 。</p>
</li>
<li>
<p>也可以使用gets() 函数，它也是有缓冲区的，每次按下回车键代表当前输入结束了，gets() 开始从缓冲区中读取内容。gets() 和 scanf() 的主要区别是：</p>
<ul>
<li>scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。</li>
<li>gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。</li>
</ul>
<pre><code class="language-c">char url[50];
gets(url);
printf(&quot;url: %s\n&quot;, url);
</code></pre>
<pre><code class="language-c">One apple once a day, keeps your enemies away!↙
One apple once a day, keeps your enemies away!
</code></pre>
</li>
</ul>
<h2 id="fgetc和fputc函数用法">fgetc和fputc函数用法</h2>
<ul>
<li>
<p>C语言中，读写文件比较灵活，既可以每次读写一个字符，也可以读写一个字符串，甚至是任意字节的数据（数据块）。</p>
</li>
<li>
<p>以字符形式读写文件时，每次可以从文件中读取一个字符，或者向文件中写入一个字符。主要使用两个函数，分别是 fgetc() 和 fputc()，仅需包含 <code>stdio.h</code> 。</p>
</li>
</ul>
<h3 id="字符读取函数-fgetc">字符读取函数 fgetc</h3>
<ul>
<li>
<p>fgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符。</p>
</li>
<li>
<p>fgetc() 的用法为：<code>int fgetc (FILE *fp);</code> fp 为文件指针。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回<code>EOF</code>。</p>
</li>
<li>
<p>EOF 是 end of file 的缩写，表示文件末尾，是在 stdio.h 中定义的宏，它的值是一个负数，往往是 -1。fgetc() 的返回值类型之所以为 int，就是为了容纳这个负数（char不能是负数）。</p>
<ul>
<li>EOF 不绝对是 -1，也可以是其他负数，这要看编译器的实现。</li>
</ul>
<pre><code class="language-c">char ch;
FILE *fp = fopen(&quot;F:\\demo.txt&quot;, &quot;r+&quot;);
ch = fgetc(fp);
</code></pre>
</li>
<li>
<p>在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 fgetc() 函数后，该指针会向后移动一个字节，所以可以连续多次使用 fgetc() 读取多个字符。</p>
</li>
<li>
<p>注意：这个文件内部的位置指针与C语言中的指针不是一回事。位置指针仅仅是一个标志，表示文件读写到的位置，也就是读写到第几个字节，它不表示地址。文件每读写一次，位置指针就会移动一次，它不需要你在程序中定义和赋值，而是由系统自动设置，对用户是隐藏的。</p>
<pre><code class="language-c">FILE *fp;
char ch;
if( (fp=fopen(&quot;F:\\demo.txt&quot;,&quot;rt&quot;)) == NULL ){
    puts(&quot;Fail to open file!&quot;);
    exit(0);
}
while( (ch=fgetc(fp)) != EOF ){
    putchar(ch);
}
putchar('\n');
fclose(fp);		// 注意文件需要关闭
</code></pre>
<ul>
<li>
<p>EOF 本来表示文件末尾，意味着读取结束，但是很多函数在读取出错时也返回 EOF，那么当返回 EOF 时，可以借助 stdio.h 中的两个函数来判断是 <code>读取结束</code> 还是 <code>读取错误</code> ，分别是 <code>feof()</code> 和 <code>ferror()</code> 。</p>
</li>
<li>
<p>feof() 函数用来判断文件内部指针是否指向了文件末尾，原型是<code>int feof ( FILE * fp );</code> 当指向文件末尾时返回非零值，否则返回零值。</p>
</li>
<li>
<p>ferror() 函数用来判断文件操作是否出错，原型是 <code>int ferror ( FILE *fp );</code> ，出错时返回非零值，否则返回零值。</p>
</li>
</ul>
</li>
</ul>
<h3 id="字符写入函数-fputc">字符写入函数 fputc</h3>
<ul>
<li>fputc 是 file output char 的所以，意思是向指定的文件中写入一个字符。fputc() 的用法为：<code>int fputc ( int ch, FILE *fp );</code> ch 为要写入的字符，fp 为文件指针。fputc() 写入成功时返回写入的字符，失败时返回 EOF，返回值类型为 int 也是为了容纳这个负数。</li>
<li>被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。</li>
<li>每写入一个字符，文件内部位置指针向后移动一个字节。</li>
</ul>
<h2 id="fgets和fputs函数">fgets和fputs函数</h2>
<p>每次读写一个字符串或者一个数据块，这样能明显提高效率。</p>
<h3 id="读字符串函数-fgets">读字符串函数 fgets</h3>
<ul>
<li>fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中，用法为： <code>char *fgets ( char *str, int n, FILE *fp );</code> str 为字符数组，n 为要读取的字符数目，fp 为文件指针。</li>
<li><strong>返回值</strong>：读取成功时返回字符数组首地址，也即 str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL。</li>
<li><strong>注</strong>1：读取到的字符串会在末尾自动添加 '\0'，n 个字符也包括 '\0'。也就是说，实际只读取到了 n-1 个字符，如果希望读取 100 个字符，n 的值应该为 101。</li>
<li><strong>注2</strong>：在读取到 n-1 个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。不管 n 的值多大，fgets() 最多只能读取一行数据，不能跨行。 <code>C中没有按行读取文件的函数，可以借助 fgets()将 n 的值设置地足够大，每次就可以读取到一行数据。</code></li>
</ul>
<h3 id="写字符串函数-fputs">写字符串函数 fputs</h3>
<ul>
<li>fputs() 函数用来向指定的文件写入一个字符串，用法为： <code>int fputs( char *str, FILE *fp );</code> str 为要写入的字符串，fp 为文件指针。写入成功返回非负数，失败返回 EOF。</li>
</ul>
<h2 id="fscanf-和-fprintf函数">fscanf 和 fprintf函数</h2>
<ul>
<li>
<p>fscanf() 和 fprintf() 函数与前面使用的 scanf() 和 printf() 功能相似，都是格式化读写函数，两者的区别在于 fscanf() 和 fprintf() 的读写对象不是键盘和显示器，而是磁盘文件。</p>
<p>两个函数的原型如下，与 scanf() 和 printf() 相比，仅仅多了一个 fp 参数。</p>
<pre><code class="language-c">int fscanf ( FILE *fp, char * format, ... );
int fprintf ( FILE *fp, char * format, ... );
</code></pre>
</li>
<li>
<p><code>fp 为文件指针，format 为格式控制字符串，... 表示参数列表。</code> 如果将 fp 设置为 stdin，那么 fscanf() 函数将会从键盘读取数据，与 scanf 作用相同；设置为 stdout，那么 fprintf() 函数将会向显示器输出内容，与 printf 作用相同。</p>
</li>
<li>
<p>fprintf() 返回成功写入的字符的个数，失败则返回负数；fscanf() 返回参数列表中被成功赋值的参数个数。</p>
</li>
</ul>
<h2 id="整数与字符串的相互转换">整数与字符串的相互转换</h2>
<ol>
<li>整数转字符串
<ul>
<li>扩展函数 <code>itoa()</code><br>
itoa ( integer to alphanumeric)是把整型数转换成字符串的一个函数。Windows环境下包含在 <code>&lt;stdlib.h&gt;</code> 头文件中，函数原型：<pre><code class="language-c">char* itoa(int value, char*string, int radix);
// value: 要转换的整数，string: 转换后的字符串,radix: 转换进制数，如2,8,10,16 进制等。
</code></pre>
</li>
<li><code>sprintf()</code>函数</li>
</ul>
<ol>
<li>sprintf函数原型为 <code>int sprintf(char *str, const char *format, ...)</code> 。作用是格式化字符串，具体功能：将数字变量转换为字符串、得到整型变量的16进制和8进制字符串、连接多个字符串。</li>
<li>snprintf函数是sprintf函数的更加安全版本，考虑到字符串的字节数，防止了字符串溢出。函数形式为：<code>int snprintf(char *restrict buf, size_t n, const char * restrict format, ...);</code> 。最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n 的话，将不会溢出。</li>
</ol>
</li>
<li>字符串转整数
<ul>
<li>扩展函数 <code>atoi()</code><br>
atoi (表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。Windows环境下包含在 <code>&lt;stdlib.h&gt;</code> 头文件中，函数原型：<pre><code class="language-c">int  atoi(const char *nptr);           // 字符串转整数函数，nptr: 要转换的字符串
</code></pre>
</li>
<li><code>sscanf()</code> 函数<br>
sscanf函数原型为 <code>int sscanf(const char *str, const char *format, ...)</code> 。将参数str的字符串根据参数format字符串来转换并格式化数据，转换后的结果存于对应的参数内。具体功能如下：
<ol>
<li>根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。</li>
<li>取指定长度的字符串</li>
<li>取到指定字符为止的字符串</li>
<li>取仅包含指定字符集的字符串</li>
<li>取到指定字符集为止的字符串</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="stl中的-iterator-和-const_iterator">STL中的 iterator 和 const_iterator</h2>
<ul>
<li>
<p>在C++中使用STL的容器时，经常会用到迭代器，使用迭代器可以很方便的进行容器元素遍历和修改等操作。</p>
</li>
<li>
<p>STL容器中<strong>set</strong>的迭代器是<code>const_iterator</code>类型，而<strong>vector等</strong>的迭代器则是普通的<code>iterator</code>类型。在声明一个集合或者一个哈希表的迭代器时，虽然我们声明的是普通的iterator，但是其实它们都是const_iterator，即一个无法对元素进行修改操作的const引用（set取到的iterator则是const的，而map取到的iterator的key则是const的）。因此，如果使用该迭代器对容器中元素进行修改操作则会编译不通过，对于map的迭代器同理。</p>
</li>
<li>
<p>为什么不允许对元素进行修改？</p>
<ol>
<li>因为set和map这种类型的容器，需要根据key来保持有序或者是确保元素的唯一性，所以不允许用户直接对元素进行修改。如果允许用户在使用iterator时直接对元素进行修改间接的修改了元素的键值，很有可能导致非唯一性或无序。</li>
<li>由于这种类型的容器需要保持元素的有序性，底层可能用了某种数据结构来保存（如：堆），如果频繁的修改元素，则内部可能需要多次进行排序，导致效率低下。</li>
</ol>
</li>
<li>
<p>怎么对元素进行修改？</p>
<ol>
<li>使用容器的erase()和insert()方法。如果想修改某个元素，那么直接删掉它，再将修改过的元素插入到原有的容器中。这种方法的缺点是效率太低。</li>
<li>使用const_cast。const_cast可以去掉任何底层const修饰，使得一个const变量成为非const的。如： <code>int &amp;item1 = const_cast&lt;int&amp;&gt; (*iter);</code></li>
</ol>
</li>
</ul>
<h2 id="next">Next</h2>
]]></content>
    </entry>
</feed>