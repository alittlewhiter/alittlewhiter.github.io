<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alittlewhiter.github.io</id>
    <title>君の知らない物语</title>
    <updated>2020-03-18T09:43:37.203Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alittlewhiter.github.io"/>
    <link rel="self" href="https://alittlewhiter.github.io/atom.xml"/>
    <subtitle>Took the sourest lemon that life has to offer and turned it into something resembling lemonade.</subtitle>
    <logo>https://alittlewhiter.github.io/images/avatar.png</logo>
    <icon>https://alittlewhiter.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 君の知らない物语</rights>
    <entry>
        <title type="html"><![CDATA[DFS & BFS]]></title>
        <id>https://alittlewhiter.github.io/post/dfs-and-bfs/</id>
        <link href="https://alittlewhiter.github.io/post/dfs-and-bfs/">
        </link>
        <updated>2020-03-18T08:36:25.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：dfs，bfs</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：dfs，bfs</p>
<!-- more -->
<h2 id="深度优先搜索dfs">深度优先搜索（DFS）</h2>
<h2 id="广度优先搜索bfs">广度优先搜索（BFS）</h2>
<h2 id="二者的比较">二者的比较 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2>
<ul>
<li>
<p>一般来说，BFS常用于找单一的最短路线，或者是规模小的路径搜索，它的特点是”搜到就是最优解”， 而DFS用于找多个解或者是”步数已知（好比3步就必需达到前提）”的标题，它的空间效率高，然则找到的不必定是最优解，必需记实并完成全数搜索，故一般情况下，深搜需要很是高效的剪枝（优化）.</p>
</li>
<li>
<p>搜索最短路径这些的很显著是用广搜，因为广搜的特征就是一层一层往下搜的，保证当前搜到的都是最优解，当然，最短路径只是一方面的操作，像什么起码状态转换也是可以操作的。</p>
</li>
<li>
<p>深搜就是优先搜索一棵子树，然后是另一棵，它和广搜对比，有着内存需要相对较少的所长，八皇后标题就是典范楷模的操作，这类标题很显著是不能用广搜往解决的。或者像图论里面的找圈的算法，数的前序中序后序遍历等，都是深搜。</p>
<p>深搜的实现近似于栈，广搜则是操作了队列，边进队，边出队。</p>
</li>
<li>
<p><strong>优缺点</strong>：BFS:对于解决最短或最少问题特别有效，而且寻找深度小，但缺点是内存耗费量大（需要开大量的数组单元用来存储状态）。<br>
DFS：对于解决遍历和求所有问题有效，对于问题搜索深度小的时候处理速度迅速，然而在深度很大的情况下效率不高</p>
</li>
<li>
<p>不管是BFS还是DFS，它们虽然好用，但由于时间和空间的局限性，以至于它们只能解决数据量小的问题。</p>
</li>
</ul>
<p><strong>坐标类型搜索</strong> ：这种类型的搜索题目通常来说简单的比较简单，复杂的通常在边界的处理和情况的讨论方面会比较复杂，分析这类问题，我们首先要抓住题目的意思，看具体是怎么建立坐标系（特别重要），然后仔细分析到搜索的每一个阶段是如何通过条件转移到下一个阶段的。确定每一次递归（对于DFS）的回溯和深入条件，对于BFS，要注意每一次入队的条件同时注意判重。要牢牢把握目标状态是一个什么状态，在什么时候结束搜索。还有，DFS过程的参数如何设定，是带参数还是不带参数，带的话各个参数一定要保证能完全的表示一个状态，不会出现一个状态对应多个参数，而这一点对于BFS来说就稍简单些，只需要多设置些变量就可以了。</p>
<p><strong>数值类型搜索</strong>：这种类型的搜索就需要仔细分析分析了，一般来说采用DFS，而且它的终止条件一般都是很明显的，难就难在对于过程的把握，过程的把握类似于坐标类型的搜索（判重、深入、枚举），注意这种类型的搜索通常还要用到剪枝优化，对于那些明显不符合要求的特殊状态我们一定要在之前就去掉它，否则它会像滚雪球一样越滚越大，浪费我们的时间 。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>版权声明：此处文段选自CSDN博主「osDetach」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41681241/article/details/81432634 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Win10定制deskthemepack主题包]]></title>
        <id>https://alittlewhiter.github.io/post/win10-ding-zhi-deskthemepack-zhu-ti-bao/</id>
        <link href="https://alittlewhiter.github.io/post/win10-ding-zhi-deskthemepack-zhu-ti-bao/">
        </link>
        <updated>2020-03-11T01:59:13.000Z</updated>
        <summary type="html"><![CDATA[<p>额、其实真没什么。。😅<br>
500怜さいこう！！ /封面</p>
]]></summary>
        <content type="html"><![CDATA[<p>额、其实真没什么。。😅<br>
500怜さいこう！！ /封面</p>
<!-- more -->
<p>偶然来找找怎么制作Win10的主题包deskthemepack文件（Win7上应该是themepack），一些小记录<sub>就懒得放图了</sub><br>
走起✨✨</p>
<ol>
<li>
<p>进入-&gt;设置 - 个性化 - 主题，依次设置自己的主题的“背景、颜色、声音、鼠标光标”。</p>
</li>
<li>
<p>进入-&gt;背景，选择背景为 <code>幻灯片放映</code> ，点击浏览以选中自己需要的壁纸文件夹作为幻灯片相册。可以更改切换频率（10min）、设置是否无序播放、选择契合度为拉伸</p>
</li>
<li>
<p>进入-&gt;颜色，首先选择颜色为深色/浅色/自定义（这里选深色），打开透明效果，主题色可以选择 自动从背景提取，或自定义一种固定颜色，‘在以下区域显示主题色’按需勾选（建议不用）。</p>
</li>
<li>
<p>进入-&gt;声音，这里一般不用修改，但也可以根据自己需要下载其他合适的音效进行配置。</p>
</li>
<li>
<p>进入-&gt;鼠标光标，这里可以更改鼠标方案，win10 1809版本已有一些内置的选项（我选Windows黑色 系统方案），可以勾选启用阴影效果。</p>
</li>
<li>
<p>最后点击保存主题、并为主题命名，这时Windows其实是保存了我们当前所自定义的一些配置，配置文件（filename.theme）位置位于：<code>C:\Users\你的用户名\AppData\Local\Microsoft\Windows\Themes</code> 。</p>
</li>
<li>
<p>如果想将主题保存为 <code>.deskthemepack</code> 文件并用于分享给其他人，可以在该主题上点击右键，即可弹出“保存用于共享的主题”按钮，点击该按钮即可弹出“另存为”对话窗口，输入文件名，选择路径保存即可。<br>
<img src="https://alittlewhiter.github.io/post-images/1583893408283.png" alt="" loading="lazy"></p>
</li>
</ol>
<p>其实只是个壁纸主题包，各种深度定制还是直接建议网上搜索。。。<sub>定制越深似乎都涉及修改注册表等啥的、打扰了😓</sub><br>
如果喜欢动态壁纸当然还是WE大法好！国内也有很多一些诸如火萤、星空、UPUPOO等<br>
不想太麻烦、也可以找一些轻量化的插件进行美化。如 <a href="http://www.startisback.com/">StartIsBack</a> (备梯付费、建议baipiao)和<a href="https://rocketdock.en.softonic.com/">RocketDock</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C/C++ 捡漏(っ °Д °;)っ]]></title>
        <id>https://alittlewhiter.github.io/post/cc-jian-lou-tu-degd-degtu/</id>
        <link href="https://alittlewhiter.github.io/post/cc-jian-lou-tu-degd-degtu/">
        </link>
        <updated>2020-03-06T07:27:40.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Keywords：C/C++、语法扫雷、使用误区</strong><br>
常常雷区蹦迪的我无(hai)所(pa)畏(ji)惧(le)🤣🤣🤣<br>
~ <sub>记得之前写过类似的、哪去了😑😵😵</sub> ~</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Keywords：C/C++、语法扫雷、使用误区</strong><br>
常常雷区蹦迪的我无(hai)所(pa)畏(ji)惧(le)🤣🤣🤣<br>
~ <sub>记得之前写过类似的、哪去了😑😵😵</sub> ~</p>
<!-- more -->
<h2 id="函数fill与memset的区别">函数fill与memset的区别</h2>
<p><strong>memset函数</strong>：memset(arr, int, sizeof(arr));</p>
<ul>
<li>
<p>按照字节填充数字，由于其机制为对指定内存区域逐字节地复制，而与数组<sub>(指针)</sub>arr指向的数据类型无关。建议仅在需要填充全0 <code>(memset(arr, 0, sizeof arr);)</code> 或全1 <code>（memset(a, -1, sizeof a);）</code> 时使用。</p>
</li>
<li>
<p>包含在在C头文件<code>string.h</code> 或 <code>&lt;cstring&gt;</code> 里面，有时包含 <code>&lt;stdlib.h&gt;</code> 也可。</p>
</li>
</ul>
<p><strong>fill函数</strong>：fill(arr, arr + sizeof(arr), dataType);</p>
<ul>
<li>
<p>按照指针arr实际类型逐个单元进行赋值，将一个区间的元素都赋同一个值（可以是字符、整数、布尔、浮点等类型）。</p>
</li>
<li>
<p>包含在C++头文件 <code>&lt;algorithm&gt;</code>里面，</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>因为memset函数按照字节填充，所以一般memset只能用来填充char型数组（只有char型占一个字节），如果填充int型数组，除了0和-1，其他的会导致填充时期望的值与实际读取的值不相同，而fill函数可以赋值任何类型。</li>
</ul>
<h2 id="输入字符和字符串">输入字符和字符串</h2>
<ol>
<li>首先C语言有多个函数可以从键盘获得用户输入，分别是：</li>
</ol>
<ul>
<li>scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据，格式化控制，非常强大！</li>
<li>getchar()、getche()、getch()：这三个函数都用于输入单个字符。</li>
<li>gets()：获取一行数据，并作为字符串处理。</li>
</ul>
<ol start="2">
<li>输入单个字符</li>
</ol>
<ul>
<li>
<p><strong>getchar()</strong></p>
<p>函数getchar()包含在 <code>&lt;stdio.h&gt;</code> 头文件中，它几乎是 <code>scanf(&quot;%c&quot;, c)</code> 的替代品，相比之更加简洁，一次从缓冲区读入一个字符。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
    char c = getchar();
    printf(&quot;c = %c\n&quot;, c);
    return 0;
}
</code></pre>
<pre><code class="language-nohighlight">@↙
c = @
</code></pre>
</li>
<li>
<p><strong>getche()</strong></p>
<p>此函数没有缓冲区，输入一个字符后会立即读取并继续执行，而不用等待用户按下回车键，这是它和 scanf()、getchar() 的最大区别。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
int main() {
    char c = getche();
    printf(&quot;c: %c\n&quot;, c);
    return 0;
}
</code></pre>
<pre><code class="language-c">@c = @
</code></pre>
<p>输入<code>@</code>后，getche() 立即读取完毕，接着继续执行 printf() 将字符输出，所以没有按下回车键程序就运行结束了。</p>
<p><strong>注意</strong>：getche() 位于 <code>conio.h</code> 头文件中，而这个头文件是 Windows 特有的，Linux 和 Mac OS 下没有包含该头文件，因此getche() 并不是标准函数，默认只能在 Windows 下使用，不能在 Linux 和 Mac OS 下使用。</p>
</li>
<li>
<p><strong>getch()</strong></p>
<p>getch() 也没有缓冲区，输入一个字符后会立即读取，不用按下回车键。getch() 的特别之处是它没有回显，看不到输入的字符。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
int main() {
    char c = getch();
    printf(&quot;c: %c\n&quot;, c);
    return 0;
}
</code></pre>
<pre><code class="language-c">c = @
</code></pre>
<p><strong>注</strong>：getch() 也位于 conio.h 头文件中，也不是标准函数。</p>
</li>
</ul>
<ol start="3">
<li>输入字符串</li>
</ol>
<ul>
<li>
<p>输入字符串当然可以使用 scanf() 这个通用的输入函数，对应的格式控制符为<code>%s</code> 。</p>
</li>
<li>
<p>也可以使用gets() 函数，它也是有缓冲区的，每次按下回车键代表当前输入结束了，gets() 开始从缓冲区中读取内容。gets() 和 scanf() 的主要区别是：</p>
<ul>
<li>scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。</li>
<li>gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。</li>
</ul>
<pre><code class="language-c">char url[50];
gets(url);
printf(&quot;url: %s\n&quot;, url);
</code></pre>
<pre><code class="language-c">One apple once a day, keeps your enemies away!↙
One apple once a day, keeps your enemies away!
</code></pre>
</li>
</ul>
<h2 id="fgetc和fputc函数用法">fgetc和fputc函数用法</h2>
<ul>
<li>
<p>C语言中，读写文件比较灵活，既可以每次读写一个字符，也可以读写一个字符串，甚至是任意字节的数据（数据块）。</p>
</li>
<li>
<p>以字符形式读写文件时，每次可以从文件中读取一个字符，或者向文件中写入一个字符。主要使用两个函数，分别是 fgetc() 和 fputc()，仅需包含 <code>stdio.h</code> 。</p>
</li>
</ul>
<h3 id="字符读取函数-fgetc">字符读取函数 fgetc</h3>
<ul>
<li>
<p>fgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符。</p>
</li>
<li>
<p>fgetc() 的用法为：<code>int fgetc (FILE *fp);</code> fp 为文件指针。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回<code>EOF</code>。</p>
</li>
<li>
<p>EOF 是 end of file 的缩写，表示文件末尾，是在 stdio.h 中定义的宏，它的值是一个负数，往往是 -1。fgetc() 的返回值类型之所以为 int，就是为了容纳这个负数（char不能是负数）。</p>
<ul>
<li>EOF 不绝对是 -1，也可以是其他负数，这要看编译器的实现。</li>
</ul>
<pre><code class="language-c">char ch;
FILE *fp = fopen(&quot;F:\\demo.txt&quot;, &quot;r+&quot;);
ch = fgetc(fp);
</code></pre>
</li>
<li>
<p>在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 fgetc() 函数后，该指针会向后移动一个字节，所以可以连续多次使用 fgetc() 读取多个字符。</p>
</li>
<li>
<p>注意：这个文件内部的位置指针与C语言中的指针不是一回事。位置指针仅仅是一个标志，表示文件读写到的位置，也就是读写到第几个字节，它不表示地址。文件每读写一次，位置指针就会移动一次，它不需要你在程序中定义和赋值，而是由系统自动设置，对用户是隐藏的。</p>
<pre><code class="language-c">FILE *fp;
char ch;
if( (fp=fopen(&quot;F:\\demo.txt&quot;,&quot;rt&quot;)) == NULL ){
    puts(&quot;Fail to open file!&quot;);
    exit(0);
}
while( (ch=fgetc(fp)) != EOF ){
    putchar(ch);
}
putchar('\n');
fclose(fp);		// 注意文件需要关闭
</code></pre>
<ul>
<li>
<p>EOF 本来表示文件末尾，意味着读取结束，但是很多函数在读取出错时也返回 EOF，那么当返回 EOF 时，可以借助 stdio.h 中的两个函数来判断是 <code>读取结束</code> 还是 <code>读取错误</code> ，分别是 <code>feof()</code> 和 <code>ferror()</code> 。</p>
</li>
<li>
<p>feof() 函数用来判断文件内部指针是否指向了文件末尾，原型是<code>int feof ( FILE * fp );</code> 当指向文件末尾时返回非零值，否则返回零值。</p>
</li>
<li>
<p>ferror() 函数用来判断文件操作是否出错，原型是 <code>int ferror ( FILE *fp );</code> ，出错时返回非零值，否则返回零值。</p>
</li>
</ul>
</li>
</ul>
<h3 id="字符写入函数-fputc">字符写入函数 fputc</h3>
<ul>
<li>fputc 是 file output char 的所以，意思是向指定的文件中写入一个字符。fputc() 的用法为：<code>int fputc ( int ch, FILE *fp );</code> ch 为要写入的字符，fp 为文件指针。fputc() 写入成功时返回写入的字符，失败时返回 EOF，返回值类型为 int 也是为了容纳这个负数。</li>
<li>被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。</li>
<li>每写入一个字符，文件内部位置指针向后移动一个字节。</li>
</ul>
<h2 id="fgets和fputs函数">fgets和fputs函数</h2>
<p>每次读写一个字符串或者一个数据块，这样能明显提高效率。</p>
<h3 id="读字符串函数-fgets">读字符串函数 fgets</h3>
<ul>
<li>fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中，用法为： <code>char *fgets ( char *str, int n, FILE *fp );</code> str 为字符数组，n 为要读取的字符数目，fp 为文件指针。</li>
<li><strong>返回值</strong>：读取成功时返回字符数组首地址，也即 str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL。</li>
<li><strong>注</strong>1：读取到的字符串会在末尾自动添加 '\0'，n 个字符也包括 '\0'。也就是说，实际只读取到了 n-1 个字符，如果希望读取 100 个字符，n 的值应该为 101。</li>
<li><strong>注2</strong>：在读取到 n-1 个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。不管 n 的值多大，fgets() 最多只能读取一行数据，不能跨行。 <code>C中没有按行读取文件的函数，可以借助 fgets()将 n 的值设置地足够大，每次就可以读取到一行数据。</code></li>
</ul>
<h3 id="写字符串函数-fputs">写字符串函数 fputs</h3>
<ul>
<li>fputs() 函数用来向指定的文件写入一个字符串，用法为： <code>int fputs( char *str, FILE *fp );</code> str 为要写入的字符串，fp 为文件指针。写入成功返回非负数，失败返回 EOF。</li>
</ul>
<h2 id="fscanf-和-fprintf函数">fscanf 和 fprintf函数</h2>
<ul>
<li>
<p>fscanf() 和 fprintf() 函数与前面使用的 scanf() 和 printf() 功能相似，都是格式化读写函数，两者的区别在于 fscanf() 和 fprintf() 的读写对象不是键盘和显示器，而是磁盘文件。</p>
<p>两个函数的原型如下，与 scanf() 和 printf() 相比，仅仅多了一个 fp 参数。</p>
<pre><code class="language-c">int fscanf ( FILE *fp, char * format, ... );
int fprintf ( FILE *fp, char * format, ... );
</code></pre>
</li>
<li>
<p><code>fp 为文件指针，format 为格式控制字符串，... 表示参数列表。</code> 如果将 fp 设置为 stdin，那么 fscanf() 函数将会从键盘读取数据，与 scanf 作用相同；设置为 stdout，那么 fprintf() 函数将会向显示器输出内容，与 printf 作用相同。</p>
</li>
<li>
<p>fprintf() 返回成功写入的字符的个数，失败则返回负数；fscanf() 返回参数列表中被成功赋值的参数个数。</p>
</li>
</ul>
<h2 id="整数与字符串的相互转换">整数与字符串的相互转换</h2>
<ol>
<li>整数转字符串
<ul>
<li>扩展函数 <code>itoa()</code><br>
itoa ( integer to alphanumeric)是把整型数转换成字符串的一个函数。Windows环境下包含在 <code>&lt;stdlib.h&gt;</code> 头文件中，函数原型：<pre><code class="language-c">char* itoa(int value, char*string, int radix);
// value: 要转换的整数，string: 转换后的字符串,radix: 转换进制数，如2,8,10,16 进制等。
</code></pre>
</li>
<li><code>sprintf()</code>函数</li>
</ul>
<ol>
<li>sprintf函数原型为 <code>int sprintf(char *str, const char *format, ...)</code> 。作用是格式化字符串，具体功能：将数字变量转换为字符串、得到整型变量的16进制和8进制字符串、连接多个字符串。</li>
<li>snprintf函数是sprintf函数的更加安全版本，考虑到字符串的字节数，防止了字符串溢出。函数形式为：<code>int snprintf(char *restrict buf, size_t n, const char * restrict format, ...);</code> 。最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n 的话，将不会溢出。</li>
</ol>
</li>
<li>字符串转整数
<ul>
<li>扩展函数 <code>atoi()</code><br>
atoi (表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。Windows环境下包含在 <code>&lt;stdlib.h&gt;</code> 头文件中，函数原型：<pre><code class="language-c">int  atoi(const char *nptr);           // 字符串转整数函数，nptr: 要转换的字符串
</code></pre>
</li>
<li><code>sscanf()</code> 函数<br>
sscanf函数原型为 <code>int sscanf(const char *str, const char *format, ...)</code> 。将参数str的字符串根据参数format字符串来转换并格式化数据，转换后的结果存于对应的参数内。具体功能如下：
<ol>
<li>根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。</li>
<li>取指定长度的字符串</li>
<li>取到指定字符为止的字符串</li>
<li>取仅包含指定字符集的字符串</li>
<li>取到指定字符集为止的字符串</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="next">Next</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Valine - 你值得拥有┏ (゜ω゜)=☞]]></title>
        <id>https://alittlewhiter.github.io/post/valine-ni-zhi-de-yong-you-o/</id>
        <link href="https://alittlewhiter.github.io/post/valine-ni-zhi-de-yong-you-o/">
        </link>
        <updated>2020-03-04T04:08:08.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Keywords：Gridea、Valine、无后端、评论系统</strong><br>
简直不要再好、、还是希望更好(╹ڡ╹ )</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Keywords：Gridea、Valine、无后端、评论系统</strong><br>
简直不要再好、、还是希望更好(╹ڡ╹ )</p>
<!-- more -->
<h2 id="first">First</h2>
<p>虽然破站也不会有人来看，但还是想为Gridea加上一个评论系统，说——不定呢嘿嘿(￣▽,￣)╭ （想peach</p>
<p>Gridea提供了两个评论系统，Gitalk和disqus。Gitalk需要使用Github账号登录，对于没有github账号的人来说不太方便，disqus目前在国内不太可用。于是<strong>valine</strong> 非你莫属！😜😜</p>
<h2 id="介绍">介绍</h2>
<p>Valine是一款快速、简洁且高效的<strong>无后端</strong>评论系统：</p>
<ul>
<li>高速，使用国内后端云服务提供商 <code>LeanCloud</code> 提供的存储服务</li>
<li>开源、自定义程度高</li>
<li>支持邮件通知、支持验证码 (不建议)</li>
<li>原版即支持表情包、Markdown等特性。<br>
官网地址：<code>https://valine.js.org/</code></li>
</ul>
<h3 id="注册leancloud">注册leancloud</h3>
<p>其次，为了成功配置Valine需要leancloud平台，注册-登录-控制台-创建应用（一条龙.jpg<br>
<img src="https://alittlewhiter.github.io/post-images/1583296181154.png" alt="" loading="lazy"><br>
进入刚刚创建的应用(开发版)，选择左下角的<code>设置</code> &gt; <code>应用Keys</code>，可以获取应用的APP ID和APP Key（注意保密）。进入安全中心，Web安全域名下填写自己的Github Pages（Coding Pages）提供的博客站点域名，点击保存。<br>
<img src="https://alittlewhiter.github.io/post-images/1583296272560.png" alt="" loading="lazy"><br>
点击<code>存储</code>新建一个Class，名称为Comment，添加如下。<br>
<img src="https://alittlewhiter.github.io/post-images/1583296175616.png" alt="" loading="lazy"></p>
<h3 id="修改主题模板">修改主题模板</h3>
<p>在Gridea theme模板templates/_block的head.ejs中引入</p>
<pre><code class="language-html">&lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt;
</code></pre>
<p>在post.ejs (文章详情页) 模板中文章末尾的位置添加下面的代码：</p>
<pre><code class="language-html">&lt;div class=&quot;comments&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        new Valine({
            el: '.comments',
            appId: '&lt;API_ID&gt;',
            appKey: '&lt;API_Key&gt;'
        })
    &lt;/script&gt;
</code></pre>
<blockquote>
<p>相关配置属性含义看<a href="https://valine.js.org/configuration.html">这里</a></p>
</blockquote>
<ul>
<li>接下来仅需修改appId和appKey即可，打开文章详情页，显示评论框就成功了。<br>
<img src="https://alittlewhiter.github.io/post-images/1583301574844.png" alt="" loading="lazy"></li>
</ul>
<h3 id="upgrade-edition">Upgrade Edition：</h3>
<ul>
<li>
<p>主题模板post.ejs文件中需要添加新的<a href="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn/scripts/Valine.min.js">Valine.min.js</a>文件，鉴于我下载该<a href="https://kveln.cn/media/scripts/Valine.min.js">js文件</a>保存到本地/media/scripts后，无论如何设置相对路径都无法同步到GitHub<s>博客</s>，所以只能采用网络上其他站点的资源url：<a href="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn/scripts/Valine.min.js">https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn/scripts/Valine.min.js</a>、<a href="https://kveln.cn/media/scripts/Valine.min.js">https://kveln.cn/media/scripts/Valine.min.js</a></p>
<pre><code class="language-html">  &lt;!--载入js，在&lt;/body&gt;之前插入即可--&gt;
  &lt;!--Leancloud 操作库:--&gt;
  &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;
  &lt;!--Valine 的核心代码库  不知道为啥该.js放本地用不了，第二、第三个目前均可用--&gt;
  &lt;!-- &lt;script src=&quot;/media/scripts/Valine.min.js&quot;&gt;&lt;/script&gt;   --&gt;
  &lt;!-- &lt;script src=&quot;https://kveln.cn/media/scripts/Valine.min.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;script src=&quot;//cdn.jsdelivr.net/gh/Alanrk/clean-cdn/scripts/Valine.min.js&quot;&gt;&lt;/script&gt;
  
  &lt;!-- 评论模块 --&gt;
  	&lt;div class=&quot;comment&quot;&gt; &lt;/div&gt;

  &lt;script&gt;
      new Valine({
        av: AV,                            // AV 对象来自上面引入av-min.js
        el: '.comment',               // 选择标签容器
        lang: 'zh-cn',                  // 设置语言
        avatar: 'mm',                 // 设置头像
        emoticon_url: 'https://cloud.panjunwen.com/alu',
        emoticon_list: [&quot;吐.png&quot;,&quot;喷血.png&quot;,&quot;狂汗.png&quot;,&quot;不说话.png&quot;,&quot;汗.png&quot;,&quot;坐等.png&quot;,
          &quot;献花.png&quot;,&quot;不高兴.png&quot;,&quot;中刀.png&quot;,&quot;害羞.png&quot;,&quot;皱眉.png&quot;,&quot;小眼睛.png&quot;,
          &quot;中指.png&quot;,&quot;尴尬.png&quot;,&quot;瞅你.png&quot;,&quot;想一想.png&quot;,&quot;中枪.png&quot;,&quot;得意.png&quot;,&quot;肿包.png&quot;,
          &quot;扇耳光.png&quot;,&quot;亲亲.png&quot;,&quot;惊喜.png&quot;,&quot;脸红.png&quot;,&quot;无所谓.png&quot;,&quot;便便.png&quot;,&quot;愤怒.png&quot;,
          &quot;蜡烛.png&quot;,&quot;献黄瓜.png&quot;,&quot;内伤.png&quot;,&quot;投降.png&quot;,&quot;观察.png&quot;,&quot;看不见.png&quot;,&quot;击掌.png&quot;,
          &quot;抠鼻.png&quot;,&quot;邪恶.png&quot;,&quot;看热闹.png&quot;,&quot;口水.png&quot;,&quot;抽烟.png&quot;,&quot;锁眉.png&quot;,&quot;装大款.png&quot;,
          &quot;吐舌.png&quot;,&quot;无奈.png&quot;,&quot;长草.png&quot;,&quot;赞一个.png&quot;,&quot;呲牙.png&quot;,&quot;无语.png&quot;,&quot;阴暗.png&quot;,
          &quot;不出所料.png&quot;,&quot;咽气.png&quot;,&quot;期待.png&quot;,&quot;高兴.png&quot;,&quot;吐血倒地.png&quot;,&quot;哭泣.png&quot;,&quot;欢呼.png&quot;,
          &quot;黑线.png&quot;,&quot;喜极而泣.png&quot;,&quot;喷水.png&quot;,&quot;深思.png&quot;,&quot;鼓掌.png&quot;,&quot;暗地观察.png&quot;],
        app_id: 'nD4DEajJJj9QlUpYtF8YFa1v-9Nh9j0Va',
        app_key: 'PpbNRCLEJPuymBxdJfNzU6Bb',
        placeholder: '我有话说...'
    });
  &lt;/script&gt;
</code></pre>
<ul>
<li>需要修改的只有：<code>el</code>、<code>app_id</code> 和 <code>app_key</code>。如果之前有用原版Valine，请将邮件通知和验证码关掉：<code>notify: false</code>, <code>verify: false</code>，避免重复收到扰人通知，还有算术验证码确实反人类，强烈建议停用。将上面的app_id和和app_key替换成leancloud中对应的<code>ID</code>和<code>Key</code>即可，修改完成后点击保存，再把Gridea客户端中的<code>远程</code>-&gt;<code>评论配置</code>-&gt;<code>是否显示评论</code>关掉，同步即可。</li>
</ul>
<pre><code class="language-html">若未引入jQuery，则引入：
&lt;script src=&quot;https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://alittlewhiter.github.io/post-images/1583305338443.png" alt="" loading="lazy"></figure>
<ul>
<li>进阶：可以考虑使用<code>Valine Admin</code>管理评论:
<ul>
<li>Valine Admin主要实现评论邮件通知、评论管理、垃圾评论过滤等功能。支持完全自定义的邮件通知模板。</li>
<li>教程：<a href="https://github.com/DesertsP/Valine-Admin">Valine Admin</a>：<a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>更多详见:</p>
<ul>
<li><a href="https://deserts.io/diy-a-comment-system/">https://deserts.io/diy-a-comment-system/</a></li>
<li><a href="https://valine.js.org/">https://valine.js.org/</a></li>
</ul>
</li>
</ul>
<p>Good Bye 😄!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于CDN这回事儿]]></title>
        <id>https://alittlewhiter.github.io/post/guan-yu-cdn-zhe-hui-shi-er/</id>
        <link href="https://alittlewhiter.github.io/post/guan-yu-cdn-zhe-hui-shi-er/">
        </link>
        <updated>2020-03-03T08:54:37.000Z</updated>
        <summary type="html"><![CDATA[<p>也就那回事儿~</p>
]]></summary>
        <content type="html"><![CDATA[<p>也就那回事儿~</p>
<!-- more -->
<h3 id="介绍">介绍</h3>
<p>CDN，Content Distribute Network，可以直译成内容分发网络，CDN解决的是如何将数据快速可靠从源站传递到用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。</p>
<h3 id="为什么不进行数据的直接交付即让用户直接从源站获取数据呢">为什么不进行数据的直接交付，即让用户直接从源站获取数据呢？<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h3>
<pre><code>我们常说的互联网实际上由两层组成，一层是以TCP/IP为核心的网络层即Internet (因特网)，另一层  
则是以万维网WWW为代表的应用层。数据从服务器端交付到用户端，至少有4个地方可能会造成网络拥堵。  
</code></pre>
<ol>
<li>“第一公里”，这是指万维网流量向用户传送的第一个出口，是网站服务器接入互联网的链路。这个出口带宽决定了一个网站能为用户提供的访问速度和并发访问量。当用户请求量超出网站的出口带宽，就会在出口处造成拥塞。</li>
<li>“最后一公里”，万维网流量向用户传送的最后一段链路，即用户接入互联网的链路。用户接入的带宽影响用户接收流量的能力。随着电信运营商的大力发展，用户的接入带宽得到了很大改善，“最后一公里”问题基本得到解决。</li>
<li>ISP互联，即因特网服务提供商之间的互联，比如中国电信和中国联通两个网络运营商之间的互联互通。当某个网站服务器部署在运营商A的机房，运营商B的用户要访问该网站，那就必须经过A、B之间的互联互通点进行跨网访问。从互联网的架构来看，不同运营商之间的互联互通带宽，对任何一个运营商网络流量来说，占比都非常小。因此，这里也通常是网络传输的拥堵点。</li>
<li>长途骨干传输。首先是长距离传输时延问题，其次是骨干网络的拥塞问题，这些问题都会造成万维网流量传输的拥堵。</li>
</ol>
<h3 id="结论">结论：</h3>
<ul>
<li>从以上对于网络拥堵的情况分析，如果网络上的数据都使用从源站直接交付到用户的方法，那么将极有可能会出现访问拥塞的情况。</li>
<li>如果能有一种技术方案，将数据缓存在离用户最近的地方，使用户以最快的速度获取，那这对于减少网站的出口带宽压力，减少网络传输的拥堵情况，将起到很大的作用。CDN正是这样一种技术方案。</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>转载如下：<br>
————————————————<br>
版权声明：本文为CSDN博主「haozlee」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/lihao21/article/details/52808747 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[来了来了、Markdown入坟系列]]></title>
        <id>https://alittlewhiter.github.io/post/lai-liao-lai-liao-markdown-ru-fen-xi-lie/</id>
        <link href="https://alittlewhiter.github.io/post/lai-liao-lai-liao-markdown-ru-fen-xi-lie/">
        </link>
        <updated>2020-03-03T04:09:36.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Keywords：markdown，md语法，笔记</strong><br>
<mark>Typora大法好！</mark><br>
<mark>Typora大法好！!</mark><br>
<mark>Typora大法好！！！</mark></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Keywords：markdown，md语法，笔记</strong><br>
<mark>Typora大法好！</mark><br>
<mark>Typora大法好！!</mark><br>
<mark>Typora大法好！！！</mark></p>
<!-- more -->
<h2 id="markdown基本撰写和格式语法">Markdown基本撰写和格式语法</h2>
<h3 id="标题">标题</h3>
<ul>
<li>要创建标题，请在标题文本前添加一至六个 <code>#</code> 符号，使用的 <code>#</code> 数量（1 - 6）将决定标题的大小。</li>
</ul>
<pre><code class="language-git">#    一级标题
##   二级标题
###  三级标题
#### 四级标题
#### 五级标题
######   六级标题
</code></pre>
<p><strong>补充</strong></p>
<ul>
<li>对标题进行封闭处理(类似于html中的自闭合标签加个/标注),那么你可以对应的在标题后面加上 相应数量的&quot;#&quot;。</li>
<li>一级标题和二级标题还支持另外的使用方式，就是在一级标题下面加<code>=</code>，二级标题下面加<code>-</code>（最少加一个）：</li>
</ul>
<pre><code class="language-html">  一级标题
  ===
  二级标题
  ---
</code></pre>
<p><strong>分隔线</strong><br>
连续的三个以上的*或-或_, 你也可以在连字符或星号之间使用空格。</p>
<pre><code class="language-HTML">---
***
___
- - -
</code></pre>
<h3 id="样式文本">样式文本</h3>
<ul>
<li>可以使用粗体、斜体或删除线文本来表示强调，粗体和斜体能够互相嵌套</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">样式</th>
<th style="text-align:left">语法</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">粗体</td>
<td style="text-align:left"><code>** **</code> 或 <code>__ __</code> 包围（无需多余空格）</td>
<td style="text-align:left"><strong>粗体字</strong></td>
</tr>
<tr>
<td style="text-align:left">斜体</td>
<td style="text-align:left"><code>* *</code> 或 <code>_ _</code> 包围</td>
<td style="text-align:left"><em>斜体字</em></td>
</tr>
<tr>
<td style="text-align:left">上标</td>
<td style="text-align:left"><code>^ ^</code> 包围</td>
<td style="text-align:left">5a<sup>3</sup>b<sup>2</sup>c</td>
</tr>
<tr>
<td style="text-align:left">下标</td>
<td style="text-align:left"><code>~ ~</code> 包围</td>
<td style="text-align:left">C<sub>60</sub> 是足球烯</td>
</tr>
<tr>
<td style="text-align:left">删除线</td>
<td style="text-align:left"><code>~~ ~~</code> 包围</td>
<td style="text-align:left"><s>删除线</s></td>
</tr>
<tr>
<td style="text-align:left">粗体+斜体</td>
<td style="text-align:left"><code>*** ***</code> 包围</td>
<td style="text-align:left"><em><strong>粗体又斜体</strong></em></td>
</tr>
<tr>
<td style="text-align:left">强调</td>
<td style="text-align:left"><code>== ==</code> 包围</td>
<td style="text-align:left"><mark>重要的事情说三遍</mark></td>
</tr>
</tbody>
</table>
<h3 id="引用文本">引用文本</h3>
<p>可以使用 <code>&gt;</code> 来引用一段文本，引用可以多层嵌套</p>
<blockquote>
<p>鲁迅：“这是一段引用文本”（我没说.jpg）</p>
<blockquote>
<p>禁止套娃！</p>
<blockquote>
<p>禁止禁止套娃！！</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<h3 id="代码">代码</h3>
<ul>
<li>
<p>使用单反引号<code>` `</code>或双反引号<code>`` ``</code>可标注句子中的代码或命令，反引号中的文本不会被Markdown解释器格式化，一般在文本段落中还能起<code>突出强调</code>的作用。</p>
</li>
<li>
<p>要将代码或文本格式化为各自的不同块，按照不同类型的代码风格进行高亮显示，使用三反引号<code>```[C/Java/html/..] ```</code> 独立分行。</p>
<pre><code class="language-git">一些基本的git命令：
git status
git add ./
git commit
</code></pre>
<p><code>code支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir</code></p>
</li>
<li>
<p>如果不需要代码高亮，可以用下面的方法禁用：</p>
<p><code>```nohighlight</code><br>
<code>```</code></p>
</li>
</ul>
<h3 id="链接">链接</h3>
<ul>
<li>
<p>通过将链接文本包含在方括号 <code>[ ]</code> 内，然后将 URL 包含在括号 <code>( )</code> 内，可创建内联链接。 还可以使用键盘快捷键 <code>命令键 + k</code> 来创建链接。</p>
<pre><code class="language-html">本站点是使用 [GitHub Pages](https://pages.github.com/) 构建的。
</code></pre>
<p>本站点是使用 <a href="https://pages.github.com/">GitHub Pages</a> 构建的。</p>
</li>
</ul>
<h3 id="脚注">脚注</h3>
<ul>
<li>向文章添加脚注，以上标的形式展示，脚注内容会显示在文章结尾处。<pre><code class="language-nohighlight">大佬写文章总是喜欢做这样[^fn1]或那样[^fn2]的脚注。
</code></pre>
</li>
<li>大佬写文章总是喜欢做这样<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>或那样<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>的脚注。</li>
</ul>
<h3 id="列表">列表</h3>
<ul>
<li>
<p>无序列表：通过在一行或多行文本前面添加 <code>+</code>、 <code>-</code> 或 <code>*</code> 后跟一个空格，可创建无序列表。</p>
<pre><code>+ George Washington
+ John Adams
+ Thomas Jefferson
</code></pre>
</li>
<li>
<p>有序列表：在列表前面加上数字/字母 作为编号，每个编号使用一个点+空格</p>
<pre><code>1. James Madison
2. James Monroe
3. John Quincy Adams
</code></pre>
</li>
</ul>
<ul>
<li>
<p>列表（有序 or 无序）还能嵌套：通过在一个列表项下面缩进一个或多个其他列表项，可创建嵌套列表。</p>
<p>要通过编辑器或使用等宽字体创建嵌套列表，可以直观地对齐列表。 在嵌套列表项的前面键入空格字符，直至列表标记字符（<code>-</code> 或 <code>*</code>）位于其上方条目中第一个文本字符的正下方。</p>
<pre><code>1. First list item
   - First nested list item
     + Second nested list item
</code></pre>
<ol>
<li>First list item
<ul>
<li>First nested list item
<ul>
<li>Second nested list item</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="任务列表">任务列表</h3>
<ul>
<li>
<p>创建任务列表，在列表项目前面、列表标号[-+*]后面加一个常规 <code>空格</code> 字符，后接 <code>[ ]</code> 。若要将任务标记为已完成，使用 <code>[x]</code> 即可。演示如下：</p>
<pre><code class="language-html">- [x] 完成更改
- [ ] 推送提交到 GitHub
- [ ] (Optional) 打开拉取请求
</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-3284351"><label class="task-list-item-label" for="task-item-3284351"> 完成更改</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-322540"><label class="task-list-item-label" for="task-item-322540"> 推送提交到 GitHub</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-519894"><label class="task-list-item-label" for="task-item-519894"> (Optional) 打开拉取请求</label></li>
</ul>
<p><strong>注</strong>：如果任务列表项描述以括号开头，则需要加空格分隔或使用\对其进行转义。</p>
</li>
</ul>
<h3 id="使用表情符号">使用表情符号</h3>
<ul>
<li>
<p>通过键入 <code>:EMOJICODE:</code> 可在您的写作中添加表情符号。</p>
<pre><code class="language-html">@octocat :+1: 这个 PR 看起来很棒 - 可以合并了！ :ship:
</code></pre>
<p>@octocat 👍 这个 PR 看起来很棒 - 可以合并了！ 🚢</p>
</li>
</ul>
<ul>
<li>键入 <code>:</code> 将显示建议的表情符号列表，该列表将在键入时进行过滤，因此一旦找到所需的表情符号，可按Tab或Enter键以完成突出显示的结果。</li>
</ul>
<h3 id="段落">段落</h3>
<ul>
<li>通过在文本行之间留一个空白行，可创建新段落。</li>
</ul>
<h3 id="公式">公式</h3>
<ul>
<li>
<p>使用Latex语法将公式写在 <code>$$ $$</code> 内部，将会自动生成相应的公式。e.g.</p>
<pre><code>$$
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
$$
</code></pre>
</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">V</mi><mn>1</mn></msub><mo>×</mo><msub><mi mathvariant="bold">V</mi><mn>2</mn></msub><mo>=</mo><mrow><mo fence="true">∣</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="bold">i</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="bold">j</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="bold">k</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>X</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>u</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>Y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>u</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>X</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>v</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>Y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>v</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">V</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">V</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6802159999999997em;vertical-align:-1.590108em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.08597em;"><span style="top:-1.05597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.6619700000000002em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26797em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87397em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-4.08597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500299999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.090108em;"><span style="top:-4.250108em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">i</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight">u</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.769892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.590108em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.090108em;"><span style="top:-4.250108em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">j</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight">u</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.769892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.590108em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.090108em;"><span style="top:-4.250108em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">k</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.769892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.590108em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.08597em;"><span style="top:-1.05597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.6619700000000002em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26797em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87397em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-4.08597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500299999999998em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="忽略markdown格式">忽略Markdown格式</h3>
<ul>
<li>
<p>通过在Markdown字符前使用 <code>\</code> 来忽略（或转义）Markdown格式。e.g.</p>
<pre><code class="language-html">让我们将 \*our-new-project\* 重命名为 \*our-old-project\*。
</code></pre>
<p>将 *our-new-project*  重命名为 *our-old-project* 。</p>
</li>
</ul>
<p>Next...</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>我也不懂。。。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>怕了怕了！！！ <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[X86寄存器详解（正经.jpg]]></title>
        <id>https://alittlewhiter.github.io/post/x86-ji-cun-qi-xiang-jie/</id>
        <link href="https://alittlewhiter.github.io/post/x86-ji-cun-qi-xiang-jie/">
        </link>
        <updated>2020-03-03T01:29:03.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：x86寄存器、<br>
精心整理，有空看看</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：x86寄存器、<br>
精心整理，有空看看</p>
<!-- more -->
<h2 id="概述">概述</h2>
<p>x86或80x86是英特尔Intel首先开发制造的一种微处理器体系结构的泛称。该系列较早期的处理器名称是以数字来表示，并以“86”作为结尾，包括最开始16位的Intel 8086、80186、80286、到后来推出32位80386微处理器以及如今64位的80486，因此其架构被称为“x86”。 寄存器是CPU的组成部分，是有限存贮容量的高速存贮部件，是 CPU 中非常珍贵的稀有资源，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，有指令寄存器(IR)和程序计数器(PC)，而在算术及逻辑部件中，寄存器有累加器(ACC)。<br>
早期的8086CPU中，只包含14个结构为16位的寄存器（即一个寄存器可以存放下2个字节的数据）：AX，BX，CX，DX，SP，BP，DI，SI，IP，FLAG，CS，DS，ES，SS。而到了 80386 CPU中，寄存器的个数增多了，同时寄存器的结构也变了，如绝大多数的寄存器扩展为32位，而有些寄存器则仍是16位 ，并在后续发展中不断更新改进。</p>
<h2 id="32位cpu系统级寄存器和数据结构">32位cpu系统级寄存器和数据结构</h2>
<figure data-type="image" tabindex="1"><img src="https://alittlewhiter.github.io/post-images/1583199240318.png" alt="" loading="lazy"></figure>
<h2 id="寄存器分类介绍32位模式">寄存器分类介绍（32位模式）</h2>
<blockquote>
<p>通用寄存器：8个，分别为EAX，EBX，ECX，EDX，ESP，EBP，ESI，EDI<br>
标志寄存器：1个，EFLAGS<br>
控制寄存器：5个，分别为CR0-CR4<br>
调试寄存器：8个，分别为DR0-DR7<br>
系统地址寄存器：4个，GDTR，IDTR，LDTR和TR<br>
段寄存器：6个，分别为CS，DS，SS，ES，FS，GS<br>
其他特殊目的寄存器：EIP，TSC等</p>
</blockquote>
<h3 id="通用寄存器general-purpose-registers">通用寄存器（General-Purpose Registers）：</h3>
<ul>
<li>
<p>尽管这8个通用寄存器大多时候是通用的，可以作任何用途，但是在某些情况下也有各自约定俗成的隐含用法。比如在串循环操作中ECX用作计数器，而EDI用于寻址目标数据串，ESI用于寻址源数据串。EBP和ESP主要用来维护栈，ESP通常指向栈的顶部，EBP指向当前栈帧的起始地址。<br>
<img src="https://alittlewhiter.github.io/post-images/1583200258718.png" alt="" loading="lazy"></p>
<ul>
<li>EAX, EBX, ECX, EDX称数据寄存器，它们都可以作为32位寄存器（如EAX）、16位寄存器（AX）或者分为两个独立的8位寄存器（AH、AL）使用。如果作为8位或者16位寄存器被寻址，则仅会改变32位寄存器的某一部分而不影响其他部分。</li>
<li>ESI、EDI、SI和DI称为变址寄存器，主要用于存放存储单元在段内的偏移量，用它们可实现多种不同形式的存储器操作数的寻址方式。EBP、ESP、BP和SP称为指针寄存器，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种寻址方式，为以不同的地址形式访问堆栈存储单元提供方便。变址寄存器和指针寄存器不可分割成8位寄存器，但也可存储算术逻辑运算的操作数和运算结果。<br>
<img src="https://alittlewhiter.github.io/post-images/1583200289859.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p>EAX(Accumulator)：累加寄存器 可作为累加器用于乘法、除法及一些调整指令，也可以保存被访问存储器单元的偏移地址。</p>
</li>
<li>
<p>EBX (Base)：基址寄存器 可以被作为EBX、BX，BH和BL被寻址，包括16位微处理器，BX可以保存内存系统位置的偏移地址，32位的EBX也可以用来寻址内存数据。</p>
</li>
<li>
<p>ECX (Count)：计数器寄存器 ECX是一个通用目的计数器，它持有多种指令的计数，自80386以上ECX寄存器也可以保存访问数据所在存储器单元的偏移地址。用于计数的指令包括重复字符串指令（REP/REPE/REPNE）、shift、rotate 和 LOOP/LOOPD 指令。重复字符串指令使用CX， Shift 和 rotate 移位指令使用CL作为计数器。，而LOOP/LOOPD循环指令使用CX或者ECX指令。</p>
</li>
<li>
<p>EDX (Data)：数据寄存器 通用目的数据寄存器，它常与EAX配合保存乘法运算结果的一部分或者除法运算之前的被除数，80386以后也可被用作寻址内存数据。</p>
</li>
<li>
<p>EDI（Destination Index）目标索引寄存器 通常寻址一些字符串指令的字符串目标数据。它也可以起到32或者16位通用寄存器的作用。</p>
</li>
<li>
<p>ESI（Source Index）源索引寄存器 通常寻址字符串指令的源字符串数据。</p>
</li>
<li>
<p>EBP (Base Pointer) 基指针寄存器 用作EBP或BP寻址，可直接存取堆栈中数据</p>
</li>
<li>
<p>ESP (Stack Pointer) 堆栈指针寄存器 可访问内存中堆栈段的栈顶</p>
</li>
</ul>
<h3 id="标志寄存器eflags">标志寄存器（EFLAGS）：</h3>
<ul>
<li>控制任务状态和模式切换、中断处理、指令追踪和访问权限控制，寄存器中的标志位需要特权指令代码才可以修改(特权指令：运行在内核态下的代码)，16位模式下使用PUSHF和POPF将FLAG压栈和推出，32位则用PUSHFD/POPFD。80x86和Pentium全系列微处理器的EFLAGS和FLAG寄存器如下：<br>
<img src="https://alittlewhiter.github.io/post-images/1583200854075.png" alt="" loading="lazy"></li>
</ul>
<h4 id="eflags寄存器的状态标志0-2-4-6-7以及11位指示算术指令如add-sub-mul以及div指令的结果这些状态标志的作用如下">EFLAGS寄存器的状态标志(0、2、4、6、7以及11位)指示算术指令（如ADD, SUB, MUL以及DIV指令）的结果，这些状态标志的作用如下：</h4>
<ul>
<li>CF(bit 0) [Carry flag]   若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。</li>
<li>PF(bit 2) [Parity flag]   如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。</li>
<li>AF(bit 4) [Adjust flag]   如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。这个标志在BCD(binary-code decimal)算术运算中被使用。</li>
<li>ZF(bit 6) [Zero flag]   若结果为0则将其置1，反之清零。</li>
<li>SF(bit 7) [Sign flag]   该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)</li>
<li>DF(bit 10)[Direction flag] 控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及- CLD指令分别用于设置以及清除DF标志。</li>
<li>OF(bit 11) [Overflow flag]   如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。</li>
</ul>
<h4 id="系统标志以及iopl域system-flags-and-iopl-field">系统标志以及IOPL域(System Flags and IOPL Field)，</h4>
<p>EFLAGS寄存器中的这部分标志用于控制操作系统或是执行操作，它们不允许被应用程序所修改。这些标志的作用如下：</p>
<ul>
<li>TF(bit 8) [Trap flag]   将该位设置为1以允许单步调试模式，清零则禁用该模式。</li>
<li>IF(bit 9) [Interrupt enable flag]   该标志用于控制处理器对可屏蔽中断请求(maskable interrupt requests)的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。</li>
<li>IOPL(bits 12 and 13) [I/O privilege level field]   指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。</li>
<li>NT(bit 14) [Nested task flag]   这个标志控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。</li>
<li>RF(bit 16) [Resume flag]   控制处理器对调试异常的响应。</li>
<li>VM(bit 17) [Virtual-8086 mode flag]   置1以允许虚拟8086模式，清除则返回保护模式。</li>
<li>AC(bit 18) [Alignment check flag]   该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。</li>
<li>VIF(bit 19) [Virtual interrupt flag]   该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)</li>
<li>VIP(bit 20) [Virtual interrupt pending flag]   该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。【Software sets and clears this flag; the processor only reads it.】与VIF标志结合使用。</li>
<li>ID(bit 21) [Identification flag]   程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。</li>
</ul>
<h3 id="控制寄存器control-register">控制寄存器（Control Register）：</h3>
<p>（CR0 - CR4）保存全局性、和任务无关的机器状态，用于控制和确定 处理器的操作模式以及当前执行任务的一些特性，其逻辑结构具体如下图：<br>
<img src="https://alittlewhiter.github.io/post-images/1583200418040.png" alt="" loading="lazy"></p>
<h4 id="cr0-包含了-6-个预定义标志控制系统的工作模式和处理器的状态其各特殊位的含义功能如下">CR0: 包含了 6 个预定义标志，控制系统的工作模式和处理器的状态，其各特殊位的含义功能如下：</h4>
<ul>
<li>PG（bit 31）：分页有效时,置位为1,清空时为0（与PE一同使用），该指令表明是否使用页表将线性地址转换成物理地址</li>
<li>CD（bit 30）：cache 缺失设置位</li>
<li>NW（bit 29）：直写无效(直写:高速缓存中的数据始终保持与主存储器中数据匹配)</li>
<li>AM（bit 18）：对齐功能屏蔽(与EFLAGS寄存器中 AC标志位一同使用)</li>
<li>WP（bit 16）：写保护</li>
<li>NE（bit 5）：数字错误标志位(与浮点协处理器共同使用)</li>
<li>ET（bit 4）：扩展类型.设置有效位时,支持 ntel 387 DX 数学协处理器指令.</li>
<li>TS（bit 3）：每当任务切换时就设置该位,并且在解释协处理器指令之前测试该位</li>
<li>EM（bit 2）：该位表明是否需要仿真协处理器的功能</li>
<li>MP（bit 1）：协处理器监视标志位</li>
<li>PE（bit 0）：保护模式使能，当设置有效位（1），CPU工作在保护模式；反之（0），则在实模式下运行。</li>
</ul>
<h4 id="cr1-未定义的控制寄存器保留">CR1: 未定义的控制寄存器，保留。</h4>
<h4 id="cr2-页故障线性地址寄存器保留最后一次出现页故障的全32位线性地址">CR2: 页故障线性地址寄存器，保留最后一次出现页故障的全32位线性地址</h4>
<h4 id="cr3-页目录基址寄存器保存页目录表的物理内存基地址和pcd和pwt标志位和cache有关">CR3: 页目录基址寄存器，保存页目录表的物理内存基地址和PCD和PWT标志位(和Cache有关)</h4>
<ul>
<li>PCD: 控制当前页目录表的缓冲，当设置清空时，缓冲置位时，缓冲无效.与CR0中的CD或PG一同使用</li>
<li>PWT: 控制cache采取直写还是回写的策略.当设置清空时,回写有效.当置位时，直写有效。</li>
</ul>
<h4 id="cr4-一些结构的扩展表明对于特定的处理器和操作系统执行支持">CR4: 一些结构的扩展.表明对于特定的处理器和操作系统执行支持.</h4>
<ul>
<li>VME: 虚地址模式，当清空时无效.</li>
<li>PVI: 保护模式虚中断，当清空时无效</li>
<li>TSD: 时间戳允许标志位，当清空时，允许RDTSC指令执行在任务特权级上；当置位时，只允许工作在特权级0.</li>
<li>DE: 调试扩展，置位表明DR4与DR5将产生没有定义的异常</li>
<li>PSE: 当置位时使用4M的页面；清空，使用4K的页面</li>
<li>PAE: 置位表示使用36物理内存的分页机制，清空时使用32位分页机制</li>
<li>MCE: 置位表示使用机器检查异常机制</li>
<li>PGE: 置位表示启动全局页面，当写CR3时，也不会被替换.</li>
<li>PCE: 置位表明使RDPMC指令工作在任何保护级别.</li>
<li>OSFXSR: 置位表明操作系统支持FXSAVE and FXRSTOR指令</li>
<li>OSXMMEXCPT: 置位表明操作系统支持不可屏蔽的SIMD浮点异常.</li>
</ul>
<h3 id="调试寄存器debug-register">调试寄存器（Debug Register）：</h3>
<p>（DR0 - DR7）使系统程序设计人员设置和监视1到4个断点（编号0-3），用它们可以规定指令执行和数据读写的任何组合。应用于调试应用代码、系统代码、开发多任务操作系统，来监视代码的运行和处理器的性能。对于每个断点，可以指定以下信息：</p>
<ul>
<li>断点发生的线性地址</li>
<li>断点位置的长度：1、2、4或8个字节</li>
<li>必须在地址处执行的操作才能生成调试异常</li>
<li>是否启用断点</li>
<li>生成调试异常时是否存在断点条件<br>
<img src="https://alittlewhiter.github.io/post-images/1583200462908.png" alt="" loading="lazy"></li>
</ul>
<h4 id="调试地址寄存器debug-address-registersdr0-dr3">调试地址寄存器（Debug Address Registers）DR0-DR3：</h4>
<p>保留4个32位断点的线性地址</p>
<h4 id="调试寄存器debug-registersdr4dr5">调试寄存器（Debug Registers）DR4，DR5：</h4>
<p>启用调试扩展时（控制寄存器CR4中的DE标志已置位时）保留调试寄存器DR4和DR5（）并尝试引用DR4和DR5寄存器会导致无效操作码异常</p>
<h4 id="调试状态寄存器debug-status-registerdr6">调试状态寄存器（Debug Status Register）DR6：</h4>
<p>报告在上次调试异常时采样的调试条件生成，且仅在生成异常时才会更新此寄存器。该寄存器中的标志显示以下信息：<br>
- B0—B3: 断点状态的监测<br>
- BD: 调试寄存器访问监测.置位,表明在指令流中,下一条指令将访问其中的一个调试寄存器<br>
- BS: 单步执行标志位<br>
- BT: 任务转换标志位</p>
<h4 id="调试控制寄存器debug-control-registerdr7">调试控制寄存器（Debug Control Register）DR7：</h4>
<p>该寄存器中的标志信息如下：<br>
- L0—L3: 局部断点使能标志位<br>
- G0--G3: 全局断点使能标志位<br>
- LE AND GE: 置位表明处理器可以监测导致数据断点的指令，一般置位<br>
- GD: 通用监测使能标志位.表明是否开启调试寄存器保护.<br>
- LEN0 through LEN3 : 用来表明相应断点地址寄存器内存位置的大小.<br>
- R/W0 through R/W3: 相应断点的状态</p>
<h3 id="系统地址寄存器memory-management-registers">系统地址寄存器（Memory Management Registers）：</h3>
<ul>
<li>80386中含有4个系统地址寄存器，包括全局描述符表寄存器GDTR(Global Descriptor Table Register)、中断描述符表寄存器 IDTR(Interrupt Descriptor Table Register)、局部描述表 寄存器LDTR(Local Descriptor Table Register)和任务寄存器TR(Task Register)。</li>
<li>主要用来在保护模式下，管理用于生成线性地址和物理地址的4个系统管理描述符表，GDTR、IDTR和LDTR用于寻址存放描述符表的段。TR用于寻址一个特殊的任务状态段(Task State Segment，TSS)。TSS中包含着当前执行任务的重要信息。<br>
<img src="https://alittlewhiter.github.io/post-images/1583200761420.png" alt="" loading="lazy"></li>
</ul>
<p>具体情况如下：<br>
- 全局描述符表寄存器GDTR：是一个48位寄存器，用来存放全局描述符表GDT的32位线性基地址和16位的界限值。在全局描述符表中不仅包括有操作系统使用的描述符，而且还有所有任务使用的公用描述符。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF，在保护模式初始化过程中必须给GDTR加载一个新值。<br>
- 中断描述符表寄存器IDTR：是一个48位寄存器，用来存放中断描述符表IDT的32位线性基地址和16位的界限值。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成 0xFFFF。<br>
局部描述符表寄存器LDTR：是一个16位寄存器，用来存放局部描述符表 LDT 的 32 位线性基地址、16 位段限长和描述符属性值。另外还有一个隐含的描述符高速缓冲寄存器，用来存放LDT表描述符。在机器加电或处理器复位后，段选择符和基地址被默认地设置为 0，而段长度被设置成 0xFFFF。<br>
- 任务状态寄存器TR：是一个16位寄存器，用来存放当前任务状态段TSS的16位段选择符、32位基地址、16位段长度和描述符属性值。与之相应，也有一个隐含的描述符高速缓冲寄存器，用来存放任务状态段TSS的描述符。当执行任务切换时，处理器会把新任务的 TSS 的段选择符和段描述符自动加载进任务寄存器TR中。</p>
<h3 id="段寄存器">段寄存器：</h3>
<ul>
<li>段寄存器是根据内存分段的管理模式而设置的，用于保存16位段选择器（一种特殊指针，用于标识内存中的段）。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。DS，ES，FS和GS寄存器指向四个数据段，四个数据段的可用性允许有效和安全地访问不同类型的数据结构。
<ul>
<li>代码段寄存器（CS）(Code Segment)：包含代码段的段选择器，其中存储正在执行的指令。处理器使用由CS和EIP组成的逻辑地址从代码段中获取指令</li>
<li>数据段寄存器（DS）(Data Segment)：值为数据段的段值</li>
<li>附加段寄存器（ES）(Extra Segment)：其值为附加数据段的段值</li>
<li>附加段寄存器（FS）(Extra Segment)：其值为附加数据段的段值</li>
<li>附加段寄存器（GS）(Extra Segment)：32位微机系统中可访问</li>
<li>堆栈段寄存器（SS）(Stack Segment)：其值为堆栈段的段值，包含堆栈段的段选择器，其中存储过程堆栈以用于当前正在执行的程序，任务或处理程序，所有堆栈操作都使用SS寄存器来查找。</li>
</ul>
</li>
</ul>
<h3 id="其他特殊目的寄存器">其他特殊目的寄存器：</h3>
<ul>
<li>
<p>指令指针指示器（EIP）：它是32位寄存器，低16位称为IP（8086的指令指针寄存器），用与兼容16位CPU，其内容是下一条要取入CPU的指令在内存中的偏移地址。当一个程序开始运行时，系统把EIP清零，每取入一条指令，EPI自动增加取入CPU的字节数目，所以称EIP为指令指针。<br>
<img src="https://alittlewhiter.github.io/post-images/1583200805247.png" alt="" loading="lazy"></p>
</li>
<li>
<p>时间戳寄存器（TSC）：每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。</p>
</li>
<li>
<p>浮点寄存器（FP）：由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。</p>
</li>
</ul>
<h2 id="64位扩展寄存器简要说明">64位扩展寄存器（简要说明）</h2>
<ul>
<li>X86-64中，通用寄存器都是64位，相对32位的x86来说，标识符从原来的ebp变成rbp。为了向后兼容性，ebp依然可以使用，不过指向了rbp的低32位，新增加通用寄存器r8到r15，其低位分别用d、w、b指定长度。</li>
<li>32位使用栈帧来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数，rax作为返回值。64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用。64位支持一些形式的以PC相关的寻址，而32位只有在jmp的时候才会用到这种寻址方式。其中：
<ul>
<li>rax 作为函数返回值使用</li>
<li>rsp 栈指针寄存器，指向栈顶</li>
<li>rdi，rsi，rdx，rcx，r8，r9 用作函数参数，依次对应第1参数，第2参数</li>
<li>rbx，rbp，r12，r13，14，15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改</li>
<li>r10，r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值<br>
<img src="https://alittlewhiter.github.io/post-images/1583200833479.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料：</h2>
<p>【1】	深入理解计算机体系结构<br>
【2】	X86系列汇编语言程序设计<br>
【3】	李忠，王晓波，余洁．x86汇编语言：从实模式到保护模式[M]．北京：电子工业出版社<br>
【4】	Intel x86 CPU系列的寄存器-wangbaolin719-ChinaUnix博客<br>
URL: http://blog.chinaunix.net/uid-27717694-id-3943419.html<br>
【5】	Intel_x86_CPU系列的寄存器[整理版]<br>
URL: https://www.docin.com/p-880130068.html<br>
【6】	[官方文档]：64-ia-32-architectures-software-developer-manual-325462.pdf</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 板子]]></title>
        <id>https://alittlewhiter.github.io/post/c-ban-zi/</id>
        <link href="https://alittlewhiter.github.io/post/c-ban-zi/">
        </link>
        <updated>2020-03-02T13:42:08.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：代码块、函数、语法 for C++<br>
{ 这 xx 竟 这 该 死 的 甜 美 ...  不要停下来啊~🤙🤙🤙}</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：代码块、函数、语法 for C++<br>
{ 这 xx 竟 这 该 死 的 甜 美 ...  不要停下来啊~🤙🤙🤙}</p>
<!-- more -->
<h2 id="开始你的表演">开始你的表演</h2>
<p>1、设想要使用new建立一个rows行，cols列的矩阵:</p>
<pre><code class="language-c++">int rows, cols ;
int **array = new int*[rows] ; 
for (int i = 0 ; i &lt; rows ; i++) {
    array[i] = new int[cols] ; 
    memset(*array, 0, sizeof(int)*cols) ;    // memset()是按字节填充，值一般只为0或-1。
}  
</code></pre>
<p>2、结构体重载操作符模板：</p>
<pre><code class="language-c++">Point operator + (const Point&amp; A, const Point&amp; B) {  
     return Point(A.x+B.x, A.y+B.y); 
}
ostream&amp; operator &lt;&lt; (ostream &amp;out, const Point&amp; p) {
    out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;  
    return out; 
}
Point a, b;
cout &lt;&lt; a+b &lt;&lt; endl; 
</code></pre>
<p>3、求和函数模板sum()：</p>
<pre><code class="language-c++">template&lt;typename T&gt; T sum(T* begin, T* end) {  
    T *p = begin;  
    T ans = 0;  
    for(T *p = begin; p != end; p++)   
        ans = ans + *p;   
    return ans; 
}
</code></pre>
<p>4、结构体和类也可以是带模板的，如Point中x，y可以为int或double等多种类型：</p>
<pre><code class="language-c++">template &lt;typename T&gt; struct Point {  
    T x, y;  
    Point(T x=0, T y=0) : x(x),y(y) { } 
}; 
</code></pre>
<p>5、重载转换运算符 ：<br>
对于类X的成员函数 X::operator T()<br>
T是类型名 ，定义了一个X到T的转换。</p>
<pre><code class="language-c++">operator bool() const {
   return p;
} 
Handle h; 
bool b=h;       //在这里调用  
</code></pre>
<p>6、C++中const 引用的是对象时只能访问该对象的const 函数，因为其他函数有可能会修改该对象的成员，编译器为了避免该类事情发生，会认为调用非const函数是错误的，error：…discards qualifiers 的意思就是缺少限定符。<br>
因此：** 类似getter函数一般需要在后面加const限定符 **</p>
<p>7、求gcd最大公约数</p>
<ul>
<li>最快算法：</li>
</ul>
<pre><code class="language-c++">int gcd(int a, int b){
    while(b^=a^=b^=a%=b) ;
    return a;
}
</code></pre>
<ul>
<li>一般算法：</li>
</ul>
<pre><code class="language-c++">int gcd(int a,  int b)  {          // 要求
     return b ? gcd(b, a%b) : a ;
}
</code></pre>
<p>8、普通快速幂的模板：</p>
<pre><code class="language-c++">int fastpow(int base, int n, int mod){
	int ans=1; 
	while(n){
		if(n&amp;1) 
                    ans *= base % mod ;
		base *= base;
		n &gt;&gt;= 1;
	}
	return ans%mod;
}
</code></pre>
<p>9、快速读入整数（ 远快于 scanf () 与 cin ）</p>
<pre><code class="language-c++">inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch &lt; '0' || ch &gt; '9') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
</code></pre>
<p>10、</p>
<p>11、</p>
<p>Final、一道大杂烩<sup>真香</sup>  输入输出模板</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
#define maxn 500005
#define maxm 200005
#define INF 1234567890
#define p 1000000007
template&lt;class T&gt;inline bool read(T &amp;x)
{
    x=0;register char c=getchar();register bool f=0;
    while(!isdigit(c)){if(c==EOF)return false;f^=c=='-',c=getchar();}
    while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar();
    if(f)x=-x;
    return true;
}
template&lt;class T&gt;inline bool readd(T &amp;x)
{
    register ll X=0;register double y=1.0;register char c=getchar();register bool f=0;
    while(!isdigit(c)){if(c==EOF)return false;f^=c=='-',c=getchar();}
    while(isdigit(c))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(c^48),c=getchar();
    x=X;
    if(c!='.')return true;
    c=getchar();
    while(isdigit(c))x+=(y/=10)*(c^48),c=getchar();
    if(f)x=-x;
    return true;
}
template&lt;class T&gt;inline bool readc(T &amp;x)
{
    register char c=getchar();
    while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
    if(c==EOF)return false;
    x=c;
    return true;
}
template&lt;class T&gt;inline bool readc(T *x)
{
    register char c=getchar();
    while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
    if(c==EOF)return false;
    while(c!=' '&amp;&amp;c!='\n'&amp;&amp;c!='\r'&amp;&amp;c!='\t'&amp;&amp;c!=EOF)*x++=c,c=getchar();
    *x=0;
    return true;
}
template&lt;class T&gt;inline bool reads(T &amp;x)
{
    x=&quot;&quot;;register char c=getchar();
    while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
    if(c==EOF)return false;
    while(c!=' '&amp;&amp;c!='\n'&amp;&amp;c!='\r'&amp;&amp;c!='\t'&amp;&amp;c!=EOF)x+=c,c=getchar();
    return true;
}
template&lt;class T&gt;inline void print(T x)
{
    if(x&lt;0)putchar('-'),x=-x;
    if(x&gt;9)print(x/10);
    putchar(x%10^48);
}
template&lt;class T&gt;inline void printd(T x,ll y)
{
    static ll mul[]={1};
    for(register ll i=1;i&lt;=18;i++)
        mul[i]=(mul[i-1]&lt;&lt;3)+(mul[i-1]&lt;&lt;1);
    if(x&lt;-1e-12)putchar('-'),x=-x;
    x*=mul[y];
    register ll x1=(ll)round(x),x2=x1/mul[y],x3=x1-x2*mul[y];
    print(x2);
    if(y&gt;0)
    {
        putchar('.');
        for(register ll i=1;i&lt;y&amp;&amp;x3*mul[i]&lt;mul[y];putchar('0'),i++);
        print(x3);
    }
}
template&lt;class T&gt;inline void printc(T x){putchar(x);}
template&lt;class T&gt;inline void printc(T *x){while(*x)putchar(*x++);}
template&lt;class T&gt;inline void prints(T x){for(register ll i=0;x[i]!='\0';i++)putchar(x[i]);}
template&lt;class T&gt;inline T maxd(T a,T b){if(b&gt;a)return b;return a;}
template&lt;class T&gt;inline T mind(T a,T b){if(b&lt;a)return b;return a;}
template&lt;class T&gt;inline T gcd(T a,T b){while(a^=b^=a^=b%=a);return b;}
template&lt;class T&gt;inline T lcm(T a,T b){return a/gcd(a,b)*b;}
template&lt;class T&gt;inline T absd(const T &amp;a){if(a&lt;0)return -a;return a;}
template&lt;class T&gt;inline void print(T x,char c){print(x),putchar(c);}
template&lt;class T&gt;inline void printd(T x,ll y,char c){printd(x,y),putchar(c);}
template&lt;class T&gt;inline void printc(T x,T c){printc(x),putchar(c);}
template&lt;class T&gt;inline void printc(T *x,T c){printc(x),putchar(c);}
template&lt;class T&gt;inline void prints(T x,char c){prints(x),putchar(c);}

</code></pre>
<p>mua~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web：前 前 后 后  ]]></title>
        <id>https://alittlewhiter.github.io/post/webqian-qian-hou-hou/</id>
        <link href="https://alittlewhiter.github.io/post/webqian-qian-hou-hou/">
        </link>
        <updated>2020-03-02T13:07:17.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：html, css, javascript, 标签，布局...<br>
【奥里给 ~hetui！！</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：html, css, javascript, 标签，布局...<br>
【奥里给 ~hetui！！</p>
<!-- more -->
<h2 id="position绝对和相对">Position：绝对和相对</h2>
<h3 id="主要区别">主要区别</h3>
<ul>
<li>Absolution：元素会脱离文档流，定位是相对于离它最近的且不是static定位的父元素而言，若该元素没有设置宽度，则宽度由元素里面的内容决定，且宽度不会影响父元素，定位为absolution后，原来的位置相当于是空的，下面的的元素会来占据。</li>
<li>Relative：元素仍处于文档流中，定位是相对于原本自身的位置，若没有设置宽度，则宽度为父元素的宽度，该元素的大小会影响父元素的大小。</li>
</ul>
<h3 id="position扩展">position扩展</h3>
<ol>
<li>Absolute：绝对定位，是相对于最近的且不是static定位的父元素来定位</li>
<li>Fixed：绝对定位，是相对于浏览器窗口来定位的，是固定的，不会跟屏幕一起滚动。</li>
<li>Relative：相对定位，是相对于其原本的位置来定位的。</li>
<li>Static：默认值，没有定位。</li>
<li>Inherit：继承父元素的position值。</li>
</ol>
<p><strong>一、absolute：绝对定位，CSS 写法“ position: absolute; ”</strong></p>
<ol>
<li>没有设定 Top、Right、Bottom、Left 的情况，默认依据父级的“内容区域原始点”为原始点，上面例子红色部分(父级黄色区域有 Padding 属性，“坐标原始点”和“内容区域原始点”不一样)， 基于绝对定位的元素不会占据空间。</li>
<li>有设定 Top、Right、Bottom、Left 的情况，这里又分了两种情况如下：
<ul>
<li>父级没 position 属性，浏览器左上角(即 Body)为“坐标原始点”进行定位，位置由 Top、Right、Bottom、Left 属性决定。</li>
<li>父级有 position属性，父级的“坐标原始点”为原始点，此时可以忽略父级元素padding的作用。</li>
</ul>
</li>
</ol>
<p><strong>二、relative：相对定位，CSS 写法“ position: relative; ”</strong></p>
<ol>
<li>
<p>父级元素第一个relative子元素参照父级的“内容区域原始点”为原始点，无父级则以 Body 的“内容区域原始点”为原始点，其余依各元素次序顺延下来获得其位置，再受Top、Right、Bottom、Left 属性值影响，且有“撑开或占据高度”的作用。</p>
</li>
<li>
<p>相对定位与绝对定位的区别在于它的参照点不是左上角的原点，而是该元素本身原先的起点位置。并且即使该元素偏移到了新的位置，也仍然从原始的起点处占据空间。</p>
<p><strong>注</strong>：Absolute定位的子元素宽度不会影响父元素的宽度，而relative定位的子元素可能会撑大父元素。在没有独立设置宽度时，absolute定位的子元素的宽度会自动缩小为内部元素的布局应有的宽度，而relative定位的元素会继承父元素的宽度（甚至超出父元素范围产生覆盖），但不包括边界宽度。</p>
</li>
</ol>
<h2 id="超链接-aa">超链接 <a></a></h2>
<ul>
<li>超链接虽然在网页中占有不可替代的地位, 但是在HTML中创建超链接非常简单, 只需用<code>&lt;a&gt;&lt;/a&gt;</code>标记环绕需要被链接的对象即可。<br>
<code>基本语法格式: &lt;a href-&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式”&gt;文本或图像&lt;/a&gt;</code></li>
<li>在上面的语法中, &lt;a&gt;标记是一个行内标记,用于定义超链接, href和target为其常用属性，具体解释如下:<br>
-- <code>href</code>：用于指定链接目标的url地址。当为&lt;a&gt;标记应用href属性时，它就具有了超链接的功能。<br>
-- <code>target</code>：用于指定链接页面的打开方式，其取值有self和blank两种，其中self为默认值。意为在原窗口中打开，blank为在新窗口中打开。</li>
</ul>
<h2 id="文本居中">文本居中</h2>
<ul>
<li>在将&lt;span&gt;标签style属性设置为vertical-align: middle 后，元素内容并没有垂直居中，在W3C官方中对 vertical-align做了下面的解释：This property affects the vertical positioning inside a line box of the boxes generated by an inline-level element.</li>
<li>事实上，一个Box中由很多行很多元素组成，vertical-align只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。如果把 vertical-align:middle 放到一个单元格元素，即table的td元素中，它的垂直居中显示是没任何问题的，因为它表示相对于该行的垂直高度居中显示。</li>
<li>可以设置&lt;span&gt;元素style中的 line-heght 值为其父元素&lt;div&gt;的height值，这样 vertical-align:middle 就会使&lt;span&gt;元素内容垂直居中。</li>
</ul>
<h2 id="css选择器">CSS选择器</h2>
<p>css选择器诸如div p、div&gt;p、div+p、div~p、div.a 的用法和区别</p>
<h3 id="div-p">div p ：</h3>
<blockquote>
<p>将所有<code>&lt;div&gt;</code>标签里面的<code>&lt;p&gt;</code>标签选中（子标签和孙子辈标签）</p>
</blockquote>
<h3 id="divp">div&gt;p ：</h3>
<blockquote>
<p>将所有<code>&lt;div&gt;</code>标签的子标签<code>&lt;p&gt;</code>选中，不包括孙子辈标签。</p>
</blockquote>
<h3 id="divp-2">div+p ：</h3>
<blockquote>
<p>将所有离<code>&lt;div&gt;</code> <strong>最近</strong>的<code>&lt;p&gt;</code>标签选中</p>
</blockquote>
<h3 id="div~p">div~p ：</h3>
<blockquote>
<p>将<code>&lt;div&gt;</code> <strong>后面</strong>所有的<p>标签选中</p>
</blockquote>
<h3 id="diva">div.a ：</h3>
<blockquote>
<p>将<code>&lt;div&gt;</code>下 <strong>class=a</strong>的标签选中</p>
</blockquote>
<h3 id="p-span">p, span ：</h3>
<blockquote>
<p>将全部的p和span标签都选中</p>
</blockquote>
<h2 id="正则匹配生日">正则匹配生日：</h2>
<pre><code class="language-javascript">var checkBirth = function (val) {
  var pattern = /^((19[2-9]\d{1})|(20((0[0-9])|(1[0-8]))))\-((0?[1-9])|(1[0-2]))\-((0?[1-9])|([1-2][0-9])|30|31)$/;
  if(pattern.test(val)) {
    var date = new Date(val);
    var month = val.substring(val.indexOf(&quot;-&quot;)+1,val.lastIndexOf(&quot;-&quot;));
    return date &amp;&amp; (date.getMonth()+1 == parseInt(month));
  }
  return false;
}
</code></pre>
<p>或者：</p>
<pre><code class="language-javascript">var checkBirth = function (val) {
  var pattern = /^((?:19[2-9]\d{1})|(?:20(?:(?:0[0-9])|(?:1[0-8]))))\-((?:0?[1-9])|(?:1[0-2]))\-((?:0?[1-9])|(?:[1-2][0-9])|30|31)$/;
  var result = val.match(pattern);
  if(result != null) {
    var iYear = parseInt(result[1]);
    var month = result[2];
    var date = result[3];
    if(/^((0?[469])|11)$/.test(month) &amp;&amp;　date == '31') {
      return false;
    } else if(parseInt(month) == 2){
      if((iYear % 4 ==0 &amp;&amp; iYear % 100 != 0) || (iYear % 400 == 0)) {
        if(date == '29') {
          return true;
        }
      }
      if(parseInt(date) &gt; 28) {
        return false;
      }
    }
    return true;
  }
  return false;
}
</code></pre>
<h2 id="more">More...</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Computer Network 默 · 示 · 录]]></title>
        <id>https://alittlewhiter.github.io/post/computer-network-mo-shi-lu/</id>
        <link href="https://alittlewhiter.github.io/post/computer-network-mo-shi-lu/">
        </link>
        <updated>2020-03-02T12:47:24.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords： WIFI、WLAN、跃点、RJ45、and so on<br>
bie说了，反正天<s>填</s>坑啊！😭😭😭<br>
#- 丢你Wang Zhong，你好！🕷 -#</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords： WIFI、WLAN、跃点、RJ45、and so on<br>
bie说了，反正天<s>填</s>坑啊！😭😭😭<br>
#- 丢你Wang Zhong，你好！🕷 -#</p>
<!-- more -->
<h2 id="wlan-和wifi-的区别">WLAN 和WIFI 的区别？</h2>
<ul>
<li>WIFI包含于WLAN中，主要采用802.11b协议的一项技术，是WLAN的一个标准，子集的关系。它们发射信号的功率不同，覆盖范围不同。</li>
<li>WIFI就是一种无线联网的技术，一般都是小范围的， 距离发射器远了就会收不到网络，而wlan覆盖范围就广泛的多</li>
</ul>
<h2 id="跃点">跃点：</h2>
<ul>
<li>即路由。一个路由为一个跃点。传输过程中需要经过多个网络，每个被经过的网络设备点（有能力路由的）叫做一个跃点，地址就是它的ip。跃点数是经过了多少个跃点的累加器，为了防止无用的数据包在网上流散。 为路由指定所需跃点数的整数值（范围是 1 ~ 9999），它用来在路由表里的多个路由中选择与转发包中的目标地址最为匹配的路由, 所选的路由具有最少的跃点数。自动跃点修改方法如下：
<ul>
<li>进入相关设备的网络设置，再进入internet TCP/IP的属性设置，再进入高级属性设置；</li>
<li>默认情况下是勾选的“自动跃点”，不要选择它，手动输入“接口跃点数”，输入的数字越小，优先级越高，这样可以手动控制哪个路由的优先级了。</li>
</ul>
</li>
</ul>
<h2 id="rj45接口">RJ45接口</h2>
<ul>
<li>有两类：用于以太网网卡(网卡接口)、路由器以太网接口等的DTE类型，还有用于交换机等的DCE类型。DTE我们可以称做“数据终端设备”，DCE我们可以称做“数据通信设备”。从某种意义来说，DTE设备称为“主动通信设备”，DCE设备称为“被动通信设备”。当两个类型一样的设备使用RJ45接口连接通信时，必须使用交叉线连接。</li>
</ul>
<h2 id="ip分配">IP分配</h2>
<ul>
<li>169.254.0.0/16这样的IP是一个本地链接地址段。RFC3927指出，在IP网络里，每台主机都需要一个IP地址，通常情况下是通过DHCP服务器自动分配，但某些特殊情况下，DHCP分配失败或者没有DHCP服务器时，机器可以自己分配一个IP来完成这个工作。<br>
169.254.X.X是 Windows操作系统 在 DHCP 信息租用失败时自动给客户机分配的IP地址。由于网络连接问题、网线问题,DHCP服务器(其实就是Modem, 路由器, 或提供共享上网的主机)问题等，而令DHCP信息租用失败, 而IP169.254.X.X 的分配可能会令客户机(你自己的计算机,设置了&quot;自动获取IP&quot;)与所处局域网网关(Modem, 路由器, 或提供共享上网的主机) 位于不同的网段中, 而无法与网关通信,而导致无法接入Internet的情况。</li>
</ul>
]]></content>
    </entry>
</feed>