<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alittlewhiter.github.io</id>
    <title>君の知らない物语</title>
    <updated>2020-04-03T11:07:45.462Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alittlewhiter.github.io"/>
    <link rel="self" href="https://alittlewhiter.github.io/atom.xml"/>
    <subtitle>Took the sourest lemon that life has to offer and turned it into something resembling lemonade.</subtitle>
    <logo>https://alittlewhiter.github.io/images/avatar.png</logo>
    <icon>https://alittlewhiter.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 君の知らない物语</rights>
    <entry>
        <title type="html"><![CDATA[瞎几把扯下排序...]]></title>
        <id>https://alittlewhiter.github.io/post/xia-ji-ba-che-xia-pai-xu/</id>
        <link href="https://alittlewhiter.github.io/post/xia-ji-ba-che-xia-pai-xu/">
        </link>
        <updated>2020-04-03T08:13:25.000Z</updated>
        <summary type="html"><![CDATA[<p>keywords: 经典排序算法，C/C++，笔记备忘</p>
<p>pro, 太pro了！</p>
]]></summary>
        <content type="html"><![CDATA[<p>keywords: 经典排序算法，C/C++，笔记备忘</p>
<p>pro, 太pro了！</p>
<!-- more -->
<h2 id="排序的概念">排序的概念</h2>
<p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列调整为“有序”的记录序列。</p>
<p>排序分为内部排序和外部排序。</p>
<p>若整个排序过程不需要访问外存便能完成，则称此类排序问题为内部排序。</p>
<p>反之，若参加排序的记录数量很大，整个序列的排序过程不可能在内存中完成，则称此类排序问题为外部排序。</p>
<h2 id="排序的分类">排序的分类</h2>
<p>这里主要介绍的八种排序算法均属于<code>内部排序</code>。如果按照策略来分类，大致可分为：交换排序、插入排序、选择排序、归并排序和基数排序。如下图所示：<br>
<img src="https://alittlewhiter.github.io/post-images/1585901877572.jpg" alt="" loading="lazy"></p>
<h2 id="算法概述">算法概述</h2>
<ol>
<li>
<p>插入排序<br>
<strong>直接插入排序</strong><br>
将第一个和第二个元素排好序，然后将第3个元素插入到已经排好序的元素中，依次类推（插入排序最好的情况就是数组已经有序了）</p>
<p><strong>希尔排序</strong><br>
因为插入排序每次只能操作一个元素，效率低。希尔排序对待排序的N个元素，取奇数k=N/2，将下标差值为k的数分为一组（一组元素个数看总元素个数决定），在组内构成有序序列，再取k=k/2，将下标差值为k的数分为一组，构成有序序列，直到k=1，然后再进行直接插入排序。</p>
</li>
<li>
<p>选择排序<br>
<strong>简单选择排序</strong><br>
选出最小的数和第一个数交换，再在剩余的数中又选择最小的和第二个数交换，依次类推。</p>
<p><strong>堆排序</strong><br>
以升序排序为例，利用<code>小根堆</code>或<code>大根堆</code>的性质，不断输出最小元素或移动最大元素，直到堆中元素全部有序。</p>
</li>
<li>
<p>交换排序<br>
<strong>冒泡排序</strong><br>
改进1：如果某次冒泡不存在数据交换，则说明已经排序好了，可以直接退出排序。<br>
改进2：头尾进行冒泡，每次把最大的沉底，最小的浮上去，两边往中间靠1。</p>
<p><strong>快速排序</strong><br>
选择一个基准元素，比基准元素小的放基准元素的前面，比基准元素大的放基准元素的后面，这种动作叫分区，每次分区都把一个数列分成了两部分，每次分区都使得一个数字有序，然后将基准元素前面部分和后面部分继续分区，一直分区直到分区的区间中只有一个元素</p>
</li>
<li>
<p>归并排序<br>
<strong>一般归并排序</strong><br>
将一个无序的数列一直一分为二，直到分到序列中只有一个数的时候，这个序列肯定是有序的，因为只有一个数，然后将两个只含有一个数字的序列合并为含有两个数字的有序序列，这样一直进行下去，最后就变成了一个全部的有序数列，合并时一般需要额外的内存空间用于存放临时数组。</p>
<p><strong>在位归并排序</strong><br>
不需要辅助数组即可实现分区的合并。</p>
</li>
<li>
<p>基数排序<br>
找到最大的数，开个比最大的数大一点的数组，遍历每个元素，某个元素为k，则a[k]++,最好遍历数组a，a[k]等于多少就输出多少个k，只能处理整型数。</p>
</li>
<li>
<p>计数排序。。。</p>
</li>
</ol>
<p>又或者按照排序稳定性：</p>
<p><strong>不稳定排序</strong>：简单选择排序，快速排序，希尔排序，堆排序<br>
<strong>稳定排序</strong>：冒泡排序，直接插入排序，归并排序，基数排序</p>
<h2 id="代码分析">代码分析</h2>
<ol>
<li>
<p>直接插入排序（Insertion Sort)<br>
<strong>算法思想</strong>：直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过 因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成：<br>
<mark>第一层循环</mark>：遍历待比较的所有数组元素<br>
<mark>第二层循环</mark>：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。如果：selected &gt; ordered，那么将二者交换。</p>
<pre><code class="language-c++">void InsertSort(int a[], int n) {
    for(int i= 1; i&lt;n; i++) {
        if(a[i] &lt; a[i-1]) {   //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
            int j= i-1;  
            int x = a[i];     //复制为哨兵，即存储待排序元素
            a[i] = a[i-1];           //先后移一个元素
            while(x &lt; a[j]){   //查找在有序表的插入位置
                a[j+1] = a[j];
                j--;     //元素后移
            }
            a[j+1] = x;     //插入到正确位置
        }
    }
}
</code></pre>
</li>
<li>
<p>希尔排序（Shell‘s Sort）</p>
<p><strong>算法思想</strong>：希尔排序也称 <code>递减增量排序</code> 算法，是插入排序的一种更高效的改进版本，但希尔排序是非稳定排序算法。希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p>算法步骤：</p>
<ul>
<li>
<p>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</p>
</li>
<li>
<p>按增量序列个数k，对序列进行k 趟排序；</p>
</li>
<li>
<p>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ul>
<p>图<img src="https://alittlewhiter.github.io/post-images/1585911980835.png" alt="" loading="lazy"></p>
<pre><code class="language-c++">void ShellInsertSort(int a[], int n, int dk) {
    for(int i= dk; i&lt;n; ++i) {
        if(a[i] &lt; a[i-dk]) {      //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
            int j = i-dk;  
            int x = a[i];      //复制为哨兵，即存储待排序元素
            a[i] = a[i-dk];      //首先后移一个元素
            while(x &lt; a[j]) {    //查找在有序表的插入位置
                a[j+dk] = a[j];
                j -= dk;       //元素后移
            }
            a[j+dk] = x;      //插入到正确位置
        }
    }
}

 // 先按增量d（n/2,n为要排序数的个数进行希尔排序
void shellSort(int a[], int n) {
    int dk = n/2;
    while( dk &gt;= 1  ){
        ShellInsertSort(a, n, dk);
        dk = dk/2;
    }
}
</code></pre>
<p>关于增量序列的选择：</p>
<ul>
<li></li>
</ul>
</li>
</ol>
<p>​</p>
<ol start="3">
<li>
<p><strong>简单选择排序（Selection Sort）</strong></p>
<p>算法思想：简单选择排序的实现思想：<code>比较+交换</code></p>
<ol>
<li>从待排序序列中，找到关键字最小的元素；</li>
<li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li>
<li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。因此我们可以发现，简单选择排序也是通过两层循环实现。第一层循环：依次遍历序列当中的每一个元素 第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。</li>
</ol>
<pre><code class="language-c++">int SelectMinKey(int a[], int n, int i) {
    int k = i;
    for(int j=i+1 ; j&lt; n; ++j) 
        if(a[k] &gt; a[j])
            k = j;
    return k;
}

void selectSort(int a[], int n) {
    int key, tmp;
    for(int i = 0; i&lt; n; ++i) {
        key = SelectMinKey(a, n,i);           //选择最小的元素
        if(key != i) {
            tmp = a[i];
            a[i] = a[key];
            a[key] = tmp; 			//最小元素与第i位置元素互换
        }
    }
}
</code></pre>
</li>
<li>
<p>堆排序（Heap Sort）</p>
<p><strong>堆的概念</strong>：<mark>堆</mark>本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆：</p>
<ul>
<li>
<p>大顶堆要求节点的元素都要大于其孩子。</p>
</li>
<li>
<p>小顶堆要求节点元素都小于其左右孩子。</p>
</li>
</ul>
<p>两者对左右孩子的大小关系不做任何要求。</p>
<p>利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法，下面通过大顶堆来实现。</p>
<p>基本思想：堆排序可以按照以下步骤来完成：</p>
<ol>
<li>
<p>首先将序列构建称为大顶堆；（这样满足了大顶堆的性质：位于根节点的元素一定是当前序列的最大值）</p>
</li>
<li>
<p>取出当前大顶堆的根节点，将其与序列末尾元素进行交换；（此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质）</p>
</li>
<li>
<p>对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质；</p>
</li>
<li>
<p>重复2.3步骤，直至堆中只有1个元素为止</p>
</li>
</ol>
<pre><code class="language-c++">/**
 * 已知H[s…m]除了H[s] 外均满足堆的定义
 * 调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选,
 *
 * @param H是待调整的堆数组
 * @param s是待调整的数组元素的位置
 * @param length是数组的长度
 */
void HeapAdjust(int H[],int s, int length) {
    int tmp  = H[s];
    int child = 2*s+1; //左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置)
    while (child &lt; length) {
        if(child+1 &lt;length &amp;&amp; H[child]&lt;H[child+1]) { // 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点)
            ++child ;
        }
        if(H[s]&lt;H[child]) {     // 如果较大的子结点大于父结点
            H[s] = H[child];    // 那么把较大的子结点往上移动，替换它的父结点
            s = child;          // 重新设置s ,即待调整的下一个结点的位置
            child = 2*s+1;
        }  else {               // 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出
            break;
        }
        H[s] = tmp;             // 当前待调整的结点放到比其大的孩子结点位置上
    }
}

void HeapSort(int H[],int length) {
    //建立初始堆
    //最后一个有孩子的节点的位置 i=  (length -1) / 2
    for (int i = (length -1) / 2 ; i &gt;= 0; --i)
        HeapAdjust(H,i,length);
    
    //从最后一个元素开始对序列进行调整
    for (int i = length - 1; i &gt; 0; --i) {
        //交换堆顶元素H[0]和堆中最后一个元素
        int temp = H[i];
        H[i] = H[0];
        H[0] = temp;
        //每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整
        HeapAdjust(H,0,i);
    }
}

</code></pre>
</li>
<li>
<p>冒泡排序（Bubble Sort）</p>
<p><strong>算法思想</strong>：冒泡遍历所有的数据，每次对相邻元素进行两两比较，如果顺序和预先规定的顺序不一致，则进行位置交换；这样一次遍历会将最大或最小的数据上浮到顶端，之后再重复同样的操作，直到所有的数据有序。</p>
<p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，冒泡排序算法的运作如下：</p>
<ul>
<li>
<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li>
<p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li>
<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
</li>
</ul>
<pre><code class="language-c++">void bubbleSort(int a[], int n) {
    for(int i =0 ; i&lt; n-1; ++i) {
        for(int j = 0; j &lt; n-i-1; ++j) {
            if(a[j] &gt; a[j+1]) {
                int tmp = a[j] ;
                a[j] = a[j+1] ;
                a[j+1] = tmp;
            }
        }
    }
}
</code></pre>
</li>
<li>
<p><strong>快速排序（Quick Sort）</strong></p>
<p><strong>算法思想</strong>：快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n logn)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。</p>
<p>事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>算法步骤：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）。</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。</li>
</ol>
<pre><code class="language-c++">void swap(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int partition(int a[], int low, int high) {
    int privotKey = a[low];                //基准元素
    while(low &lt; high) {                   //从表的两端交替地向中间扫描
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey)
            --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端
        swap(&amp;a[low], &amp;a[high]);
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey )
            ++low;
        swap(&amp;a[low], &amp;a[high]);
    }
    return low;
}


void quickSort(int a[], int low, int high) {
    if(low &lt; high) {
        int privotLoc = partition(a,  low,  high);  //将表一分为二
        quickSort(a,  low,  privotLoc -1);      //递归对低子表递归排序
        quickSort(a,   privotLoc + 1, high);    //递归对高子表递归排序
    }
}
</code></pre>
</li>
<li>
<p><strong>归并排序（Merge Sort）</strong></p>
<p><strong>算法思想</strong>：归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>算法步骤：</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤3直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<pre><code class="language-c++">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]
void Merge(ElemType *r,ElemType *rf, int i, int m, int n) {
    int j,k;
    for(j=m+1,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k) {
        if(r[j] &lt; r[i])
            rf[k] = r[j++];
        else
            rf[k] = r[i++];
    }
    while(i &lt;= m)
        rf[k++] = r[i++];
    while(j &lt;= n)
        rf[k++] = r[j++];
}

void MergeSort(ElemType *r, ElemType *rf, int lenght) {
    int len = 1;
    ElemType *q = r ;
    ElemType *tmp ;
    while(len &lt; lenght) {
        int s = len;
        len = 2 * s ;
        int i = 0;
        while(i+ len &lt;lenght) {
            Merge(q, rf,  i, i+ s-1, i+ len-1 ); //对等长的两个子表合并
            i = i+ len;
        }
        if(i + s &lt; lenght) {
            Merge(q, rf,  i, i+ s -1, lenght -1); //对不等长的两个子表合并
        }
        tmp = q;
        q = rf;
        rf = tmp; //交换q,rf，以保证下一趟归并时，仍从q 归并到rf
    }
}
</code></pre>
<p>一般在提到<a href="http://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a>时，大都想到上面分治Divide-and-Conqure算法, 它一般是O(nlgn)的时间复杂度以及额外的O(n)空间。，但实际上<strong>O(n)的额外空间</strong>这一缺点是完全可以克服的，完全<code>可以实现O(nlgn) 时间效率以及 O(1) 额外空间</code> 的归并排序。对于这种不用额外空间(即<code>常数大小的额外空间</code>)的算法，有一个通用的名字叫做In-place Algorithms，因此我们称该归并算法为 <code>In-place merge sort</code> ，也就是<code>在位归并排序</code> 。</p>
<p><strong>在位归并排序</strong>：</p>
<p>在C++头文件中有在位归并排序的模板实现：<code>#include&lt;algorithm&gt;</code>  ，<code>void std::inplace_merge(_BIter, _BIter, _BIter);</code></p>
<pre><code class="language-c++">#include&lt;algorithm&gt;

int num[arrayLength];

mergesort(0, arrayLength-1);		// main()函数调用

void mergesort(int left,int right) {
    if(left&gt;=right)
        return;
    int mid=(left+right)/2;
    mergesort(left,mid);
    mergesort(mid+1,right);
    inplace_merge(number+left, number+mid+1, number+right+1);
}
</code></pre>
<p>另外，还可以通过 <code>循环左移</code> 来实现归并操作：</p>
<pre><code class="language-c++">//将长度为n的数组逆序
void reverse(int *arr,int n) {
    int i=0,j=n-1;
    while(i&lt;j) {
        swap(arr[i],arr[j]);
        i++;
        j--;
    }
}

//将数组向左循环移位i个位置
void exchange(int *arr,int n,int i) {
    reverse(arr,i);
    reverse(arr+i,n-i);
    reverse(arr,n);
}

//数组两个有序部分的归并
void merge(int *arr,int begin,int mid,int end) {
    int i=begin,j=mid,k=end;
    while(i&lt;j &amp;&amp; j&lt;=k) {
        int step=0;
        while(i&lt;j &amp;&amp; arr[i]&lt;=arr[j])
            ++i;
        while(j&lt;=k &amp;&amp; arr[j]&lt;=arr[i]) {
            ++j;
            ++step;
        }
        exchange(arr+i,j-i,j-i-step);
        i=i+step;
    }
}

void MergeSort(int *arr,int l,int r) {
    if(l&lt;r) {
        int mid=(l+r)/2;
        MergeSort(arr,l,mid);
        MergeSort(arr,mid+1,r);
        merge(arr,l,mid+1,r);
    }
}
</code></pre>
</li>
<li>
<p><strong>基数排序(Radix Sort)</strong></p>
<p><strong>算法思想</strong>：基数排序 通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p>
<p>分配：将 L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中 。</p>
<p>收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列 L[ ] 。</p>
<p>对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束。</p>
<pre><code class="language-c++">void RadixSort(Node L[],length,maxradix) {
    int m,n,k,lsp;
    k=1;
    m=1;
    int temp[10][length-1];
    Empty(temp); //清空临时空间
    while(k&lt;maxradix) { //遍历所有关键字
        for(int i=0; i&lt;length; i++) { //分配过程
            if(L[i]&lt;m)
                Temp[0][n]=L[i];
            else
                Lsp=(L[i]/m)%10; //确定关键字
            Temp[lsp][n]=L[i];
            n++;
        }
        CollectElement(L,Temp); //收集
        n=0;
        m=m*10;
        k++;
    }
}

</code></pre>
</li>
</ol>
<h2 id="总结分析">总结分析</h2>
<p>各算法の时间复杂度函数O(n)的增长情况如图：<br>
<img src="https://alittlewhiter.github.io/post-images/1585912012375.png" alt="" loading="lazy"></p>
<p>所以对n较大的排序记录，一般的选择都是时间复杂度为O(nlog2n)的排序方法。</p>
<ol>
<li>
<p>平方阶(O(n2))排序</p>
<p>各类简单排序:直接插入、直接选择和冒泡排序；</p>
</li>
<li>
<p>线性对数阶(O(nlog2n))排序</p>
<p>快速排序、堆排序和归并排序；</p>
</li>
<li>
<p>O(n1+§))排序,§是介于0和1之间的常数。</p>
<p>希尔排序</p>
</li>
<li>
<p>线性阶(O(n))排序</p>
<p>基数排序，此外还有桶排序、箱排序。</p>
</li>
</ol>
<p><em><strong>因此</strong></em>：</p>
<ul>
<li>
<p>当原表有序或基本有序时，<code>直接插入排序</code>和<code>冒泡排序</code>将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</p>
</li>
<li>
<p>而<code>快速排序</code>则相反，<mark>当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）</mark>；</p>
</li>
<li>
<p>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</p>
</li>
</ul>
<p><strong>排序算法的稳定性</strong>: 若待排序的序列中，存在多个<code>具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变</code>，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。</p>
<p><strong>稳定性的好处</strong>：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。</p>
<ul>
<li>
<p>基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；</p>
</li>
<li>
<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</p>
</li>
<li>
<p>不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</p>
</li>
</ul>
<h2 id="何种排序算法">何种排序算法？</h2>
<p>考虑的因素有以下四点：</p>
<ol>
<li>
<p>待排序的记录数目n的大小；</p>
</li>
<li>
<p>记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</p>
</li>
<li>
<p>关键字的结构及其分布情况；</p>
</li>
<li>
<p>对排序稳定性的要求。</p>
</li>
</ol>
<p>具体来说：设待排序元素的个数为n</p>
<p>1）当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：<code>快速排序</code>、<code>堆排序</code>或<code>归并排序</code>。</p>
<ul>
<li>
<p>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p>
</li>
<li>
<p>堆排序 ： 如果内存空间允许且要求稳定性的，</p>
</li>
<li>
<p>归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</p>
</li>
</ul>
<p>2） 当n较大，内存空间允许，且要求稳定性：归并排序</p>
<p>3）当n较小，可采用直接插入或直接选择排序。</p>
<ul>
<li>
<p>直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。</p>
</li>
<li>
<p>直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序</p>
</li>
</ul>
<p>4）一般不使用或不直接使用传统的冒泡排序。</p>
<p>5）基数排序</p>
<ul>
<li>它是一种稳定的排序算法，但有一定的局限性：
<ol>
<li>关键字可分解。</li>
<li>记录的关键字位数较少，如果密集更好。</li>
<li>如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P r o v e r]]></title>
        <id>https://alittlewhiter.github.io/post/prover/</id>
        <link href="https://alittlewhiter.github.io/post/prover/">
        </link>
        <updated>2020-03-31T09:11:03.000Z</updated>
        <summary type="html"><![CDATA[<p>证明。。。</p>
]]></summary>
        <content type="html"><![CDATA[<p>证明。。。</p>
<!-- more -->
<h2 id="floyd算法的正确性证明">Floyd算法的正确性证明</h2>
<ul>
<li>用数学归纳法证明： 假设存在一条最短路径为i,d1,d2,d3,…,dk,j (i,j,dt均为点的标号)，也就是说从i到j的最短路径就是这一条，并且其中任意两点距离也都是最短的（反证法）。</li>
<li>我们现在需要证明，这条路径的权值在外层循环k=max(d1,d2,d3,…,dk),我们记成max(i to j),被填入到矩阵D中。</li>
<li>设P为i与j的最短路径中还需要经过的点的个数
<ul>
<li>当P=0的时候显然成立，因为i与j的最短路径为直接相连的那条边</li>
<li>当P=1的时候也成立，因为当外层循环k等于那个点的时候，就可以得到D[i][k]+D[k][j]并填入到D中</li>
<li>假设P&lt;=m时成立，即对于任意两点路径，若它们之间经过的点小于等于m，则有k=max(d1,d2,…,dP)时，i,j最短路径权值被填入到矩阵D中。</li>
<li>当P=m+1时，找到这经过的m+1个点中标号最大的点dt，也就是说dt=max(d1,d2,…,dm+1),那么dt与j或i之间最多只有m个点，按照前面的假设，我们知道在k=max(i to dt)和k=max(dt to j)的时候，D[i][dt]和D[dt][j]会获得最短的路径权值，又因为dt &gt; max(i to dt) 且 dt &gt; max(dt to j)，所以当k=dt的时候，我们知道D[i][j]=D[i][dt]+D[dt][j]一定是最后的结果了，这时，P=m+1情况成立。</li>
</ul>
</li>
</ul>
<h2 id="next">next...</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最左&最右推导、语法树]]></title>
        <id>https://alittlewhiter.github.io/post/zui-zuo-andzui-you-tui-dao-yu-fa-shu/</id>
        <link href="https://alittlewhiter.github.io/post/zui-zuo-andzui-you-tui-dao-yu-fa-shu/">
        </link>
        <updated>2020-03-26T10:36:42.000Z</updated>
        <summary type="html"><![CDATA[<p>keyeords：最左推导、最右推导、语法树、二义性</p>
]]></summary>
        <content type="html"><![CDATA[<p>keyeords：最左推导、最右推导、语法树、二义性</p>
<!-- more -->
<h2 id="最左推导和最右推导">最左推导和最右推导</h2>
<ul>
<li>
<p><strong>最左推导</strong>：任何一步α =&gt; β都是对α中的最左一个非终结符进行替换</p>
</li>
<li>
<p><strong>最右推导</strong>：任何一步α =&gt; β都是对α中的最右一个非终结符进行替换</p>
</li>
<li>
<p>例如：<br>
文法G(E)为：</p>
<ul>
<li>
<p>E -&gt; T | E + T |E - T</p>
</li>
<li>
<p>T -&gt; F | T * F | T / F</p>
</li>
<li>
<p>F -&gt; (E) | i</p>
</li>
</ul>
<p>给出i * (i + i)的最左推导和最右推导。</p>
<pre><code class="language-nohighlight">最左推导：
从文法的起始符号开始：
E -&gt; T
-&gt; T * F
-&gt; F * F
-&gt; i * F
-&gt; i * (E)
-&gt; i * (E + T)
-&gt; i * (T +T)
-&gt; i * (F + T)
-&gt; i * (i + T)
-&gt; i * (i + F)
-&gt; i * (i + i)
最右推导：
从文法的开始符号开始：
E -&gt; T
-&gt; T * F
-&gt; T * (E)
-&gt; T * (E + T)
-&gt; T * (E + F)
-&gt; T * (E + i)
-&gt; T * (T + i)
-&gt; T * (F + i)
-&gt; T * (i + i)
-&gt; F * (i + i)
-&gt; i * (i + 1)
</code></pre>
</li>
</ul>
<h2 id="文法的二义性">文法的二义性</h2>
<ul>
<li>给定一个文法G，如果L（G）中存在一个具有两棵或两棵以上分析树的句子， 我们就称该文法为二义性的，G也叫二义性文法。<br>
<strong>造成二义性的原因</strong>：文法中没有体现出结合率和优先级<br>
<img src="https://alittlewhiter.github.io/post-images/1585262146917.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[某科学のPrime]]></title>
        <id>https://alittlewhiter.github.io/post/mou-ke-xue-noprime/</id>
        <link href="https://alittlewhiter.github.io/post/mou-ke-xue-noprime/">
        </link>
        <updated>2020-03-21T11:15:20.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：判断质数、求素数</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：判断质数、求素数</p>
<!-- more -->
<ol>
<li>
<p>判断素数的效率算法：</p>
<pre><code class="language-c++">bool isprime(long x){
    if(x==2 || x==3 || x==5)
        return true;
    if(x%2==0 || x%3==0 || x%5==0 || x&lt;2)
        return false;
    long c = 7, mc = int(sqrt(x));
    while(c &lt;= mc){
        if(x%c == 0)
            return false;
        c += 4;
        if(x%c == 0)
            return false;
        c += 2;
        if(x%c == 0)
            return false;
        c += 4;
        if(x%c == 0)
            return false;
        c += 2;
        if(x%c == 0)
            return false;
        c += 4;
        if(x%c == 0)
            return false;
        c += 6;
        if(x%c == 0)
            return false;
        c += 2;
        if(x%c == 0)
            return false;
        c += 6;
    }
    return true;
}
</code></pre>
</li>
<li>
<p>求取n以内的素数：</p>
<pre><code class="language-java">int countPrimes(int n) {
    if(!n||n==1)  return 0;
    vector&lt;bool&gt; isPrime(n,true);
    for(int i=2;i*i&lt;n;++i) {
        if(!isPrime[i]) continue;
        //填表起点i*i，如3*3，因为3*2已填，步长+i
        for(int j=i*i;j&lt;n;j+=i) {
            isPrime[j]=false;
        }
    }
    int count=0;
    for(int i=2;i&lt;n;++i) {
        if(isPrime[i])  ++count;
    }
    return count;
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DFS & BFS]]></title>
        <id>https://alittlewhiter.github.io/post/dfs-and-bfs/</id>
        <link href="https://alittlewhiter.github.io/post/dfs-and-bfs/">
        </link>
        <updated>2020-03-18T08:36:25.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：dfs，bfs</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：dfs，bfs</p>
<!-- more -->
<h2 id="深度优先搜索dfs">深度优先搜索（DFS）</h2>
<h2 id="广度优先搜索bfs">广度优先搜索（BFS）</h2>
<h2 id="二者的比较">二者的比较 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2>
<ul>
<li>
<p>一般来说，BFS常用于找单一的最短路线，或者是规模小的路径搜索，它的特点是”搜到就是最优解”， 而DFS用于找多个解或者是”步数已知（好比3步就必需达到前提）”的标题，它的空间效率高，然则找到的不必定是最优解，必需记实并完成全数搜索，故一般情况下，深搜需要很是高效的剪枝（优化）.</p>
</li>
<li>
<p>搜索最短路径这些的很显著是用广搜，因为广搜的特征就是一层一层往下搜的，保证当前搜到的都是最优解，当然，最短路径只是一方面的操作，像什么起码状态转换也是可以操作的。</p>
</li>
<li>
<p>深搜就是优先搜索一棵子树，然后是另一棵，它和广搜对比，有着内存需要相对较少的所长，八皇后标题就是典范楷模的操作，这类标题很显著是不能用广搜往解决的。或者像图论里面的找圈的算法，数的前序中序后序遍历等，都是深搜。</p>
<p>深搜的实现近似于栈，广搜则是操作了队列，边进队，边出队。</p>
</li>
<li>
<p><strong>优缺点</strong>：BFS:对于解决最短或最少问题特别有效，而且寻找深度小，但缺点是内存耗费量大（需要开大量的数组单元用来存储状态）。<br>
DFS：对于解决遍历和求所有问题有效，对于问题搜索深度小的时候处理速度迅速，然而在深度很大的情况下效率不高</p>
</li>
<li>
<p>不管是BFS还是DFS，它们虽然好用，但由于时间和空间的局限性，以至于它们只能解决数据量小的问题。</p>
</li>
</ul>
<p><strong>坐标类型搜索</strong> ：这种类型的搜索题目通常来说简单的比较简单，复杂的通常在边界的处理和情况的讨论方面会比较复杂，分析这类问题，我们首先要抓住题目的意思，看具体是怎么建立坐标系（特别重要），然后仔细分析到搜索的每一个阶段是如何通过条件转移到下一个阶段的。确定每一次递归（对于DFS）的回溯和深入条件，对于BFS，要注意每一次入队的条件同时注意判重。要牢牢把握目标状态是一个什么状态，在什么时候结束搜索。还有，DFS过程的参数如何设定，是带参数还是不带参数，带的话各个参数一定要保证能完全的表示一个状态，不会出现一个状态对应多个参数，而这一点对于BFS来说就稍简单些，只需要多设置些变量就可以了。</p>
<p><strong>数值类型搜索</strong>：这种类型的搜索就需要仔细分析分析了，一般来说采用DFS，而且它的终止条件一般都是很明显的，难就难在对于过程的把握，过程的把握类似于坐标类型的搜索（判重、深入、枚举），注意这种类型的搜索通常还要用到剪枝优化，对于那些明显不符合要求的特殊状态我们一定要在之前就去掉它，否则它会像滚雪球一样越滚越大，浪费我们的时间 。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>版权声明：此处文段选自CSDN博主「osDetach」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41681241/article/details/81432634 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Win10定制deskthemepack主题包]]></title>
        <id>https://alittlewhiter.github.io/post/win10-ding-zhi-deskthemepack-zhu-ti-bao/</id>
        <link href="https://alittlewhiter.github.io/post/win10-ding-zhi-deskthemepack-zhu-ti-bao/">
        </link>
        <updated>2020-03-11T01:59:13.000Z</updated>
        <summary type="html"><![CDATA[<p>额、其实真没什么。。😅<br>
500怜さいこう！！ /封面</p>
]]></summary>
        <content type="html"><![CDATA[<p>额、其实真没什么。。😅<br>
500怜さいこう！！ /封面</p>
<!-- more -->
<p>偶然来找找怎么制作Win10的主题包deskthemepack文件（Win7上应该是themepack），一些小记录<sub>就懒得放图了</sub><br>
走起✨✨</p>
<ol>
<li>
<p>进入-&gt;设置 - 个性化 - 主题，依次设置自己的主题的“背景、颜色、声音、鼠标光标”。</p>
</li>
<li>
<p>进入-&gt;背景，选择背景为 <code>幻灯片放映</code> ，点击浏览以选中自己需要的壁纸文件夹作为幻灯片相册。可以更改切换频率（10min）、设置是否无序播放、选择契合度为拉伸</p>
</li>
<li>
<p>进入-&gt;颜色，首先选择颜色为深色/浅色/自定义（这里选深色），打开透明效果，主题色可以选择 自动从背景提取，或自定义一种固定颜色，‘在以下区域显示主题色’按需勾选（建议不用）。</p>
</li>
<li>
<p>进入-&gt;声音，这里一般不用修改，但也可以根据自己需要下载其他合适的音效进行配置。</p>
</li>
<li>
<p>进入-&gt;鼠标光标，这里可以更改鼠标方案，win10 1809版本已有一些内置的选项（我选Windows黑色 系统方案），可以勾选启用阴影效果。</p>
</li>
<li>
<p>最后点击保存主题、并为主题命名，这时Windows其实是保存了我们当前所自定义的一些配置，配置文件（filename.theme）位置位于：<code>C:\Users\你的用户名\AppData\Local\Microsoft\Windows\Themes</code> 。</p>
</li>
<li>
<p>如果想将主题保存为 <code>.deskthemepack</code> 文件并用于分享给其他人，可以在该主题上点击右键，即可弹出“保存用于共享的主题”按钮，点击该按钮即可弹出“另存为”对话窗口，输入文件名，选择路径保存即可。<br>
<img src="https://alittlewhiter.github.io/post-images/1583893408283.png" alt="" loading="lazy"></p>
</li>
</ol>
<p>其实只是个壁纸主题包，各种深度定制还是直接建议网上搜索。。。<sub>定制越深似乎都涉及修改注册表等啥的、打扰了😓</sub><br>
如果喜欢动态壁纸当然还是WE大法好！国内也有很多一些诸如火萤、星空、UPUPOO等<br>
不想太麻烦、也可以找一些轻量化的插件进行美化。如 <a href="http://www.startisback.com/">StartIsBack</a> (备梯付费、建议baipiao)和<a href="https://rocketdock.en.softonic.com/">RocketDock</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C/C++ 捡漏(っ °Д °;)っ]]></title>
        <id>https://alittlewhiter.github.io/post/cc-jian-lou-tu-degd-degtu/</id>
        <link href="https://alittlewhiter.github.io/post/cc-jian-lou-tu-degd-degtu/">
        </link>
        <updated>2020-03-06T07:27:40.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Keywords：C/C++、语法扫雷、使用误区</strong><br>
常常雷区蹦迪的我无(hai)所(pa)畏(ji)惧(le)🤣🤣🤣<br>
~ <sub>记得之前写过类似的、哪去了😑😵😵</sub> ~</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Keywords：C/C++、语法扫雷、使用误区</strong><br>
常常雷区蹦迪的我无(hai)所(pa)畏(ji)惧(le)🤣🤣🤣<br>
~ <sub>记得之前写过类似的、哪去了😑😵😵</sub> ~</p>
<!-- more -->
<h2 id="函数fill与memset的区别">函数fill与memset的区别</h2>
<p><strong>memset函数</strong>：memset(arr, int, sizeof(arr));</p>
<ul>
<li>
<p>按照字节填充数字，由于其机制为对指定内存区域逐字节地复制，而与数组<sub>(指针)</sub>arr指向的数据类型无关。建议仅在需要填充全0 <code>(memset(arr, 0, sizeof arr);)</code> 或全1 <code>（memset(a, -1, sizeof a);）</code> 时使用。</p>
</li>
<li>
<p>包含在在C头文件<code>string.h</code> 或 <code>&lt;cstring&gt;</code> 里面，有时包含 <code>&lt;stdlib.h&gt;</code> 也可。</p>
</li>
</ul>
<p><strong>fill函数</strong>：fill(arr, arr + sizeof(arr), dataType);</p>
<ul>
<li>
<p>按照指针arr实际类型逐个单元进行赋值，将一个区间的元素都赋同一个值（可以是字符、整数、布尔、浮点等类型）。</p>
</li>
<li>
<p>包含在C++头文件 <code>&lt;algorithm&gt;</code>里面，</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>因为memset函数按照字节填充，所以一般memset只能用来填充char型数组（只有char型占一个字节），如果填充int型数组，除了0和-1，其他的会导致填充时期望的值与实际读取的值不相同，而fill函数可以赋值任何类型。</li>
<li><strong>注</strong>：C++使用fill初始化二维数组时应该 <code>fill(dis[0], dis[0]+maxn*maxn, INF);</code> ,因为 dis[0]才是dis的首元素 dis[0][0] 的地址。</li>
</ul>
<h2 id="输入字符和字符串">输入字符和字符串</h2>
<ol>
<li>首先C语言有多个函数可以从键盘获得用户输入，分别是：</li>
</ol>
<ul>
<li>scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据，格式化控制，非常强大！</li>
<li>getchar()、getche()、getch()：这三个函数都用于输入单个字符。</li>
<li>gets()：获取一行数据，并作为字符串处理。</li>
</ul>
<ol start="2">
<li>输入单个字符</li>
</ol>
<ul>
<li>
<p><strong>getchar()</strong></p>
<p>函数getchar()包含在 <code>&lt;stdio.h&gt;</code> 头文件中，它几乎是 <code>scanf(&quot;%c&quot;, c)</code> 的替代品，相比之更加简洁，一次从缓冲区读入一个字符。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
    char c = getchar();
    printf(&quot;c = %c\n&quot;, c);
    return 0;
}
</code></pre>
<pre><code class="language-nohighlight">@↙
c = @
</code></pre>
</li>
<li>
<p><strong>getche()</strong></p>
<p>此函数没有缓冲区，输入一个字符后会立即读取并继续执行，而不用等待用户按下回车键，这是它和 scanf()、getchar() 的最大区别。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
int main() {
    char c = getche();
    printf(&quot;c: %c\n&quot;, c);
    return 0;
}
</code></pre>
<pre><code class="language-c">@c = @
</code></pre>
<p>输入<code>@</code>后，getche() 立即读取完毕，接着继续执行 printf() 将字符输出，所以没有按下回车键程序就运行结束了。</p>
<p><strong>注意</strong>：getche() 位于 <code>conio.h</code> 头文件中，而这个头文件是 Windows 特有的，Linux 和 Mac OS 下没有包含该头文件，因此getche() 并不是标准函数，默认只能在 Windows 下使用，不能在 Linux 和 Mac OS 下使用。</p>
</li>
<li>
<p><strong>getch()</strong></p>
<p>getch() 也没有缓冲区，输入一个字符后会立即读取，不用按下回车键。getch() 的特别之处是它没有回显，看不到输入的字符。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
int main() {
    char c = getch();
    printf(&quot;c: %c\n&quot;, c);
    return 0;
}
</code></pre>
<pre><code class="language-c">c = @
</code></pre>
<p><strong>注</strong>：getch() 也位于 conio.h 头文件中，也不是标准函数。</p>
</li>
</ul>
<ol start="3">
<li>输入字符串</li>
</ol>
<ul>
<li>
<p>输入字符串当然可以使用 scanf() 这个通用的输入函数，对应的格式控制符为<code>%s</code> 。</p>
</li>
<li>
<p>也可以使用gets() 函数，它也是有缓冲区的，每次按下回车键代表当前输入结束了，gets() 开始从缓冲区中读取内容。gets() 和 scanf() 的主要区别是：</p>
<ul>
<li>scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。</li>
<li>gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。</li>
</ul>
<pre><code class="language-c">char url[50];
gets(url);
printf(&quot;url: %s\n&quot;, url);
</code></pre>
<pre><code class="language-c">One apple once a day, keeps your enemies away!↙
One apple once a day, keeps your enemies away!
</code></pre>
</li>
</ul>
<h2 id="fgetc和fputc函数用法">fgetc和fputc函数用法</h2>
<ul>
<li>
<p>C语言中，读写文件比较灵活，既可以每次读写一个字符，也可以读写一个字符串，甚至是任意字节的数据（数据块）。</p>
</li>
<li>
<p>以字符形式读写文件时，每次可以从文件中读取一个字符，或者向文件中写入一个字符。主要使用两个函数，分别是 fgetc() 和 fputc()，仅需包含 <code>stdio.h</code> 。</p>
</li>
</ul>
<h3 id="字符读取函数-fgetc">字符读取函数 fgetc</h3>
<ul>
<li>
<p>fgetc 是 file get char 的缩写，意思是从指定的文件中读取一个字符。</p>
</li>
<li>
<p>fgetc() 的用法为：<code>int fgetc (FILE *fp);</code> fp 为文件指针。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回<code>EOF</code>。</p>
</li>
<li>
<p>EOF 是 end of file 的缩写，表示文件末尾，是在 stdio.h 中定义的宏，它的值是一个负数，往往是 -1。fgetc() 的返回值类型之所以为 int，就是为了容纳这个负数（char不能是负数）。</p>
<ul>
<li>EOF 不绝对是 -1，也可以是其他负数，这要看编译器的实现。</li>
</ul>
<pre><code class="language-c">char ch;
FILE *fp = fopen(&quot;F:\\demo.txt&quot;, &quot;r+&quot;);
ch = fgetc(fp);
</code></pre>
</li>
<li>
<p>在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用 fgetc() 函数后，该指针会向后移动一个字节，所以可以连续多次使用 fgetc() 读取多个字符。</p>
</li>
<li>
<p>注意：这个文件内部的位置指针与C语言中的指针不是一回事。位置指针仅仅是一个标志，表示文件读写到的位置，也就是读写到第几个字节，它不表示地址。文件每读写一次，位置指针就会移动一次，它不需要你在程序中定义和赋值，而是由系统自动设置，对用户是隐藏的。</p>
<pre><code class="language-c">FILE *fp;
char ch;
if( (fp=fopen(&quot;F:\\demo.txt&quot;,&quot;rt&quot;)) == NULL ){
    puts(&quot;Fail to open file!&quot;);
    exit(0);
}
while( (ch=fgetc(fp)) != EOF ){
    putchar(ch);
}
putchar('\n');
fclose(fp);		// 注意文件需要关闭
</code></pre>
<ul>
<li>
<p>EOF 本来表示文件末尾，意味着读取结束，但是很多函数在读取出错时也返回 EOF，那么当返回 EOF 时，可以借助 stdio.h 中的两个函数来判断是 <code>读取结束</code> 还是 <code>读取错误</code> ，分别是 <code>feof()</code> 和 <code>ferror()</code> 。</p>
</li>
<li>
<p>feof() 函数用来判断文件内部指针是否指向了文件末尾，原型是<code>int feof ( FILE * fp );</code> 当指向文件末尾时返回非零值，否则返回零值。</p>
</li>
<li>
<p>ferror() 函数用来判断文件操作是否出错，原型是 <code>int ferror ( FILE *fp );</code> ，出错时返回非零值，否则返回零值。</p>
</li>
</ul>
</li>
</ul>
<h3 id="字符写入函数-fputc">字符写入函数 fputc</h3>
<ul>
<li>fputc 是 file output char 的所以，意思是向指定的文件中写入一个字符。fputc() 的用法为：<code>int fputc ( int ch, FILE *fp );</code> ch 为要写入的字符，fp 为文件指针。fputc() 写入成功时返回写入的字符，失败时返回 EOF，返回值类型为 int 也是为了容纳这个负数。</li>
<li>被写入的文件可以用写、读写、追加方式打开，用写或读写方式打开一个已存在的文件时将清除原有的文件内容，并将写入的字符放在文件开头。如需保留原有文件内容，并把写入的字符放在文件末尾，就必须以追加方式打开文件。不管以何种方式打开，被写入的文件若不存在时则创建该文件。</li>
<li>每写入一个字符，文件内部位置指针向后移动一个字节。</li>
</ul>
<h2 id="fgets和fputs函数">fgets和fputs函数</h2>
<p>每次读写一个字符串或者一个数据块，这样能明显提高效率。</p>
<h3 id="读字符串函数-fgets">读字符串函数 fgets</h3>
<ul>
<li>fgets() 函数用来从指定的文件中读取一个字符串，并保存到字符数组中，用法为： <code>char *fgets ( char *str, int n, FILE *fp );</code> str 为字符数组，n 为要读取的字符数目，fp 为文件指针。</li>
<li><strong>返回值</strong>：读取成功时返回字符数组首地址，也即 str；读取失败时返回 NULL；如果开始读取时文件内部指针已经指向了文件末尾，那么将读取不到任何字符，也返回 NULL。</li>
<li><strong>注</strong>1：读取到的字符串会在末尾自动添加 '\0'，n 个字符也包括 '\0'。也就是说，实际只读取到了 n-1 个字符，如果希望读取 100 个字符，n 的值应该为 101。</li>
<li><strong>注2</strong>：在读取到 n-1 个字符之前如果出现了换行，或者读到了文件末尾，则读取结束。不管 n 的值多大，fgets() 最多只能读取一行数据，不能跨行。 <code>C中没有按行读取文件的函数，可以借助 fgets()将 n 的值设置地足够大，每次就可以读取到一行数据。</code></li>
</ul>
<h3 id="写字符串函数-fputs">写字符串函数 fputs</h3>
<ul>
<li>fputs() 函数用来向指定的文件写入一个字符串，用法为： <code>int fputs( char *str, FILE *fp );</code> str 为要写入的字符串，fp 为文件指针。写入成功返回非负数，失败返回 EOF。</li>
</ul>
<h2 id="fscanf-和-fprintf函数">fscanf 和 fprintf函数</h2>
<ul>
<li>
<p>fscanf() 和 fprintf() 函数与前面使用的 scanf() 和 printf() 功能相似，都是格式化读写函数，两者的区别在于 fscanf() 和 fprintf() 的读写对象不是键盘和显示器，而是磁盘文件。</p>
<p>两个函数的原型如下，与 scanf() 和 printf() 相比，仅仅多了一个 fp 参数。</p>
<pre><code class="language-c">int fscanf ( FILE *fp, char * format, ... );
int fprintf ( FILE *fp, char * format, ... );
</code></pre>
</li>
<li>
<p><code>fp 为文件指针，format 为格式控制字符串，... 表示参数列表。</code> 如果将 fp 设置为 stdin，那么 fscanf() 函数将会从键盘读取数据，与 scanf 作用相同；设置为 stdout，那么 fprintf() 函数将会向显示器输出内容，与 printf 作用相同。</p>
</li>
<li>
<p>fprintf() 返回成功写入的字符的个数，失败则返回负数；fscanf() 返回参数列表中被成功赋值的参数个数。</p>
</li>
</ul>
<h2 id="整数与字符串的相互转换">整数与字符串的相互转换</h2>
<ol>
<li>整数转字符串
<ul>
<li>扩展函数 <code>itoa()</code><br>
itoa ( integer to alphanumeric)是把整型数转换成字符串的一个函数。Windows环境下包含在 <code>&lt;stdlib.h&gt;</code> 头文件中，函数原型：<pre><code class="language-c">char* itoa(int value, char*string, int radix);
// value: 要转换的整数，string: 转换后的字符串,radix: 转换进制数，如2,8,10,16 进制等。
</code></pre>
</li>
<li><code>sprintf()</code>函数</li>
</ul>
<ol>
<li>sprintf函数原型为 <code>int sprintf(char *str, const char *format, ...)</code> 。作用是格式化字符串，具体功能：将数字变量转换为字符串、得到整型变量的16进制和8进制字符串、连接多个字符串。</li>
<li>snprintf函数是sprintf函数的更加安全版本，考虑到字符串的字节数，防止了字符串溢出。函数形式为：<code>int snprintf(char *restrict buf, size_t n, const char * restrict format, ...);</code> 。最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n 的话，将不会溢出。</li>
</ol>
</li>
<li>字符串转整数
<ul>
<li>扩展函数 <code>atoi()</code><br>
atoi (表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。Windows环境下包含在 <code>&lt;stdlib.h&gt;</code> 头文件中，函数原型：<pre><code class="language-c">int  atoi(const char *nptr);           // 字符串转整数函数，nptr: 要转换的字符串
</code></pre>
</li>
<li><code>sscanf()</code> 函数<br>
sscanf函数原型为 <code>int sscanf(const char *str, const char *format, ...)</code> 。将参数str的字符串根据参数format字符串来转换并格式化数据，转换后的结果存于对应的参数内。具体功能如下：
<ol>
<li>根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。</li>
<li>取指定长度的字符串</li>
<li>取到指定字符为止的字符串</li>
<li>取仅包含指定字符集的字符串</li>
<li>取到指定字符集为止的字符串</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="stl中的-iterator-和-const_iterator">STL中的 iterator 和 const_iterator</h2>
<ul>
<li>
<p>在C++中使用STL的容器时，经常会用到迭代器，使用迭代器可以很方便的进行容器元素遍历和修改等操作。</p>
</li>
<li>
<p>STL容器中<strong>set</strong>的迭代器是<code>const_iterator</code>类型，而<strong>vector等</strong>的迭代器则是普通的<code>iterator</code>类型。在声明一个集合或者一个哈希表的迭代器时，虽然我们声明的是普通的iterator，但是其实它们都是const_iterator，即一个无法对元素进行修改操作的const引用（set取到的iterator则是const的，而map取到的iterator的key则是const的）。因此，如果使用该迭代器对容器中元素进行修改操作则会编译不通过，对于map的迭代器同理。</p>
</li>
<li>
<p>为什么不允许对元素进行修改？</p>
<ol>
<li>因为set和map这种类型的容器，需要根据key来保持有序或者是确保元素的唯一性，所以不允许用户直接对元素进行修改。如果允许用户在使用iterator时直接对元素进行修改间接的修改了元素的键值，很有可能导致非唯一性或无序。</li>
<li>由于这种类型的容器需要保持元素的有序性，底层可能用了某种数据结构来保存（如：堆），如果频繁的修改元素，则内部可能需要多次进行排序，导致效率低下。</li>
</ol>
</li>
<li>
<p>怎么对元素进行修改？</p>
<ol>
<li>使用容器的erase()和insert()方法。如果想修改某个元素，那么直接删掉它，再将修改过的元素插入到原有的容器中。这种方法的缺点是效率太低。</li>
<li>使用const_cast。const_cast可以去掉任何底层const修饰，使得一个const变量成为非const的。如： <code>int &amp;item1 = const_cast&lt;int&amp;&gt; (*iter);</code></li>
</ol>
</li>
</ul>
<h2 id="next">Next</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Valine - 你值得拥有┏ (゜ω゜)=☞]]></title>
        <id>https://alittlewhiter.github.io/post/valine-ni-zhi-de-yong-you-o/</id>
        <link href="https://alittlewhiter.github.io/post/valine-ni-zhi-de-yong-you-o/">
        </link>
        <updated>2020-03-04T04:08:08.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Keywords：Gridea、Valine、无后端、评论系统</strong><br>
简直不要再好、、还是希望更好(╹ڡ╹ )</p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Keywords：Gridea、Valine、无后端、评论系统</strong><br>
简直不要再好、、还是希望更好(╹ڡ╹ )</p>
<!-- more -->
<h2 id="first">First</h2>
<p>虽然破站也不会有人来看，但还是想为Gridea加上一个评论系统，说——不定呢嘿嘿(￣▽,￣)╭ （想peach</p>
<p>Gridea提供了两个评论系统，Gitalk和disqus。Gitalk需要使用Github账号登录，对于没有github账号的人来说不太方便，disqus目前在国内不太可用。于是<strong>valine</strong> 非你莫属！😜😜</p>
<h2 id="介绍">介绍</h2>
<p>Valine是一款快速、简洁且高效的<strong>无后端</strong>评论系统：</p>
<ul>
<li>高速，使用国内后端云服务提供商 <code>LeanCloud</code> 提供的存储服务</li>
<li>开源、自定义程度高</li>
<li>支持邮件通知、支持验证码 (不建议)</li>
<li>原版即支持表情包、Markdown等特性。<br>
官网地址：<code>https://valine.js.org/</code></li>
</ul>
<h3 id="注册leancloud">注册leancloud</h3>
<p>其次，为了成功配置Valine需要leancloud平台，注册-登录-控制台-创建应用（一条龙.jpg<br>
<img src="https://alittlewhiter.github.io/post-images/1583296181154.png" alt="" loading="lazy"><br>
进入刚刚创建的应用(开发版)，选择左下角的<code>设置</code> &gt; <code>应用Keys</code>，可以获取应用的APP ID和APP Key（注意保密）。进入安全中心，Web安全域名下填写自己的Github Pages（Coding Pages）提供的博客站点域名，点击保存。<br>
<img src="https://alittlewhiter.github.io/post-images/1583296272560.png" alt="" loading="lazy"><br>
点击<code>存储</code>新建一个Class，名称为Comment，添加如下。<br>
<img src="https://alittlewhiter.github.io/post-images/1583296175616.png" alt="" loading="lazy"></p>
<h3 id="修改主题模板">修改主题模板</h3>
<p>在Gridea theme模板templates/_block的head.ejs中引入</p>
<pre><code class="language-html">&lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt;
</code></pre>
<p>在post.ejs (文章详情页) 模板中文章末尾的位置添加下面的代码：</p>
<pre><code class="language-html">&lt;div class=&quot;comments&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        new Valine({
            el: '.comments',
            appId: '&lt;API_ID&gt;',
            appKey: '&lt;API_Key&gt;'
        })
    &lt;/script&gt;
</code></pre>
<blockquote>
<p>相关配置属性含义看<a href="https://valine.js.org/configuration.html">这里</a></p>
</blockquote>
<ul>
<li>接下来仅需修改appId和appKey即可，打开文章详情页，显示评论框就成功了。<br>
<img src="https://alittlewhiter.github.io/post-images/1583301574844.png" alt="" loading="lazy"></li>
</ul>
<h3 id="upgrade-edition">Upgrade Edition：</h3>
<ul>
<li>
<p>主题模板post.ejs文件中需要添加新的<a href="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn/scripts/Valine.min.js">Valine.min.js</a>文件，鉴于我下载该<a href="https://kveln.cn/media/scripts/Valine.min.js">js文件</a>保存到本地/media/scripts后，无论如何设置相对路径都无法同步到GitHub<s>博客</s>，所以只能采用网络上其他站点的资源url：<a href="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn/scripts/Valine.min.js">https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn/scripts/Valine.min.js</a>、<a href="https://kveln.cn/media/scripts/Valine.min.js">https://kveln.cn/media/scripts/Valine.min.js</a></p>
<pre><code class="language-html">  &lt;!--载入js，在&lt;/body&gt;之前插入即可--&gt;
  &lt;!--Leancloud 操作库:--&gt;
  &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;
  &lt;!--Valine 的核心代码库  不知道为啥该.js放本地用不了，第二、第三个目前均可用--&gt;
  &lt;!-- &lt;script src=&quot;/media/scripts/Valine.min.js&quot;&gt;&lt;/script&gt;   --&gt;
  &lt;!-- &lt;script src=&quot;https://kveln.cn/media/scripts/Valine.min.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;script src=&quot;//cdn.jsdelivr.net/gh/Alanrk/clean-cdn/scripts/Valine.min.js&quot;&gt;&lt;/script&gt;
  
  &lt;!-- 评论模块 --&gt;
  	&lt;div class=&quot;comment&quot;&gt; &lt;/div&gt;

  &lt;script&gt;
      new Valine({
        av: AV,                            // AV 对象来自上面引入av-min.js
        el: '.comment',               // 选择标签容器
        lang: 'zh-cn',                  // 设置语言
        avatar: 'mm',                 // 设置头像
        emoticon_url: 'https://cloud.panjunwen.com/alu',
        emoticon_list: [&quot;吐.png&quot;,&quot;喷血.png&quot;,&quot;狂汗.png&quot;,&quot;不说话.png&quot;,&quot;汗.png&quot;,&quot;坐等.png&quot;,
          &quot;献花.png&quot;,&quot;不高兴.png&quot;,&quot;中刀.png&quot;,&quot;害羞.png&quot;,&quot;皱眉.png&quot;,&quot;小眼睛.png&quot;,
          &quot;中指.png&quot;,&quot;尴尬.png&quot;,&quot;瞅你.png&quot;,&quot;想一想.png&quot;,&quot;中枪.png&quot;,&quot;得意.png&quot;,&quot;肿包.png&quot;,
          &quot;扇耳光.png&quot;,&quot;亲亲.png&quot;,&quot;惊喜.png&quot;,&quot;脸红.png&quot;,&quot;无所谓.png&quot;,&quot;便便.png&quot;,&quot;愤怒.png&quot;,
          &quot;蜡烛.png&quot;,&quot;献黄瓜.png&quot;,&quot;内伤.png&quot;,&quot;投降.png&quot;,&quot;观察.png&quot;,&quot;看不见.png&quot;,&quot;击掌.png&quot;,
          &quot;抠鼻.png&quot;,&quot;邪恶.png&quot;,&quot;看热闹.png&quot;,&quot;口水.png&quot;,&quot;抽烟.png&quot;,&quot;锁眉.png&quot;,&quot;装大款.png&quot;,
          &quot;吐舌.png&quot;,&quot;无奈.png&quot;,&quot;长草.png&quot;,&quot;赞一个.png&quot;,&quot;呲牙.png&quot;,&quot;无语.png&quot;,&quot;阴暗.png&quot;,
          &quot;不出所料.png&quot;,&quot;咽气.png&quot;,&quot;期待.png&quot;,&quot;高兴.png&quot;,&quot;吐血倒地.png&quot;,&quot;哭泣.png&quot;,&quot;欢呼.png&quot;,
          &quot;黑线.png&quot;,&quot;喜极而泣.png&quot;,&quot;喷水.png&quot;,&quot;深思.png&quot;,&quot;鼓掌.png&quot;,&quot;暗地观察.png&quot;],
        app_id: 'nD4DEajJJj9QlUpYtF8YFa1v-9Nh9j0Va',
        app_key: 'PpbNRCLEJPuymBxdJfNzU6Bb',
        placeholder: '我有话说...'
    });
  &lt;/script&gt;
</code></pre>
<ul>
<li>需要修改的只有：<code>el</code>、<code>app_id</code> 和 <code>app_key</code>。如果之前有用原版Valine，请将邮件通知和验证码关掉：<code>notify: false</code>, <code>verify: false</code>，避免重复收到扰人通知，还有算术验证码确实反人类，强烈建议停用。将上面的app_id和和app_key替换成leancloud中对应的<code>ID</code>和<code>Key</code>即可，修改完成后点击保存，再把Gridea客户端中的<code>远程</code>-&gt;<code>评论配置</code>-&gt;<code>是否显示评论</code>关掉，同步即可。</li>
</ul>
<pre><code class="language-html">若未引入jQuery，则引入：
&lt;script src=&quot;https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://alittlewhiter.github.io/post-images/1583305338443.png" alt="" loading="lazy"></figure>
<ul>
<li>进阶：可以考虑使用<code>Valine Admin</code>管理评论:
<ul>
<li>Valine Admin主要实现评论邮件通知、评论管理、垃圾评论过滤等功能。支持完全自定义的邮件通知模板。</li>
<li>教程：<a href="https://github.com/DesertsP/Valine-Admin">Valine Admin</a>：<a href="https://github.com/DesertsP/Valine-Admin">https://github.com/DesertsP/Valine-Admin</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>更多详见:</p>
<ul>
<li><a href="https://deserts.io/diy-a-comment-system/">https://deserts.io/diy-a-comment-system/</a></li>
<li><a href="https://valine.js.org/">https://valine.js.org/</a></li>
</ul>
</li>
</ul>
<p>Good Bye 😄!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于CDN这回事儿]]></title>
        <id>https://alittlewhiter.github.io/post/guan-yu-cdn-zhe-hui-shi-er/</id>
        <link href="https://alittlewhiter.github.io/post/guan-yu-cdn-zhe-hui-shi-er/">
        </link>
        <updated>2020-03-03T08:54:37.000Z</updated>
        <summary type="html"><![CDATA[<p>也就那回事儿~</p>
]]></summary>
        <content type="html"><![CDATA[<p>也就那回事儿~</p>
<!-- more -->
<h3 id="介绍">介绍</h3>
<p>CDN，Content Distribute Network，可以直译成内容分发网络，CDN解决的是如何将数据快速可靠从源站传递到用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。</p>
<h3 id="为什么不进行数据的直接交付即让用户直接从源站获取数据呢">为什么不进行数据的直接交付，即让用户直接从源站获取数据呢？<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h3>
<pre><code>我们常说的互联网实际上由两层组成，一层是以TCP/IP为核心的网络层即Internet (因特网)，另一层  
则是以万维网WWW为代表的应用层。数据从服务器端交付到用户端，至少有4个地方可能会造成网络拥堵。  
</code></pre>
<ol>
<li>“第一公里”，这是指万维网流量向用户传送的第一个出口，是网站服务器接入互联网的链路。这个出口带宽决定了一个网站能为用户提供的访问速度和并发访问量。当用户请求量超出网站的出口带宽，就会在出口处造成拥塞。</li>
<li>“最后一公里”，万维网流量向用户传送的最后一段链路，即用户接入互联网的链路。用户接入的带宽影响用户接收流量的能力。随着电信运营商的大力发展，用户的接入带宽得到了很大改善，“最后一公里”问题基本得到解决。</li>
<li>ISP互联，即因特网服务提供商之间的互联，比如中国电信和中国联通两个网络运营商之间的互联互通。当某个网站服务器部署在运营商A的机房，运营商B的用户要访问该网站，那就必须经过A、B之间的互联互通点进行跨网访问。从互联网的架构来看，不同运营商之间的互联互通带宽，对任何一个运营商网络流量来说，占比都非常小。因此，这里也通常是网络传输的拥堵点。</li>
<li>长途骨干传输。首先是长距离传输时延问题，其次是骨干网络的拥塞问题，这些问题都会造成万维网流量传输的拥堵。</li>
</ol>
<h3 id="结论">结论：</h3>
<ul>
<li>从以上对于网络拥堵的情况分析，如果网络上的数据都使用从源站直接交付到用户的方法，那么将极有可能会出现访问拥塞的情况。</li>
<li>如果能有一种技术方案，将数据缓存在离用户最近的地方，使用户以最快的速度获取，那这对于减少网站的出口带宽压力，减少网络传输的拥堵情况，将起到很大的作用。CDN正是这样一种技术方案。</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>转载如下：<br>
————————————————<br>
版权声明：本文为CSDN博主「haozlee」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/lihao21/article/details/52808747 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[来了来了、Markdown入坟系列]]></title>
        <id>https://alittlewhiter.github.io/post/lai-liao-lai-liao-markdown-ru-fen-xi-lie/</id>
        <link href="https://alittlewhiter.github.io/post/lai-liao-lai-liao-markdown-ru-fen-xi-lie/">
        </link>
        <updated>2020-03-03T04:09:36.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Keywords：markdown，md语法，笔记</strong><br>
<mark>Typora大法好！</mark><br>
<mark>Typora大法好！!</mark><br>
<mark>Typora大法好！！！</mark></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Keywords：markdown，md语法，笔记</strong><br>
<mark>Typora大法好！</mark><br>
<mark>Typora大法好！!</mark><br>
<mark>Typora大法好！！！</mark></p>
<!-- more -->
<h2 id="markdown基本撰写和格式语法">Markdown基本撰写和格式语法</h2>
<h3 id="标题">标题</h3>
<ul>
<li>要创建标题，请在标题文本前添加一至六个 <code>#</code> 符号，使用的 <code>#</code> 数量（1 - 6）将决定标题的大小。</li>
</ul>
<pre><code class="language-git">#    一级标题
##   二级标题
###  三级标题
#### 四级标题
#### 五级标题
######   六级标题
</code></pre>
<p><strong>补充</strong></p>
<ul>
<li>对标题进行封闭处理(类似于html中的自闭合标签加个/标注),那么你可以对应的在标题后面加上 相应数量的&quot;#&quot;。</li>
<li>一级标题和二级标题还支持另外的使用方式，就是在一级标题下面加<code>=</code>，二级标题下面加<code>-</code>（最少加一个）：</li>
</ul>
<pre><code class="language-html">  一级标题
  ===
  二级标题
  ---
</code></pre>
<p><strong>分隔线</strong><br>
连续的三个以上的*或-或_, 你也可以在连字符或星号之间使用空格。</p>
<pre><code class="language-HTML">---
***
___
- - -
</code></pre>
<h3 id="样式文本">样式文本</h3>
<ul>
<li>可以使用粗体、斜体或删除线文本来表示强调，粗体和斜体能够互相嵌套</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">样式</th>
<th style="text-align:left">语法</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">粗体</td>
<td style="text-align:left"><code>** **</code> 或 <code>__ __</code> 包围（无需多余空格）</td>
<td style="text-align:left"><strong>粗体字</strong></td>
</tr>
<tr>
<td style="text-align:left">斜体</td>
<td style="text-align:left"><code>* *</code> 或 <code>_ _</code> 包围</td>
<td style="text-align:left"><em>斜体字</em></td>
</tr>
<tr>
<td style="text-align:left">上标</td>
<td style="text-align:left"><code>^ ^</code> 包围</td>
<td style="text-align:left">5a<sup>3</sup>b<sup>2</sup>c</td>
</tr>
<tr>
<td style="text-align:left">下标</td>
<td style="text-align:left"><code>~ ~</code> 包围</td>
<td style="text-align:left">C<sub>60</sub> 是足球烯</td>
</tr>
<tr>
<td style="text-align:left">删除线</td>
<td style="text-align:left"><code>~~ ~~</code> 包围</td>
<td style="text-align:left"><s>删除线</s></td>
</tr>
<tr>
<td style="text-align:left">粗体+斜体</td>
<td style="text-align:left"><code>*** ***</code> 包围</td>
<td style="text-align:left"><em><strong>粗体又斜体</strong></em></td>
</tr>
<tr>
<td style="text-align:left">强调</td>
<td style="text-align:left"><code>== ==</code> 包围</td>
<td style="text-align:left"><mark>重要的事情说三遍</mark></td>
</tr>
</tbody>
</table>
<h3 id="引用文本">引用文本</h3>
<p>可以使用 <code>&gt;</code> 来引用一段文本，引用可以多层嵌套</p>
<blockquote>
<p>鲁迅：“这是一段引用文本”（我没说.jpg）</p>
<blockquote>
<p>禁止套娃！</p>
<blockquote>
<p>禁止禁止套娃！！</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<h3 id="代码">代码</h3>
<ul>
<li>
<p>使用单反引号<code>` `</code>或双反引号<code>`` ``</code>可标注句子中的代码或命令，反引号中的文本不会被Markdown解释器格式化，一般在文本段落中还能起<code>突出强调</code>的作用。</p>
</li>
<li>
<p>要将代码或文本格式化为各自的不同块，按照不同类型的代码风格进行高亮显示，使用三反引号<code>```[C/Java/html/..] ```</code> 独立分行。</p>
<pre><code class="language-git">一些基本的git命令：
git status
git add ./
git commit
</code></pre>
<p><code>code支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir</code></p>
</li>
<li>
<p>如果不需要代码高亮，可以用下面的方法禁用：</p>
<p><code>```nohighlight</code><br>
<code>```</code></p>
</li>
</ul>
<h3 id="链接">链接</h3>
<ul>
<li>
<p>通过将链接文本包含在方括号 <code>[ ]</code> 内，然后将 URL 包含在括号 <code>( )</code> 内，可创建内联链接。 还可以使用键盘快捷键 <code>命令键 + k</code> 来创建链接。</p>
<pre><code class="language-html">本站点是使用 [GitHub Pages](https://pages.github.com/) 构建的。
</code></pre>
<p>本站点是使用 <a href="https://pages.github.com/">GitHub Pages</a> 构建的。</p>
</li>
</ul>
<h3 id="脚注">脚注</h3>
<ul>
<li>向文章添加脚注，以上标的形式展示，脚注内容会显示在文章结尾处。<pre><code class="language-nohighlight">大佬写文章总是喜欢做这样[^fn1]或那样[^fn2]的脚注。
</code></pre>
</li>
<li>大佬写文章总是喜欢做这样<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>或那样<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>的脚注。</li>
</ul>
<h3 id="列表">列表</h3>
<ul>
<li>
<p>无序列表：通过在一行或多行文本前面添加 <code>+</code>、 <code>-</code> 或 <code>*</code> 后跟一个空格，可创建无序列表。</p>
<pre><code>+ George Washington
+ John Adams
+ Thomas Jefferson
</code></pre>
</li>
<li>
<p>有序列表：在列表前面加上数字/字母 作为编号，每个编号使用一个点+空格</p>
<pre><code>1. James Madison
2. James Monroe
3. John Quincy Adams
</code></pre>
</li>
</ul>
<ul>
<li>
<p>列表（有序 or 无序）还能嵌套：通过在一个列表项下面缩进一个或多个其他列表项，可创建嵌套列表。</p>
<p>要通过编辑器或使用等宽字体创建嵌套列表，可以直观地对齐列表。 在嵌套列表项的前面键入空格字符，直至列表标记字符（<code>-</code> 或 <code>*</code>）位于其上方条目中第一个文本字符的正下方。</p>
<pre><code>1. First list item
   - First nested list item
     + Second nested list item
</code></pre>
<ol>
<li>First list item
<ul>
<li>First nested list item
<ul>
<li>Second nested list item</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="任务列表">任务列表</h3>
<ul>
<li>
<p>创建任务列表，在列表项目前面、列表标号[-+*]后面加一个常规 <code>空格</code> 字符，后接 <code>[ ]</code> 。若要将任务标记为已完成，使用 <code>[x]</code> 即可。演示如下：</p>
<pre><code class="language-html">- [x] 完成更改
- [ ] 推送提交到 GitHub
- [ ] (Optional) 打开拉取请求
</code></pre>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8415240"><label class="task-list-item-label" for="task-item-8415240"> 完成更改</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-8382915"><label class="task-list-item-label" for="task-item-8382915"> 推送提交到 GitHub</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6529264"><label class="task-list-item-label" for="task-item-6529264"> (Optional) 打开拉取请求</label></li>
</ul>
<p><strong>注</strong>：如果任务列表项描述以括号开头，则需要加空格分隔或使用\对其进行转义。</p>
</li>
</ul>
<h3 id="使用表情符号">使用表情符号</h3>
<ul>
<li>
<p>通过键入 <code>:EMOJICODE:</code> 可在您的写作中添加表情符号。</p>
<pre><code class="language-html">@octocat :+1: 这个 PR 看起来很棒 - 可以合并了！ :ship:
</code></pre>
<p>@octocat 👍 这个 PR 看起来很棒 - 可以合并了！ 🚢</p>
</li>
</ul>
<ul>
<li>键入 <code>:</code> 将显示建议的表情符号列表，该列表将在键入时进行过滤，因此一旦找到所需的表情符号，可按Tab或Enter键以完成突出显示的结果。</li>
</ul>
<h3 id="段落">段落</h3>
<ul>
<li>通过在文本行之间留一个空白行，可创建新段落。</li>
</ul>
<h3 id="公式">公式</h3>
<ul>
<li>
<p>使用Latex语法将公式写在 <code>$$ $$</code> 内部，将会自动生成相应的公式。e.g.</p>
<pre><code>$$
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
$$
</code></pre>
</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">V</mi><mn>1</mn></msub><mo>×</mo><msub><mi mathvariant="bold">V</mi><mn>2</mn></msub><mo>=</mo><mrow><mo fence="true">∣</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="bold">i</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="bold">j</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="bold">k</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>X</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>u</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>Y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>u</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>X</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>v</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>Y</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>v</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">V</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">V</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.6802159999999997em;vertical-align:-1.590108em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.08597em;"><span style="top:-1.05597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.6619700000000002em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26797em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87397em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-4.08597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500299999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.090108em;"><span style="top:-4.250108em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">i</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight">u</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.769892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.590108em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.090108em;"><span style="top:-4.250108em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">j</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight">u</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-1.769892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">Y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.590108em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.090108em;"><span style="top:-4.250108em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">k</span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.769892em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.590108em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.08597em;"><span style="top:-1.05597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.6619700000000002em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26797em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87397em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-4.08597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500299999999998em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="忽略markdown格式">忽略Markdown格式</h3>
<ul>
<li>
<p>通过在Markdown字符前使用 <code>\</code> 来忽略（或转义）Markdown格式。e.g.</p>
<pre><code class="language-html">让我们将 \*our-new-project\* 重命名为 \*our-old-project\*。
</code></pre>
<p>将 *our-new-project*  重命名为 *our-old-project* 。</p>
</li>
</ul>
<p>Next...</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>我也不懂。。。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>怕了怕了！！！ <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
</feed>