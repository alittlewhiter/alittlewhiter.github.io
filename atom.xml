<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alittlewhiter.github.io</id>
    <title>君の知らない物语</title>
    <updated>2020-03-03T17:33:33.296Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alittlewhiter.github.io"/>
    <link rel="self" href="https://alittlewhiter.github.io/atom.xml"/>
    <subtitle>Took the sourest lemon that life has to offer and turned it into something resembling lemonade.</subtitle>
    <logo>https://alittlewhiter.github.io/images/avatar.png</logo>
    <icon>https://alittlewhiter.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 君の知らない物语</rights>
    <entry>
        <title type="html"><![CDATA[关于CDN这回事儿]]></title>
        <id>https://alittlewhiter.github.io/post/guan-yu-cdn-zhe-hui-shi-er/</id>
        <link href="https://alittlewhiter.github.io/post/guan-yu-cdn-zhe-hui-shi-er/">
        </link>
        <updated>2020-03-03T08:54:37.000Z</updated>
        <summary type="html"><![CDATA[<p>也就那回事儿~</p>
]]></summary>
        <content type="html"><![CDATA[<p>也就那回事儿~</p>
<!-- more -->
<h3 id="介绍">介绍</h3>
<p>CDN，Content Distribute Network，可以直译成内容分发网络，CDN解决的是如何将数据快速可靠从源站传递到用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。</p>
<h3 id="为什么不进行数据的直接交付即让用户直接从源站获取数据呢">为什么不进行数据的直接交付，即让用户直接从源站获取数据呢？</h3>
<p>我们常说的互联网实际上由两层组成，一层是以TCP/IP为核心的网络层即Internet（因特网），另一层则是以万维网WWW为代表的应用层。数据从服务器端交付到用户端，至少有4个地方可能会造成网络拥堵。</p>
<ol>
<li>“第一公里”，这是指万维网流量向用户传送的第一个出口，是网站服务器接入互联网的链路。这个出口带宽决定了一个网站能为用户提供的访问速度和并发访问量。当用户请求量超出网站的出口带宽，就会在出口处造成拥塞。</li>
<li>“最后一公里”，万维网流量向用户传送的最后一段链路，即用户接入互联网的链路。用户接入的带宽影响用户接收流量的能力。随着电信运营商的大力发展，用户的接入带宽得到了很大改善，“最后一公里”问题基本得到解决。</li>
<li>ISP互联，即因特网服务提供商之间的互联，比如中国电信和中国联通两个网络运营商之间的互联互通。当某个网站服务器部署在运营商A的机房，运营商B的用户要访问该网站，那就必须经过A、B之间的互联互通点进行跨网访问。从互联网的架构来看，不同运营商之间的互联互通带宽，对任何一个运营商网络流量来说，占比都非常小。因此，这里也通常是网络传输的拥堵点。</li>
<li>长途骨干传输。首先是长距离传输时延问题，其次是骨干网络的拥塞问题，这些问题都会造成万维网流量传输的拥堵。<br>
从以上对于网络拥堵的情况分析，如果网络上的数据都使用从源站直接交付到用户的方法，那么将极有可能会出现访问拥塞的情况。<br>
如果能有一种技术方案，将数据缓存在离用户最近的地方，使用户以最快的速度获取，那这对于减少网站的出口带宽压力，减少网络传输的拥堵情况，将起到很大的作用。CDN正是这样一种技术方案。</li>
</ol>
<p>转载如下：<br>
————————————————<br>
版权声明：本文为CSDN博主「haozlee」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/lihao21/article/details/52808747</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[来了来了、Markdown入坟系列]]></title>
        <id>https://alittlewhiter.github.io/post/lai-liao-lai-liao-markdown-ru-fen-xi-lie/</id>
        <link href="https://alittlewhiter.github.io/post/lai-liao-lai-liao-markdown-ru-fen-xi-lie/">
        </link>
        <updated>2020-03-03T04:09:36.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Keywords：markdown，md语法，笔记</strong><br>
<mark>Typora大法好！</mark><br>
<mark>Typora大法好！!</mark><br>
<mark>Typora大法好！！！</mark></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Keywords：markdown，md语法，笔记</strong><br>
<mark>Typora大法好！</mark><br>
<mark>Typora大法好！!</mark><br>
<mark>Typora大法好！！！</mark></p>
<!-- more -->
<h2 id="markdown基本撰写和格式语法">Markdown基本撰写和格式语法</h2>
<ol>
<li>标题<br>
要创建标题，请在标题文本前添加一至六个 <code>#</code> 符号，使用的 <code>#</code> 数量（1 - 6）将决定标题的大小。</li>
</ol>
<pre><code class="language-git">#    一级标题
##   二级标题
###  三级标题
#### 四级标题
#### 五级标题
######   六级标题
</code></pre>
<p><strong>补充</strong></p>
<ul>
<li>对标题进行封闭处理(类似于html中的自闭合标签加个/标注),那么你可以对应的在标题后面加上 相应数量的&quot;#&quot;。</li>
<li>一级标题和二级标题还支持另外的使用方式，就是在一级标题下面加<code>=</code>，二级标题下面加<code>-</code>（最少加一个）：</li>
</ul>
<pre><code class="language-html">  一级标题
  ===
  二级标题
  ---
</code></pre>
<p><strong>分隔线</strong><br>
连续的三个以上的*或-或_, 你也可以在连字符或星号之间使用空格。</p>
<pre><code class="language-php+HTML">---
***
___
- - -
</code></pre>
<ol start="2">
<li>样式文本<br>
可以使用粗体、斜体或删除线文本来表示强调。粗体和斜体能够嵌套，</li>
</ol>
<table>
<thead>
<tr>
<th>样式</th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>粗体</td>
<td><code>** **</code> 或 <code>__ __</code>包围起来（无需多余空格）</td>
</tr>
<tr>
<td>斜体</td>
<td><code>* *</code> 或 <code>_ _</code>包围</td>
</tr>
<tr>
<td>删除线</td>
<td><code>~~ ~~</code>包围</td>
</tr>
<tr>
<td>全部粗体+斜体</td>
<td><code>*** ***</code>包围</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>引用文本</li>
<li>引用代码</li>
<li>链接</li>
<li>章节链接</li>
<li>相对链接</li>
<li>列表</li>
<li>任务列表</li>
<li>引用议题 和 拉取请求</li>
<li>提及人员 和 团队</li>
<li>引用外部资源</li>
<li>内容附件</li>
<li>使用表情符号</li>
<li>段落</li>
<li>忽略Markdown格式</li>
<li></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[X86寄存器详解（正经.jpg]]></title>
        <id>https://alittlewhiter.github.io/post/x86-ji-cun-qi-xiang-jie/</id>
        <link href="https://alittlewhiter.github.io/post/x86-ji-cun-qi-xiang-jie/">
        </link>
        <updated>2020-03-03T01:29:03.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：x86寄存器、<br>
精心整理，有空看看</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：x86寄存器、<br>
精心整理，有空看看</p>
<!-- more -->
<h2 id="概述">概述</h2>
<p>x86或80x86是英特尔Intel首先开发制造的一种微处理器体系结构的泛称。该系列较早期的处理器名称是以数字来表示，并以“86”作为结尾，包括最开始16位的Intel 8086、80186、80286、到后来推出32位80386微处理器以及如今64位的80486，因此其架构被称为“x86”。 寄存器是CPU的组成部分，是有限存贮容量的高速存贮部件，是 CPU 中非常珍贵的稀有资源，它们可用来暂存指令、数据和地址。在中央处理器的控制部件中，有指令寄存器(IR)和程序计数器(PC)，而在算术及逻辑部件中，寄存器有累加器(ACC)。<br>
早期的8086CPU中，只包含14个结构为16位的寄存器（即一个寄存器可以存放下2个字节的数据）：AX，BX，CX，DX，SP，BP，DI，SI，IP，FLAG，CS，DS，ES，SS。而到了 80386 CPU中，寄存器的个数增多了，同时寄存器的结构也变了，如绝大多数的寄存器扩展为32位，而有些寄存器则仍是16位 ，并在后续发展中不断更新改进。</p>
<h2 id="32位cpu系统级寄存器和数据结构">32位cpu系统级寄存器和数据结构</h2>
<figure data-type="image" tabindex="1"><img src="https://alittlewhiter.github.io/post-images/1583199240318.png" alt="" loading="lazy"></figure>
<h2 id="寄存器分类介绍32位模式">寄存器分类介绍（32位模式）</h2>
<blockquote>
<p>通用寄存器：8个，分别为EAX，EBX，ECX，EDX，ESP，EBP，ESI，EDI<br>
标志寄存器：1个，EFLAGS<br>
控制寄存器：5个，分别为CR0-CR4<br>
调试寄存器：8个，分别为DR0-DR7<br>
系统地址寄存器：4个，GDTR，IDTR，LDTR和TR<br>
段寄存器：6个，分别为CS，DS，SS，ES，FS，GS<br>
其他特殊目的寄存器：EIP，TSC等</p>
</blockquote>
<h3 id="通用寄存器general-purpose-registers">通用寄存器（General-Purpose Registers）：</h3>
<ul>
<li>
<p>尽管这8个通用寄存器大多时候是通用的，可以作任何用途，但是在某些情况下也有各自约定俗成的隐含用法。比如在串循环操作中ECX用作计数器，而EDI用于寻址目标数据串，ESI用于寻址源数据串。EBP和ESP主要用来维护栈，ESP通常指向栈的顶部，EBP指向当前栈帧的起始地址。<br>
<img src="https://alittlewhiter.github.io/post-images/1583200258718.png" alt="" loading="lazy"></p>
<ul>
<li>EAX, EBX, ECX, EDX称数据寄存器，它们都可以作为32位寄存器（如EAX）、16位寄存器（AX）或者分为两个独立的8位寄存器（AH、AL）使用。如果作为8位或者16位寄存器被寻址，则仅会改变32位寄存器的某一部分而不影响其他部分。</li>
<li>ESI、EDI、SI和DI称为变址寄存器，主要用于存放存储单元在段内的偏移量，用它们可实现多种不同形式的存储器操作数的寻址方式。EBP、ESP、BP和SP称为指针寄存器，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种寻址方式，为以不同的地址形式访问堆栈存储单元提供方便。变址寄存器和指针寄存器不可分割成8位寄存器，但也可存储算术逻辑运算的操作数和运算结果。<br>
<img src="https://alittlewhiter.github.io/post-images/1583200289859.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p>EAX(Accumulator)：累加寄存器 可作为累加器用于乘法、除法及一些调整指令，也可以保存被访问存储器单元的偏移地址。</p>
</li>
<li>
<p>EBX (Base)：基址寄存器 可以被作为EBX、BX，BH和BL被寻址，包括16位微处理器，BX可以保存内存系统位置的偏移地址，32位的EBX也可以用来寻址内存数据。</p>
</li>
<li>
<p>ECX (Count)：计数器寄存器 ECX是一个通用目的计数器，它持有多种指令的计数，自80386以上ECX寄存器也可以保存访问数据所在存储器单元的偏移地址。用于计数的指令包括重复字符串指令（REP/REPE/REPNE）、shift、rotate 和 LOOP/LOOPD 指令。重复字符串指令使用CX， Shift 和 rotate 移位指令使用CL作为计数器。，而LOOP/LOOPD循环指令使用CX或者ECX指令。</p>
</li>
<li>
<p>EDX (Data)：数据寄存器 通用目的数据寄存器，它常与EAX配合保存乘法运算结果的一部分或者除法运算之前的被除数，80386以后也可被用作寻址内存数据。</p>
</li>
<li>
<p>EDI（Destination Index）目标索引寄存器 通常寻址一些字符串指令的字符串目标数据。它也可以起到32或者16位通用寄存器的作用。</p>
</li>
<li>
<p>ESI（Source Index）源索引寄存器 通常寻址字符串指令的源字符串数据。</p>
</li>
<li>
<p>EBP (Base Pointer) 基指针寄存器 用作EBP或BP寻址，可直接存取堆栈中数据</p>
</li>
<li>
<p>ESP (Stack Pointer) 堆栈指针寄存器 可访问内存中堆栈段的栈顶</p>
</li>
</ul>
<h3 id="标志寄存器eflags">标志寄存器（EFLAGS）：</h3>
<ul>
<li>控制任务状态和模式切换、中断处理、指令追踪和访问权限控制，寄存器中的标志位需要特权指令代码才可以修改(特权指令：运行在内核态下的代码)，16位模式下使用PUSHF和POPF将FLAG压栈和推出，32位则用PUSHFD/POPFD。80x86和Pentium全系列微处理器的EFLAGS和FLAG寄存器如下：<br>
<img src="https://alittlewhiter.github.io/post-images/1583200854075.png" alt="" loading="lazy"></li>
</ul>
<h4 id="eflags寄存器的状态标志0-2-4-6-7以及11位指示算术指令如add-sub-mul以及div指令的结果这些状态标志的作用如下">EFLAGS寄存器的状态标志(0、2、4、6、7以及11位)指示算术指令（如ADD, SUB, MUL以及DIV指令）的结果，这些状态标志的作用如下：</h4>
<ul>
<li>CF(bit 0) [Carry flag]   若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。</li>
<li>PF(bit 2) [Parity flag]   如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。</li>
<li>AF(bit 4) [Adjust flag]   如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。这个标志在BCD(binary-code decimal)算术运算中被使用。</li>
<li>ZF(bit 6) [Zero flag]   若结果为0则将其置1，反之清零。</li>
<li>SF(bit 7) [Sign flag]   该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)</li>
<li>DF(bit 10)[Direction flag] 控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及- CLD指令分别用于设置以及清除DF标志。</li>
<li>OF(bit 11) [Overflow flag]   如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。</li>
</ul>
<h4 id="系统标志以及iopl域system-flags-and-iopl-field">系统标志以及IOPL域(System Flags and IOPL Field)，</h4>
<p>EFLAGS寄存器中的这部分标志用于控制操作系统或是执行操作，它们不允许被应用程序所修改。这些标志的作用如下：</p>
<ul>
<li>TF(bit 8) [Trap flag]   将该位设置为1以允许单步调试模式，清零则禁用该模式。</li>
<li>IF(bit 9) [Interrupt enable flag]   该标志用于控制处理器对可屏蔽中断请求(maskable interrupt requests)的响应。置1以响应可屏蔽中断，反之则禁止可屏蔽中断。</li>
<li>IOPL(bits 12 and 13) [I/O privilege level field]   指示当前运行任务的I/O特权级(I/O privilege level)，正在运行任务的当前特权级(CPL)必须小于或等于I/O特权级才能允许访问I/O地址空间。这个域只能在CPL为0时才能通过POPF以及IRET指令修改。</li>
<li>NT(bit 14) [Nested task flag]   这个标志控制中断链和被调用任务。若当前任务与前一个执行任务相关则置1，反之则清零。</li>
<li>RF(bit 16) [Resume flag]   控制处理器对调试异常的响应。</li>
<li>VM(bit 17) [Virtual-8086 mode flag]   置1以允许虚拟8086模式，清除则返回保护模式。</li>
<li>AC(bit 18) [Alignment check flag]   该标志以及在CR0寄存器中的AM位置1时将允许内存引用的对齐检查，以上两个标志中至少有一个被清零则禁用对齐检查。</li>
<li>VIF(bit 19) [Virtual interrupt flag]   该标志是IF标志的虚拟镜像(Virtual image)，与VIP标志结合起来使用。使用这个标志以及VIP标志，并设置CR4控制寄存器中的VME标志就可以允许虚拟模式扩展(virtual mode extensions)</li>
<li>VIP(bit 20) [Virtual interrupt pending flag]   该位置1以指示一个中断正在被挂起，当没有中断挂起时该位清零。【Software sets and clears this flag; the processor only reads it.】与VIF标志结合使用。</li>
<li>ID(bit 21) [Identification flag]   程序能够设置或清除这个标志指示了处理器对CPUID指令的支持。</li>
</ul>
<h3 id="控制寄存器control-register">控制寄存器（Control Register）：</h3>
<p>（CR0 - CR4）保存全局性、和任务无关的机器状态，用于控制和确定 处理器的操作模式以及当前执行任务的一些特性，其逻辑结构具体如下图：<br>
<img src="https://alittlewhiter.github.io/post-images/1583200418040.png" alt="" loading="lazy"></p>
<h4 id="cr0-包含了-6-个预定义标志控制系统的工作模式和处理器的状态其各特殊位的含义功能如下">CR0: 包含了 6 个预定义标志，控制系统的工作模式和处理器的状态，其各特殊位的含义功能如下：</h4>
<ul>
<li>PG（bit 31）：分页有效时,置位为1,清空时为0（与PE一同使用），该指令表明是否使用页表将线性地址转换成物理地址</li>
<li>CD（bit 30）：cache 缺失设置位</li>
<li>NW（bit 29）：直写无效(直写:高速缓存中的数据始终保持与主存储器中数据匹配)</li>
<li>AM（bit 18）：对齐功能屏蔽(与EFLAGS寄存器中 AC标志位一同使用)</li>
<li>WP（bit 16）：写保护</li>
<li>NE（bit 5）：数字错误标志位(与浮点协处理器共同使用)</li>
<li>ET（bit 4）：扩展类型.设置有效位时,支持 ntel 387 DX 数学协处理器指令.</li>
<li>TS（bit 3）：每当任务切换时就设置该位,并且在解释协处理器指令之前测试该位</li>
<li>EM（bit 2）：该位表明是否需要仿真协处理器的功能</li>
<li>MP（bit 1）：协处理器监视标志位</li>
<li>PE（bit 0）：保护模式使能，当设置有效位（1），CPU工作在保护模式；反之（0），则在实模式下运行。</li>
</ul>
<h4 id="cr1-未定义的控制寄存器保留">CR1: 未定义的控制寄存器，保留。</h4>
<h4 id="cr2-页故障线性地址寄存器保留最后一次出现页故障的全32位线性地址">CR2: 页故障线性地址寄存器，保留最后一次出现页故障的全32位线性地址</h4>
<h4 id="cr3-页目录基址寄存器保存页目录表的物理内存基地址和pcd和pwt标志位和cache有关">CR3: 页目录基址寄存器，保存页目录表的物理内存基地址和PCD和PWT标志位(和Cache有关)</h4>
<ul>
<li>PCD: 控制当前页目录表的缓冲，当设置清空时，缓冲置位时，缓冲无效.与CR0中的CD或PG一同使用</li>
<li>PWT: 控制cache采取直写还是回写的策略.当设置清空时,回写有效.当置位时，直写有效。</li>
</ul>
<h4 id="cr4-一些结构的扩展表明对于特定的处理器和操作系统执行支持">CR4: 一些结构的扩展.表明对于特定的处理器和操作系统执行支持.</h4>
<ul>
<li>VME: 虚地址模式，当清空时无效.</li>
<li>PVI: 保护模式虚中断，当清空时无效</li>
<li>TSD: 时间戳允许标志位，当清空时，允许RDTSC指令执行在任务特权级上；当置位时，只允许工作在特权级0.</li>
<li>DE: 调试扩展，置位表明DR4与DR5将产生没有定义的异常</li>
<li>PSE: 当置位时使用4M的页面；清空，使用4K的页面</li>
<li>PAE: 置位表示使用36物理内存的分页机制，清空时使用32位分页机制</li>
<li>MCE: 置位表示使用机器检查异常机制</li>
<li>PGE: 置位表示启动全局页面，当写CR3时，也不会被替换.</li>
<li>PCE: 置位表明使RDPMC指令工作在任何保护级别.</li>
<li>OSFXSR: 置位表明操作系统支持FXSAVE and FXRSTOR指令</li>
<li>OSXMMEXCPT: 置位表明操作系统支持不可屏蔽的SIMD浮点异常.</li>
</ul>
<h3 id="调试寄存器debug-register">调试寄存器（Debug Register）：</h3>
<p>（DR0 - DR7）使系统程序设计人员设置和监视1到4个断点（编号0-3），用它们可以规定指令执行和数据读写的任何组合。应用于调试应用代码、系统代码、开发多任务操作系统，来监视代码的运行和处理器的性能。对于每个断点，可以指定以下信息：</p>
<ul>
<li>断点发生的线性地址</li>
<li>断点位置的长度：1、2、4或8个字节</li>
<li>必须在地址处执行的操作才能生成调试异常</li>
<li>是否启用断点</li>
<li>生成调试异常时是否存在断点条件<br>
<img src="https://alittlewhiter.github.io/post-images/1583200462908.png" alt="" loading="lazy"></li>
</ul>
<h4 id="调试地址寄存器debug-address-registersdr0-dr3">调试地址寄存器（Debug Address Registers）DR0-DR3：</h4>
<p>保留4个32位断点的线性地址</p>
<h4 id="调试寄存器debug-registersdr4dr5">调试寄存器（Debug Registers）DR4，DR5：</h4>
<p>启用调试扩展时（控制寄存器CR4中的DE标志已置位时）保留调试寄存器DR4和DR5（）并尝试引用DR4和DR5寄存器会导致无效操作码异常</p>
<h4 id="调试状态寄存器debug-status-registerdr6">调试状态寄存器（Debug Status Register）DR6：</h4>
<p>报告在上次调试异常时采样的调试条件生成，且仅在生成异常时才会更新此寄存器。该寄存器中的标志显示以下信息：<br>
- B0—B3: 断点状态的监测<br>
- BD: 调试寄存器访问监测.置位,表明在指令流中,下一条指令将访问其中的一个调试寄存器<br>
- BS: 单步执行标志位<br>
- BT: 任务转换标志位</p>
<h4 id="调试控制寄存器debug-control-registerdr7">调试控制寄存器（Debug Control Register）DR7：</h4>
<p>该寄存器中的标志信息如下：<br>
- L0—L3: 局部断点使能标志位<br>
- G0--G3: 全局断点使能标志位<br>
- LE AND GE: 置位表明处理器可以监测导致数据断点的指令，一般置位<br>
- GD: 通用监测使能标志位.表明是否开启调试寄存器保护.<br>
- LEN0 through LEN3 : 用来表明相应断点地址寄存器内存位置的大小.<br>
- R/W0 through R/W3: 相应断点的状态</p>
<h3 id="系统地址寄存器memory-management-registers">系统地址寄存器（Memory Management Registers）：</h3>
<ul>
<li>80386中含有4个系统地址寄存器，包括全局描述符表寄存器GDTR(Global Descriptor Table Register)、中断描述符表寄存器 IDTR(Interrupt Descriptor Table Register)、局部描述表 寄存器LDTR(Local Descriptor Table Register)和任务寄存器TR(Task Register)。</li>
<li>主要用来在保护模式下，管理用于生成线性地址和物理地址的4个系统管理描述符表，GDTR、IDTR和LDTR用于寻址存放描述符表的段。TR用于寻址一个特殊的任务状态段(Task State Segment，TSS)。TSS中包含着当前执行任务的重要信息。<br>
<img src="https://alittlewhiter.github.io/post-images/1583200761420.png" alt="" loading="lazy"></li>
</ul>
<p>具体情况如下：<br>
- 全局描述符表寄存器GDTR：是一个48位寄存器，用来存放全局描述符表GDT的32位线性基地址和16位的界限值。在全局描述符表中不仅包括有操作系统使用的描述符，而且还有所有任务使用的公用描述符。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF，在保护模式初始化过程中必须给GDTR加载一个新值。<br>
- 中断描述符表寄存器IDTR：是一个48位寄存器，用来存放中断描述符表IDT的32位线性基地址和16位的界限值。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成 0xFFFF。<br>
局部描述符表寄存器LDTR：是一个16位寄存器，用来存放局部描述符表 LDT 的 32 位线性基地址、16 位段限长和描述符属性值。另外还有一个隐含的描述符高速缓冲寄存器，用来存放LDT表描述符。在机器加电或处理器复位后，段选择符和基地址被默认地设置为 0，而段长度被设置成 0xFFFF。<br>
- 任务状态寄存器TR：是一个16位寄存器，用来存放当前任务状态段TSS的16位段选择符、32位基地址、16位段长度和描述符属性值。与之相应，也有一个隐含的描述符高速缓冲寄存器，用来存放任务状态段TSS的描述符。当执行任务切换时，处理器会把新任务的 TSS 的段选择符和段描述符自动加载进任务寄存器TR中。</p>
<h3 id="段寄存器">段寄存器：</h3>
<ul>
<li>段寄存器是根据内存分段的管理模式而设置的，用于保存16位段选择器（一种特殊指针，用于标识内存中的段）。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。DS，ES，FS和GS寄存器指向四个数据段，四个数据段的可用性允许有效和安全地访问不同类型的数据结构。
<ul>
<li>代码段寄存器（CS）(Code Segment)：包含代码段的段选择器，其中存储正在执行的指令。处理器使用由CS和EIP组成的逻辑地址从代码段中获取指令</li>
<li>数据段寄存器（DS）(Data Segment)：值为数据段的段值</li>
<li>附加段寄存器（ES）(Extra Segment)：其值为附加数据段的段值</li>
<li>附加段寄存器（FS）(Extra Segment)：其值为附加数据段的段值</li>
<li>附加段寄存器（GS）(Extra Segment)：32位微机系统中可访问</li>
<li>堆栈段寄存器（SS）(Stack Segment)：其值为堆栈段的段值，包含堆栈段的段选择器，其中存储过程堆栈以用于当前正在执行的程序，任务或处理程序，所有堆栈操作都使用SS寄存器来查找。</li>
</ul>
</li>
</ul>
<h3 id="其他特殊目的寄存器">其他特殊目的寄存器：</h3>
<ul>
<li>
<p>指令指针指示器（EIP）：它是32位寄存器，低16位称为IP（8086的指令指针寄存器），用与兼容16位CPU，其内容是下一条要取入CPU的指令在内存中的偏移地址。当一个程序开始运行时，系统把EIP清零，每取入一条指令，EPI自动增加取入CPU的字节数目，所以称EIP为指令指针。<br>
<img src="https://alittlewhiter.github.io/post-images/1583200805247.png" alt="" loading="lazy"></p>
</li>
<li>
<p>时间戳寄存器（TSC）：每个时钟周期时其值加1，重启时清零。通过RDTSC指令读取TSC寄存器，只有当CR4寄存器的TSD位为0时，才可以在任何优先级下执行该指令，否则只能在特权级下执行该指令。</p>
</li>
<li>
<p>浮点寄存器（FP）：由于在80486微处理器内部设有浮点运算器，因此在其内部有相应的寄存器，其中包括8个80位通用数据寄存器、1个48位指令指针寄存器、1个48位数据指针寄存器、1个16位控制字寄存器、1个16位状态字寄存器和1个16位标记字寄存器。</p>
</li>
</ul>
<h2 id="64位扩展寄存器简要说明">64位扩展寄存器（简要说明）</h2>
<ul>
<li>X86-64中，通用寄存器都是64位，相对32位的x86来说，标识符从原来的ebp变成rbp。为了向后兼容性，ebp依然可以使用，不过指向了rbp的低32位，新增加通用寄存器r8到r15，其低位分别用d、w、b指定长度。</li>
<li>32位使用栈帧来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数，rax作为返回值。64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用。64位支持一些形式的以PC相关的寻址，而32位只有在jmp的时候才会用到这种寻址方式。其中：
<ul>
<li>rax 作为函数返回值使用</li>
<li>rsp 栈指针寄存器，指向栈顶</li>
<li>rdi，rsi，rdx，rcx，r8，r9 用作函数参数，依次对应第1参数，第2参数</li>
<li>rbx，rbp，r12，r13，14，15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改</li>
<li>r10，r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值<br>
<img src="https://alittlewhiter.github.io/post-images/1583200833479.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="参考资料">参考资料：</h2>
<p>【1】	深入理解计算机体系结构<br>
【2】	X86系列汇编语言程序设计<br>
【3】	李忠，王晓波，余洁．x86汇编语言：从实模式到保护模式[M]．北京：电子工业出版社<br>
【4】	Intel x86 CPU系列的寄存器-wangbaolin719-ChinaUnix博客<br>
URL: http://blog.chinaunix.net/uid-27717694-id-3943419.html<br>
【5】	Intel_x86_CPU系列的寄存器[整理版]<br>
URL: https://www.docin.com/p-880130068.html<br>
【6】	[官方文档]：64-ia-32-architectures-software-developer-manual-325462.pdf</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++ 板子]]></title>
        <id>https://alittlewhiter.github.io/post/c-ban-zi/</id>
        <link href="https://alittlewhiter.github.io/post/c-ban-zi/">
        </link>
        <updated>2020-03-02T13:42:08.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：代码块、函数、语法 for C++<br>
{ 这 xx 竟 这 该 死 的 甜 美 ...  不要停下来啊~🤙🤙🤙}</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：代码块、函数、语法 for C++<br>
{ 这 xx 竟 这 该 死 的 甜 美 ...  不要停下来啊~🤙🤙🤙}</p>
<!-- more -->
<h2 id="开始你的表演">开始你的表演</h2>
<p>1、设想要使用new建立一个rows行，cols列的矩阵:</p>
<pre><code class="language-c++">int rows, cols ;
int **array = new int*[rows] ; 
for (int i = 0 ; i &lt; rows ; i++) {
    array[i] = new int[cols] ; 
    memset(*array, 0, sizeof(int)*cols) ;    // memset()是按字节填充，值一般只为0或-1。
}  
</code></pre>
<p>2、结构体重载操作符模板：</p>
<pre><code class="language-c++">Point operator + (const Point&amp; A, const Point&amp; B) {  
     return Point(A.x+B.x, A.y+B.y); 
}
ostream&amp; operator &lt;&lt; (ostream &amp;out, const Point&amp; p) {
    out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;  
    return out; 
}
Point a, b;
cout &lt;&lt; a+b &lt;&lt; endl; 
</code></pre>
<p>3、求和函数模板sum()：</p>
<pre><code class="language-c++">template&lt;typename T&gt; T sum(T* begin, T* end) {  
    T *p = begin;  
    T ans = 0;  
    for(T *p = begin; p != end; p++)   
        ans = ans + *p;   
    return ans; 
}
</code></pre>
<p>4、结构体和类也可以是带模板的，如Point中x，y可以为int或double等多种类型：</p>
<pre><code class="language-c++">template &lt;typename T&gt; struct Point {  
    T x, y;  
    Point(T x=0, T y=0) : x(x),y(y) { } 
}; 
</code></pre>
<p>5、重载转换运算符 ：<br>
对于类X的成员函数 X::operator T()<br>
T是类型名 ，定义了一个X到T的转换。</p>
<pre><code class="language-c++">operator bool() const {
   return p;
} 
Handle h; 
bool b=h;       //在这里调用  
</code></pre>
<p>6、C++中const 引用的是对象时只能访问该对象的const 函数，因为其他函数有可能会修改该对象的成员，编译器为了避免该类事情发生，会认为调用非const函数是错误的，error：…discards qualifiers 的意思就是缺少限定符。<br>
因此：** 类似getter函数一般需要在后面加const限定符 **</p>
<p>7、求gcd最大公约数</p>
<ul>
<li>最快算法：</li>
</ul>
<pre><code class="language-c++">int gcd(int a, int b){
    while(b^=a^=b^=a%=b) ;
    return a;
}
</code></pre>
<ul>
<li>一般算法：</li>
</ul>
<pre><code class="language-c++">int gcd(int a,  int b)  {          // 要求
     return b ? gcd(b, a%b) : a ;
}
</code></pre>
<p>8、普通快速幂的模板：</p>
<pre><code class="language-c++">int fastpow(int base, int n, int mod){
	int ans=1; 
	while(n){
		if(n&amp;1) 
                    ans *= base % mod ;
		base *= base;
		n &gt;&gt;= 1;
	}
	return ans%mod;
}
</code></pre>
<p>9、快速读入整数（ 远快于 scanf () 与 cin ）</p>
<pre><code class="language-c++">inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch &lt; '0' || ch &gt; '9') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
</code></pre>
<p>10、</p>
<p>11、</p>
<p>Final、一道大杂烩~真香</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
#define maxn 500005
#define maxm 200005
#define INF 1234567890
#define p 1000000007
template&lt;class T&gt;inline bool read(T &amp;x)
{
    x=0;register char c=getchar();register bool f=0;
    while(!isdigit(c)){if(c==EOF)return false;f^=c=='-',c=getchar();}
    while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar();
    if(f)x=-x;
    return true;
}
template&lt;class T&gt;inline bool readd(T &amp;x)
{
    register ll X=0;register double y=1.0;register char c=getchar();register bool f=0;
    while(!isdigit(c)){if(c==EOF)return false;f^=c=='-',c=getchar();}
    while(isdigit(c))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(c^48),c=getchar();
    x=X;
    if(c!='.')return true;
    c=getchar();
    while(isdigit(c))x+=(y/=10)*(c^48),c=getchar();
    if(f)x=-x;
    return true;
}
template&lt;class T&gt;inline bool readc(T &amp;x)
{
    register char c=getchar();
    while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
    if(c==EOF)return false;
    x=c;
    return true;
}
template&lt;class T&gt;inline bool readc(T *x)
{
    register char c=getchar();
    while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
    if(c==EOF)return false;
    while(c!=' '&amp;&amp;c!='\n'&amp;&amp;c!='\r'&amp;&amp;c!='\t'&amp;&amp;c!=EOF)*x++=c,c=getchar();
    *x=0;
    return true;
}
template&lt;class T&gt;inline bool reads(T &amp;x)
{
    x=&quot;&quot;;register char c=getchar();
    while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
    if(c==EOF)return false;
    while(c!=' '&amp;&amp;c!='\n'&amp;&amp;c!='\r'&amp;&amp;c!='\t'&amp;&amp;c!=EOF)x+=c,c=getchar();
    return true;
}
template&lt;class T&gt;inline void print(T x)
{
    if(x&lt;0)putchar('-'),x=-x;
    if(x&gt;9)print(x/10);
    putchar(x%10^48);
}
template&lt;class T&gt;inline void printd(T x,ll y)
{
    static ll mul[]={1};
    for(register ll i=1;i&lt;=18;i++)
        mul[i]=(mul[i-1]&lt;&lt;3)+(mul[i-1]&lt;&lt;1);
    if(x&lt;-1e-12)putchar('-'),x=-x;
    x*=mul[y];
    register ll x1=(ll)round(x),x2=x1/mul[y],x3=x1-x2*mul[y];
    print(x2);
    if(y&gt;0)
    {
        putchar('.');
        for(register ll i=1;i&lt;y&amp;&amp;x3*mul[i]&lt;mul[y];putchar('0'),i++);
        print(x3);
    }
}
template&lt;class T&gt;inline void printc(T x){putchar(x);}
template&lt;class T&gt;inline void printc(T *x){while(*x)putchar(*x++);}
template&lt;class T&gt;inline void prints(T x){for(register ll i=0;x[i]!='\0';i++)putchar(x[i]);}
template&lt;class T&gt;inline T maxd(T a,T b){if(b&gt;a)return b;return a;}
template&lt;class T&gt;inline T mind(T a,T b){if(b&lt;a)return b;return a;}
template&lt;class T&gt;inline T gcd(T a,T b){while(a^=b^=a^=b%=a);return b;}
template&lt;class T&gt;inline T lcm(T a,T b){return a/gcd(a,b)*b;}
template&lt;class T&gt;inline T absd(const T &amp;a){if(a&lt;0)return -a;return a;}
template&lt;class T&gt;inline void print(T x,char c){print(x),putchar(c);}
template&lt;class T&gt;inline void printd(T x,ll y,char c){printd(x,y),putchar(c);}
template&lt;class T&gt;inline void printc(T x,T c){printc(x),putchar(c);}
template&lt;class T&gt;inline void printc(T *x,T c){printc(x),putchar(c);}
template&lt;class T&gt;inline void prints(T x,char c){prints(x),putchar(c);}

</code></pre>
<p>mua~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web：前 前 后 后  ]]></title>
        <id>https://alittlewhiter.github.io/post/webqian-qian-hou-hou/</id>
        <link href="https://alittlewhiter.github.io/post/webqian-qian-hou-hou/">
        </link>
        <updated>2020-03-02T13:07:17.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：html, css, javascript, 标签，布局...<br>
【奥里给 ~hetui！！</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：html, css, javascript, 标签，布局...<br>
【奥里给 ~hetui！！</p>
<!-- more -->
<h2 id="position绝对和相对">Position：绝对和相对</h2>
<h3 id="主要区别">主要区别</h3>
<ul>
<li>Absolution：元素会脱离文档流，定位是相对于离它最近的且不是static定位的父元素而言，若该元素没有设置宽度，则宽度由元素里面的内容决定，且宽度不会影响父元素，定位为absolution后，原来的位置相当于是空的，下面的的元素会来占据。</li>
<li>Relative：元素仍处于文档流中，定位是相对于原本自身的位置，若没有设置宽度，则宽度为父元素的宽度，该元素的大小会影响父元素的大小。</li>
</ul>
<h3 id="position扩展">position扩展</h3>
<ol>
<li>Absolute：绝对定位，是相对于最近的且不是static定位的父元素来定位</li>
<li>Fixed：绝对定位，是相对于浏览器窗口来定位的，是固定的，不会跟屏幕一起滚动。</li>
<li>Relative：相对定位，是相对于其原本的位置来定位的。</li>
<li>Static：默认值，没有定位。</li>
<li>Inherit：继承父元素的position值。</li>
</ol>
<p>** 一、absolute：绝对定位，CSS 写法“ position: absolute; ”**<br>
1. 没有设定 Top、Right、Bottom、Left 的情况，默认依据父级的“内容区域原始点”为原始点，上面例子红色部分(父级黄色区域有 Padding 属性，“坐标原始点”和“内容区域原始点”不一样)， 基于绝对定位的元素不会占据空间。<br>
2. 有设定 Top、Right、Bottom、Left 的情况，这里又分了两种情况如下：<br>
(1). 父级没 position 属性，浏览器左上角(即 Body)为“坐标原始点”进行定位，位置由 Top、Right、Bottom、Left 属性决定。<br>
(2). 父级有 position属性，父级的“坐标原始点”为原始点，此时可以忽略父级元素padding的作用。</p>
<p>** 二、relative：相对定位，CSS 写法“ position: relative; ”**<br>
父级元素第一个relative子元素参照父级的“内容区域原始点”为原始点，无父级则以 Body 的“内容区域原始点”为原始点，其余依各元素次序顺延下来获得其位置，再受Top、Right、Bottom、Left 属性值影响，且有“撑开或占据高度”的作用。<br>
相对定位与绝对定位的区别在于它的参照点不是左上角的原点，而是该元素本身原先的起点位置。并且即使该元素偏移到了新的位置，也仍然从原始的起点处占据空间。</p>
<p>** 注 **：Absolute定位的子元素宽度不会影响父元素的宽度，而relative定位的子元素可能会撑大父元素。在没有独立设置宽度时，absolute定位的子元素的宽度会自动缩小为内部元素的布局应有的宽度，而relative定位的元素会继承父元素的宽度（甚至超出父元素范围产生覆盖），但不包括边界宽度。</p>
<h2 id="超链接-aa">超链接 <a></a></h2>
<ul>
<li>超链接虽然在网页中占有不可替代的地位, 但是在HTML中创建超链接非常简单, 只需用&lt;a&gt; &lt;/a&gt;标记环绕需要被链接的对象即可。<br>
<code>基本语法格式: &lt;a href-&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式”&gt;文本或图像&lt;/a&gt;</code></li>
<li>在上面的语法中, &lt;a&gt;标记是一个行内标记,用于定义超链接, href和target为其常用属性，具体解释如下:<br>
-- href :用于指定链接目标的url地址。当为&lt;a&gt;标记应用href属性时，它就具有了超链接的功能。<br>
-- target :用于指定链接页面的打开方式，其取值有self和blank两种，其中self为默认值。意为在原窗口中打开，blank为在新窗口中打开。</li>
</ul>
<h2 id="文本居中">文本居中</h2>
<ul>
<li>在将&lt;span&gt;标签style属性设置为vertical-align: middle 后，元素内容并没有垂直居中，在W3C官方中对 vertical-align做了下面的解释：This property affects the vertical positioning inside a line box of the boxes generated by an inline-level element.</li>
<li>事实上，一个Box中由很多行很多元素组成，vertical-align只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。如果把 vertical-align:middle 放到一个单元格元素，即table的td元素中，它的垂直居中显示是没任何问题的，因为它表示相对于该行的垂直高度居中显示。</li>
<li>可以设置&lt;span&gt;元素style中的 line-heght 值为其父元素&lt;div&gt;的height值，这样 vertical-align:middle 就会使&lt;span&gt;元素内容垂直居中。</li>
</ul>
<h2 id="more">More...</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Computer Network 默 · 示 · 录]]></title>
        <id>https://alittlewhiter.github.io/post/computer-network-mo-shi-lu/</id>
        <link href="https://alittlewhiter.github.io/post/computer-network-mo-shi-lu/">
        </link>
        <updated>2020-03-02T12:47:24.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords： WIFI、WLAN、跃点、RJ45、and so on<br>
bie说了，反正天<s>填</s>坑啊！😭😭😭<br>
#- 丢你王忠，你好！🕷 -#</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords： WIFI、WLAN、跃点、RJ45、and so on<br>
bie说了，反正天<s>填</s>坑啊！😭😭😭<br>
#- 丢你王忠，你好！🕷 -#</p>
<!-- more -->
<h2 id="wlan-和wifi-的区别">WLAN 和WIFI 的区别？</h2>
<ul>
<li>WIFI包含于WLAN中，主要采用802.11b协议的一项技术，是WLAN的一个标准，子集的关系。它们发射信号的功率不同，覆盖范围不同。</li>
<li>WIFI就是一种无线联网的技术，一般都是小范围的， 距离发射器远了就会收不到网络，而wlan覆盖范围就广泛的多</li>
</ul>
<h2 id="跃点">跃点：</h2>
<ul>
<li>即路由。一个路由为一个跃点。传输过程中需要经过多个网络，每个被经过的网络设备点（有能力路由的）叫做一个跃点，地址就是它的ip。跃点数是经过了多少个跃点的累加器，为了防止无用的数据包在网上流散。 为路由指定所需跃点数的整数值（范围是 1 ~ 9999），它用来在路由表里的多个路由中选择与转发包中的目标地址最为匹配的路由, 所选的路由具有最少的跃点数。自动跃点修改方法如下：
<ul>
<li>进入相关设备的网络设置，再进入internet TCP/IP的属性设置，再进入高级属性设置；</li>
<li>默认情况下是勾选的“自动跃点”，不要选择它，手动输入“接口跃点数”，输入的数字越小，优先级越高，这样可以手动控制哪个路由的优先级了。</li>
</ul>
</li>
</ul>
<h2 id="rj45接口">RJ45接口</h2>
<ul>
<li>有两类：用于以太网网卡(网卡接口)、路由器以太网接口等的DTE类型，还有用于交换机等的DCE类型。DTE我们可以称做“数据终端设备”，DCE我们可以称做“数据通信设备”。从某种意义来说，DTE设备称为“主动通信设备”，DCE设备称为“被动通信设备”。当两个类型一样的设备使用RJ45接口连接通信时，必须使用交叉线连接。</li>
</ul>
<h2 id="ip分配">IP分配</h2>
<ul>
<li>169.254.0.0/16这样的IP是一个本地链接地址段。RFC3927指出，在IP网络里，每台主机都需要一个IP地址，通常情况下是通过DHCP服务器自动分配，但某些特殊情况下，DHCP分配失败或者没有DHCP服务器时，机器可以自己分配一个IP来完成这个工作。<br>
169.254.X.X是 Windows操作系统 在 DHCP 信息租用失败时自动给客户机分配的IP地址。由于网络连接问题、网线问题,DHCP服务器(其实就是Modem, 路由器, 或提供共享上网的主机)问题等，而令DHCP信息租用失败, 而IP169.254.X.X 的分配可能会令客户机(你自己的计算机,设置了&quot;自动获取IP&quot;)与所处局域网网关(Modem, 路由器, 或提供共享上网的主机) 位于不同的网段中, 而无法与网关通信,而导致无法接入Internet的情况。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[那一天，人类终于回想起曾一度被Ucore支配的恐惧...]]></title>
        <id>https://alittlewhiter.github.io/post/na-yi-tian-ren-lei-zhong-yu-hui-xiang-qi-ceng-yi-du-bei-ucore-zhi-pei-de-kong-ju/</id>
        <link href="https://alittlewhiter.github.io/post/na-yi-tian-ren-lei-zhong-yu-hui-xiang-qi-ceng-yi-du-bei-ucore-zhi-pei-de-kong-ju/">
        </link>
        <updated>2020-03-02T12:02:31.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：Ucore lab0、lab1、lab2实验分析、报告</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：Ucore lab0、lab1、lab2实验分析、报告</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搬点之前的《操♂作 系 统》]]></title>
        <id>https://alittlewhiter.github.io/post/ban-dian-zhi-qian-de-lesslesscao-zuo-xi-tong-greatergreater-huan-you-wo-os-da-jpg/</id>
        <link href="https://alittlewhiter.github.io/post/ban-dian-zhi-qian-de-lesslesscao-zuo-xi-tong-greatergreater-huan-you-wo-os-da-jpg/">
        </link>
        <updated>2020-03-02T11:47:06.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：OS管理功能、分类、进程</p>
<p>就学啥忘啥呗、学到老 &amp; 忘到老...<br>
~（Ko no OS da !）~</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：OS管理功能、分类、进程</p>
<p>就学啥忘啥呗、学到老 &amp; 忘到老...<br>
~（Ko no OS da !）~</p>
<!-- more -->
<h1 id="操作系统可以分为五大管理功能部分">操作系统可以分为五大管理功能部分：</h1>
<p>1）设备管理：主要是负责内核与外围设备的数据交互，实质是对硬件设备的管理，包括对输入输出设备的分配，初始化，维护与回收等。例如管理音频输入输出。<br>
2）作业管理：这部分功能主要是负责人机交互，图形界面或者系统任务的管理。<br>
3）文件管理：这部分功能涉及文件的逻辑组织和物理组织，目录结构和管理等。从操作系统的角度来看，文件系统是系统对文件存储器的存储空间进行分配，维护和回收，同时负责文件的索引，共享和权限保护。而从用户的角度来说，文件系统是按照文件目录和文件名来进行存取的。<br>
4）进程管理：说明一个进程存在的唯一标志是pcb（进程控制块），负责维护进程的信息和状态。进程管理实质上是系统采取某些进程调度算法来使处理合理的分配给每个任务使用。<br>
5）存储管理：数据的存储方式和组织结构。</p>
<h1 id="os的分类">OS的分类</h1>
<h3 id="操作系统的类型也可以分为几种批处理系统分时操作系统实时操作系统网络操作系统等-下面将简单的介绍他们各自的特点">操作系统的类型也可以分为几种：批处理系统，分时操作系统，实时操作系统，网络操作系统等。下面将简单的介绍他们各自的特点：</h3>
<p>1）批处理系统：首先，用户提交完作业后并在获得结果之前不会再与操作系统进行数据交互，用户提交的作业由系统外存储存为后备作业；数据是成批处理的，有操作系统负责作业的自动完成；支持多道程序运行。<br>
2）分时操作系统：首先交互性方面，用户可以对程序动态运行时对其加以控制；支持多个用户登录终端，并且每个用户共享CPU和其他系统资源。<br>
3）实时操作系统：会有时钟管理，包括定时处理和延迟处理。实时性要求比较高，某些任务必须优先处理，而有些任务则会被延迟调度完成。<br>
4）网络操作系统：网络操作系统主要有几种基本功能<br>
（1）网络通信：负责在源主机与目标主机之间的数据的可靠通信，这是最基本的功能。<br>
（2）网络服务：系统支持一些电子邮件服务，文件传输，数据共享，设备共享等。<br>
（3）资源管理：对网络中共享的资源进行管理，例如设置权限以保证数据源的安全性。<br>
（4）网络管理：主要任务是实现安全管理，例如通过“存取控制”来确保数据的存取安全性，通过“容错性”来保障服务器故障时数据的安全性。<br>
（5）支持交互操作：在客户/服务器模型的LAN环境下，多种客户机和主机不仅能与服务器进行数据连接通信，并且可以访问服务器的文件系统</p>
<h1 id="下一个">下一个</h1>
<p>。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库の一些笔记]]></title>
        <id>https://alittlewhiter.github.io/post/shu-ju-ku-noyi-xie-bi-ji/</id>
        <link href="https://alittlewhiter.github.io/post/shu-ju-ku-noyi-xie-bi-ji/">
        </link>
        <updated>2020-03-02T11:25:57.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：关系的键、DML &amp; DDL、模式、数据库完整性、FD</p>
<p>新冠肺炎宅在家，学习效率那是超像想地low哇<sub>（唉、搬点旧货</sub></p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：关系的键、DML &amp; DDL、模式、数据库完整性、FD</p>
<p>新冠肺炎宅在家，学习效率那是超像想地low哇<sub>（唉、搬点旧货</sub></p>
<!-- more -->
<h2 id="有关-键">有关 键</h2>
<p><strong>超键（super key， SK）</strong><br>
<code>又称“超码”，是在数据库关系模式设计中能唯一标识一个元组的属性或属性集。 包含所有属性的集叫做明显（平凡）超键。</code><br>
<strong>候选键（candidate key， CK）</strong><br>
<code>又称“候选键“、”极小码“，是在数据库关系模式设计中能能唯一标识一个元组，且其真子集不能唯一标识一个元组的属性或属性集。</code><br>
<strong>主键（primary key， PK）</strong><br>
<code>又称“主码“，既从候选键中挑选出来的能唯一标识一个元组的属性或属性集。一张表中有且只能有一个主键。</code><br>
<strong>外键（foreign key， FK）</strong><br>
<code>又称“外码“，若一个关系中的一个属性或属性集是另外一个关系中的主码，则该属性或属性集为这个关系引用另外一个关系的外码。一张表中可以没有外码。</code></p>
<p><strong>DML(Data Manipulation Language)数据操纵语言：</strong><br>
<code>适用范围：对数据库中的数据进行一些简单操作，数据库表的增删改查，如insert, delete, update, select，call 等（select 可以划分到 DQL，）</code><br>
<strong>DDL(Data Definition Language)数据定义语言：</strong><br>
<code>适用范围：对数据库中的某些对象(例如，database,table)进行管理，如建库、建表、更改表结构，删库、删表，建索引，设置约束等：Create, Alter 和 Drop.</code><br>
- Create语句：可以创建数据库和数据库的一些对象。<br>
- Drop语句：可以删除数据表、索引、触发程序、条件约束以及数据表的权限等。<br>
- Alter语句：修改数据表定义及属性。</p>
<h3 id="主要区别">主要区别：</h3>
<p>1.DML操作是可以手动控制事务的开启、提交和回滚的。<br>
2.DDL操作是隐性提交的，不能rollback！</p>
<h3 id="此外还有">此外还有：</h3>
<p>DCL（DataControl Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin, dbcreator, db_owner或db_securityadmin等人员才有权力执行DCL<br>
DQL（Data QueryLanguage）：SELECT，数据查询语言</p>
<h2 id="模式schema">模式（Schema）：</h2>
<pre><code class="language-git">也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。
</code></pre>
<h3 id="理解">理解：</h3>
<p>① 一个数据库只有一个模式；<br>
② 是数据库数据在逻辑级上的视图；<br>
③ 数据库模式以某一种数据模型为基础；<br>
④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。</p>
<h3 id="外模式external-schema">外模式(external schema)</h3>
<ul>
<li>外模式是用户与数据库系统的接口。</li>
<li>单个用户的视图称为外部视图。一个用户往往只用到数据库的一部分。外部视图由若干外 部记录类型组成，这些外部记录类型和概念记录类型、内部记录类型可能不一样。</li>
<li>用户使用数据操纵语言语句对数据库进行操作.实际上是对外部视图的外部记录进行操作。例如GET操作是读一个外部记录值(实际上是逻辑记录值)，而不是数据库的内部记录值。每个外部视图用 DDL描述后得到的是外模式。描述外部视图的DDL称为“外模式DDL”。</li>
<li>外模式是外部视图 中每个外部记录类型的定义，因此它是面向一个或多个用户需要的那部分数据的描述。在外模 式中还必须定义外模式和概念模式间数据结构的差异。</li>
<li>外模式与概念模式的分离，使数据库系统的灵活性大大增加。外模式是从模式导出的，它必须是导出它的模式的逻辑子集但在外模式里，不仅那些与用户无关的数据可以略去，而且 数据项可以按照用户使用的习惯重新命名，记录类型也可以重新组合和命名。应用程序员不必 再关心整个数据库的全局逻辑结构，他只与外模式发生直接联系，按照外模式存储和操纵数据.</li>
<li>一个数据库可以有多个外模式。由于它是各个用户的数据视图，如果不同用户在应用需求，看待数据的方式，对数据保密的要求等方面存在差异，则其外模式描述就是不同的。即使对模式中同一数据，在外模式中的结构，类型，长度，保密级别等都可以是不同的。</li>
<li>对于一个数据库系统而言，同一外模式也可以为某一用户的多个应用所应用，但任何一个应用程序都必须使用而且只能使用一个外模式，才能对数据库中的数据进行操作。一个模式可以支持若干个外模式，但每一个外模式只能属于一个模式。</li>
</ul>
<h2 id="数据库完整性database-integrity">数据库完整性（Database Integrity）</h2>
<p><mark>指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。数据库完整性由各种各样的完整性约束来保证，因此可以说数据库完整性设计就是数据库完整性约束的设计。</mark></p>
<h3 id="数据库完整性约束分类">数据库完整性约束分类</h3>
<p><mark>数据库完整性约束可分为6类：列级静态约束、元组级静态约束、关系级静态约束、列级动态约束、元组级动态约束、关系级动态约束。动态约束通常由应用软件来实现。</mark></p>
<ul>
<li>
<p>关系完整性的用于保证数据库中数据的正确性。系统在进行更新、插入或删除等操作时都要检查数据的完整性，核实其约束条件，即关系模型的完整性规则。</p>
</li>
<li>
<p>在关系模型中有四类完整性约束：实体完整性、域完整性、参照完整性和用户定义的完整性，其中实体完整性和参照完整性约束条件, 称为关系的两个不变性。</p>
<ul>
<li>1、实体完整性（Entity Integrity）。实体完整性指表中行的完整性。主要用于保证操作的数据（记录）非空、唯一且不重复。即实体完整性要求每个关系（表）有且仅有一个主键，每一个主键值必须唯一，而且不允许为“空”（NULL）或重复。</li>
<li>2、域完整性（Domain Integrity）是指数据库表中的列必须满足某种特定的数据类型或约束。其中约束又包括取值范围、精度等规定。表中的CHECK、FOREIGN KEY 约束和DEFAULT、 NOT NULL定义都属于域完整性的范畴。</li>
<li>3、参照完整性（Referential Integrity）属于表间规则。对于永久关系的相关表，在更新、插入或删除记录时，如果只改其一，就会影响数据的完整性。如删除父表的某记录后，子表的相应记录未删除，致使这些记录称为孤立记录。对于更新、插入或删除表间数据的完整性，统称为参照完整性。通常，在客观现实中的实体之间存在一定联系，在关系模型中实体及实体间的联系都是以关系进行描述，因此，操作时就可能存在着关系与关系间的关联和引用。</li>
<li>4、用户定义完整性（User-defined Integrity）是对数据表中字段属性的约束，用户定义完整性规则（User-defined integrity）也称域完整性规则。包括字段的值域、字段的类型和字段的有效规则（如小数位数）等约束，是由确定关系结构时所定义的字段的属性决定的。</li>
</ul>
</li>
</ul>
<h2 id="判断是否保持函数依赖">判断是否保持函数依赖？</h2>
<ul>
<li>设有属性集 {ABCDEF}，存在这样的函数依赖集{A-&gt;BC , CD-&gt;E , B-&gt;D , BE-&gt;F , EF-&gt;A},然后有这样的分解{ABC , BD , BEF}。判断该关系分解是否保持函数依赖？
<ul>
<li>答：设U1=ABC，A-&gt;BC，U2=BD，B-&gt;D ，U3=BEF，BE-&gt;F ，即我们不能推出 CD-&gt;E ，EF-&gt;A，所以也不具有保持函数依赖的特性。</li>
</ul>
</li>
</ul>
<h2 id="exists-not-exists">exists / not exists</h2>
<ul>
<li>EXISTS(包括 NOT EXISTS )子句的返回值是一个BOOL值。 EXISTS内部有一个子查询语句(SELECT ... FROM...)， 我将其称为EXIST的内查询语句。其内查询语句返回一个结果集。 EXISTS子句根据其内查询语句的结果集空或者非空，返回一个布尔值。</li>
<li>一种通俗的可以理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。</li>
<li>分析器会先看语句的第一个词，当它发现第一个词是SELECT关键字的时候，它会跳到FROM关键字，然后通过FROM关键字找到表名并把表装入内存。接着是找WHERE关键字，如果找不到则返回到SELECT找字段解析，如果找到WHERE，则分析其中的条件，完成后再回到SELECT分析字段。最后形成一张我们要的虚表。</li>
<li>WHERE关键字后面的是条件表达式。条件表达式计算完成后，会有一个返回值，即非0或0，非0即为真(true)，0即为假(false)。同理EXISTS后面的条件也有一个返回值，真或假，来确定接下来执不执行SELECT。</li>
<li>分析器先找到关键字SELECT，然后跳到FROM关键字将STUDENT表导入内存，并通过指针找到第一条记录，接着找到WHERE关键字计算它的条件表达式，如果为真那么把这条记录装到一个虚表当中，指针再指向下一条记录。如果为假那么指针直接指向下一条记录，而不进行其它操作。一直检索完整个表，并把检索出来的虚拟表返回给用户。EXISTS是条件表达式的一部分，它也有一个返回值(true或false)。</li>
<li>exists 与 in 最大的区别在于 in引导的子句只能返回一个字段，exists子句是允许的，但in只允许有一个字段返回。EXISTS与IN的使用效率的问题，通常情况下采用exists要比in效率高，因为IN不走索引，但要看实际情况具体使用：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</li>
</ul>
<h2 id="and-next">And next</h2>
<p>。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Python 爬虫 - 小记]]></title>
        <id>https://alittlewhiter.github.io/post/guan-yu-python-pa-chong-xiao-ji/</id>
        <link href="https://alittlewhiter.github.io/post/guan-yu-python-pa-chong-xiao-ji/">
        </link>
        <updated>2020-03-02T10:51:21.000Z</updated>
        <summary type="html"><![CDATA[<p>于中国大学MOOC有关<strong>爬虫</strong>网课学习记录<br>
<s>学这玩意儿也不是一次两次了、没一次学进去过的。。。😓</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>于中国大学MOOC有关<strong>爬虫</strong>网课学习记录<br>
<s>学这玩意儿也不是一次两次了、没一次学进去过的。。。😓</s></p>
<!-- more -->
<h2 id="requests库的常用方法">requests库的常用方法：</h2>
<p>requests.request(method, url, **kwargs);   method具体方法，url访问链接，kwargs控制访问参数（可选）<br>
get(url, params=None, **)<br>
head(url, **)<br>
post(url, data, json, **)<br>
put(url, data, **)<br>
patch(url, data, **)<br>
delete(url,  **)</p>
<p>可选访问参数有：params，data，json，headers，cookies，auth，files，timeout，proxies，allow_redirects，stream，verify，cert</p>
<h2 id="通用代码模板">通用代码模板：</h2>
<p>import requests</p>
<p>def getHTMLText(url):<br>
try:<br>
r = requests.get(url, timeout=100)<br>
r.raise_for_status()             # 对状态码不是200的错误状态抛出一个HTTP异常<br>
r.encoding = r.apparent_encoding<br>
return r.text<br>
except:<br>
print(r.status_code)<br>
return &quot;产生异常&quot;</p>
<h1 id="爬虫尺寸">爬虫尺寸：</h1>
<ul>
<li>小规模 --Requests库，数据量小，爬取小型网页数据</li>
<li>中规模 --Scrapy库，数据规模较大，速度敏感，爬取系列网站</li>
<li>大规模 --定制开发库，搜索引擎，爬取速度关键，全网爬取</li>
</ul>
<h1 id="robots协议">Robots协议</h1>
<p>各个网站主页根目录下，给出网站对于各种用户代理访问的反爬规则</p>
<h1 id="beautifulsoup库的使用">BeautifulSoup库的使用</h1>
<p>pip install beautifulsoup4</p>
<p>#- 对HTML页面内容的遍历方法：（构建标签树）<br>
<code>from bs4 import BeautifulSoup</code><br>
<code>soup = BeautifulSoup(aRespaonse.text, 'html.parser')</code><br>
<code>data = soup.prettify()</code><br>
<code>with open('F:/py123.html;, 'wb') as f:</code><br>
<code>f.write(data.encode('utf-8'))</code><br>
<code>f.close()</code><br>
<code>tag = soup.title/a/p/head/body/....</code><br>
<code>tag.attrs // 获取标签内属性，字典</code><br>
<code>tag(.parent)*.name // 标签名，父级标签名</code><br>
<code>tag.string // 标签内字符串</code></p>
<p>#- bs4库的基本元素：<br>
Tag，Name，Attributes，NavigabString，Comment<br>
#- bs4库的遍历功能<br>
.contents,  .parent,  .parents,  .children,   .descendants, .next_sibling,   .previous_sibling,  .next_siblings,  .previous_siblings</p>
<h2 id="信息标记的三种形式">信息标记的三种形式：</h2>
<ul>
<li>1、XML    &lt;<em>&gt;&lt;/</em>&gt;标签类型<br>
Internet上信息交互与传递</li>
<li>2、JSON    &quot;<em>&quot;: [&quot;</em>&quot;, &quot;*&quot;, ..]  有类型的键值对，字符串形式<br>
移动应用云端和节点的信息通信，适于js等，无注释</li>
<li>3、YAML    无类型键值对，缩进表达所属关系<br>
Name:   #comment<br>
name1<br>
name2<br>
各类系统的配置文件，有注释易读</li>
</ul>
<p><code>{soup/&lt;..&gt;}(..) .find_all(name, attrs, recursive, string, **kwargs) :</code><br>
<code>返回一个列表类型，存储查找的结果。</code></p>
<ul>
<li>name：对标签名称检索字符串</li>
<li>attrs：对标签属性值检索字符串，可标注属性检索</li>
<li>recursive：是否对子孙全部检索，默认True</li>
<li>string：对&lt;&gt;...&lt;/&gt;中间的内容进行检索</li>
<li>**kwargs:</li>
<li>···</li>
</ul>
<p>⏳<br>
⏳<br>
⏳<br>
。。。算啦、本辣鸡写不下去了，有缘再见吧 😇</p>
]]></content>
    </entry>
</feed>