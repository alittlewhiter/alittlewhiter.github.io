<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alittlewhiter.github.io</id>
    <title>君の知らない物语</title>
    <updated>2020-03-02T14:03:01.490Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alittlewhiter.github.io"/>
    <link rel="self" href="https://alittlewhiter.github.io/atom.xml"/>
    <subtitle>Took the sourest lemon that life has to offer and turned it into something resembling lemonade.</subtitle>
    <logo>https://alittlewhiter.github.io/images/avatar.png</logo>
    <icon>https://alittlewhiter.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 君の知らない物语</rights>
    <entry>
        <title type="html"><![CDATA[C++ 板子]]></title>
        <id>https://alittlewhiter.github.io/post/c-ban-zi/</id>
        <link href="https://alittlewhiter.github.io/post/c-ban-zi/">
        </link>
        <updated>2020-03-02T13:42:08.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：代码块、函数、语法 for C++<br>
{ 这 xx 竟 这 该 死 的 甜 美 ...  不要停下来啊~🤙🤙🤙}</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：代码块、函数、语法 for C++<br>
{ 这 xx 竟 这 该 死 的 甜 美 ...  不要停下来啊~🤙🤙🤙}</p>
<!-- more -->
<h2 id="321开始你的表演">321开始你的表演</h2>
<p>1、设想要使用new建立一个rows行，cols列的矩阵:</p>
<pre><code>int rows, cols ;
int **array = new int*[rows] ; 
for (int i = 0 ; i &lt; rows ; i++) {
    array[i] = new int[cols] ; 
    memset(*array, 0, sizeof(int)*cols) ;    // memset()是按字节填充，值一般只为0或-1。
}  
</code></pre>
<p>2、结构体重载操作符模板：</p>
<pre><code>Point operator + (const Point&amp; A, const Point&amp; B) {  
     return Point(A.x+B.x, A.y+B.y); 
}
ostream&amp; operator &lt;&lt; (ostream &amp;out, const Point&amp; p) {
    out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;;  
    return out; 
}
Point a, b;
cout &lt;&lt; a+b &lt;&lt; endl; 
</code></pre>
<p>3、求和函数模板sum()：</p>
<pre><code>template&lt;typename T&gt; T sum(T* begin, T* end) {  
    T *p = begin;  
    T ans = 0;  
    for(T *p = begin; p != end; p++)   
        ans = ans + *p;   
    return ans; 
}
</code></pre>
<p>4、结构体和类也可以是带模板的，如Point中x，y可以为int或double等多种类型：</p>
<pre><code>template &lt;typename T&gt; struct Point {  
    T x, y;  
    Point(T x=0, T y=0) : x(x),y(y) { } 
}; 
</code></pre>
<p>5、重载转换运算符 ：<br>
对于类X的成员函数 X::operator T()<br>
T是类型名 ，定义了一个X到T的转换。</p>
<pre><code>operator bool() const {
   return p;
} 
Handle h; 
bool b=h;       //在这里调用  
</code></pre>
<p>6、C++中const 引用的是对象时只能访问该对象的const 函数，因为其他函数有可能会修改该对象的成员，编译器为了避免该类事情发生，会认为调用非const函数是错误的，error：…discards qualifiers 的意思就是缺少限定符。<br>
因此：** 类似getter函数一般需要在后面加const限定符 **</p>
<p>7、求gcd最大公约数</p>
<ul>
<li>最快算法：</li>
</ul>
<pre><code>int gcd(int a, int b){
    while(b^=a^=b^=a%=b) ;
    return a;
}
</code></pre>
<ul>
<li>一般算法：</li>
</ul>
<pre><code>int gcd(int a,  int b)  {          // 要求
     return b ? gcd(b, a%b) : a ;
}
</code></pre>
<p>8、普通快速幂的模板：</p>
<pre><code>int fastpow(int base, int n, int mod){
	int ans=1; 
	while(n){
		if(n&amp;1) 
                    ans *= base % mod ;
		base *= base;
		n &gt;&gt;= 1;
	}
	return ans%mod;
}
</code></pre>
<p>9、快速读入整数（ 远快于 scanf () 与 cin ）</p>
<pre><code>inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch &lt; '0' || ch &gt; '9') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
</code></pre>
<p>10、</p>
<p>11、</p>
<p>Final、一道大杂烩~真香</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
#define maxn 500005
#define maxm 200005
#define INF 1234567890
#define p 1000000007
template&lt;class T&gt;inline bool read(T &amp;x)
{
    x=0;register char c=getchar();register bool f=0;
    while(!isdigit(c)){if(c==EOF)return false;f^=c=='-',c=getchar();}
    while(isdigit(c))x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=getchar();
    if(f)x=-x;
    return true;
}
template&lt;class T&gt;inline bool readd(T &amp;x)
{
    register ll X=0;register double y=1.0;register char c=getchar();register bool f=0;
    while(!isdigit(c)){if(c==EOF)return false;f^=c=='-',c=getchar();}
    while(isdigit(c))X=(X&lt;&lt;3)+(X&lt;&lt;1)+(c^48),c=getchar();
    x=X;
    if(c!='.')return true;
    c=getchar();
    while(isdigit(c))x+=(y/=10)*(c^48),c=getchar();
    if(f)x=-x;
    return true;
}
template&lt;class T&gt;inline bool readc(T &amp;x)
{
    register char c=getchar();
    while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
    if(c==EOF)return false;
    x=c;
    return true;
}
template&lt;class T&gt;inline bool readc(T *x)
{
    register char c=getchar();
    while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
    if(c==EOF)return false;
    while(c!=' '&amp;&amp;c!='\n'&amp;&amp;c!='\r'&amp;&amp;c!='\t'&amp;&amp;c!=EOF)*x++=c,c=getchar();
    *x=0;
    return true;
}
template&lt;class T&gt;inline bool reads(T &amp;x)
{
    x=&quot;&quot;;register char c=getchar();
    while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
    if(c==EOF)return false;
    while(c!=' '&amp;&amp;c!='\n'&amp;&amp;c!='\r'&amp;&amp;c!='\t'&amp;&amp;c!=EOF)x+=c,c=getchar();
    return true;
}
template&lt;class T&gt;inline void print(T x)
{
    if(x&lt;0)putchar('-'),x=-x;
    if(x&gt;9)print(x/10);
    putchar(x%10^48);
}
template&lt;class T&gt;inline void printd(T x,ll y)
{
    static ll mul[]={1};
    for(register ll i=1;i&lt;=18;i++)
        mul[i]=(mul[i-1]&lt;&lt;3)+(mul[i-1]&lt;&lt;1);
    if(x&lt;-1e-12)putchar('-'),x=-x;
    x*=mul[y];
    register ll x1=(ll)round(x),x2=x1/mul[y],x3=x1-x2*mul[y];
    print(x2);
    if(y&gt;0)
    {
        putchar('.');
        for(register ll i=1;i&lt;y&amp;&amp;x3*mul[i]&lt;mul[y];putchar('0'),i++);
        print(x3);
    }
}
template&lt;class T&gt;inline void printc(T x){putchar(x);}
template&lt;class T&gt;inline void printc(T *x){while(*x)putchar(*x++);}
template&lt;class T&gt;inline void prints(T x){for(register ll i=0;x[i]!='\0';i++)putchar(x[i]);}
template&lt;class T&gt;inline T maxd(T a,T b){if(b&gt;a)return b;return a;}
template&lt;class T&gt;inline T mind(T a,T b){if(b&lt;a)return b;return a;}
template&lt;class T&gt;inline T gcd(T a,T b){while(a^=b^=a^=b%=a);return b;}
template&lt;class T&gt;inline T lcm(T a,T b){return a/gcd(a,b)*b;}
template&lt;class T&gt;inline T absd(const T &amp;a){if(a&lt;0)return -a;return a;}
template&lt;class T&gt;inline void print(T x,char c){print(x),putchar(c);}
template&lt;class T&gt;inline void printd(T x,ll y,char c){printd(x,y),putchar(c);}
template&lt;class T&gt;inline void printc(T x,T c){printc(x),putchar(c);}
template&lt;class T&gt;inline void printc(T *x,T c){printc(x),putchar(c);}
template&lt;class T&gt;inline void prints(T x,char c){prints(x),putchar(c);}

</code></pre>
<p>mua~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web：前 前 后 后  ]]></title>
        <id>https://alittlewhiter.github.io/post/webqian-qian-hou-hou/</id>
        <link href="https://alittlewhiter.github.io/post/webqian-qian-hou-hou/">
        </link>
        <updated>2020-03-02T13:07:17.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：html, css, javascript, 标签，布局...<br>
【奥里给 ~hetui！！</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：html, css, javascript, 标签，布局...<br>
【奥里给 ~hetui！！</p>
<!-- more -->
<h2 id="position绝对和相对">Position：绝对和相对</h2>
<h3 id="主要区别">主要区别</h3>
<ul>
<li>Absolution：元素会脱离文档流，定位是相对于离它最近的且不是static定位的父元素而言，若该元素没有设置宽度，则宽度由元素里面的内容决定，且宽度不会影响父元素，定位为absolution后，原来的位置相当于是空的，下面的的元素会来占据。</li>
<li>Relative：元素仍处于文档流中，定位是相对于原本自身的位置，若没有设置宽度，则宽度为父元素的宽度，该元素的大小会影响父元素的大小。</li>
</ul>
<h3 id="position扩展">position扩展</h3>
<ol>
<li>Absolute：绝对定位，是相对于最近的且不是static定位的父元素来定位</li>
<li>Fixed：绝对定位，是相对于浏览器窗口来定位的，是固定的，不会跟屏幕一起滚动。</li>
<li>Relative：相对定位，是相对于其原本的位置来定位的。</li>
<li>Static：默认值，没有定位。</li>
<li>Inherit：继承父元素的position值。</li>
</ol>
<p>** 一、absolute：绝对定位，CSS 写法“ position: absolute; ”**<br>
1. 没有设定 Top、Right、Bottom、Left 的情况，默认依据父级的“内容区域原始点”为原始点，上面例子红色部分(父级黄色区域有 Padding 属性，“坐标原始点”和“内容区域原始点”不一样)， 基于绝对定位的元素不会占据空间。<br>
2. 有设定 Top、Right、Bottom、Left 的情况，这里又分了两种情况如下：<br>
(1). 父级没 position 属性，浏览器左上角(即 Body)为“坐标原始点”进行定位，位置由 Top、Right、Bottom、Left 属性决定。<br>
(2). 父级有 position属性，父级的“坐标原始点”为原始点，此时可以忽略父级元素padding的作用。</p>
<p>** 二、relative：相对定位，CSS 写法“ position: relative; ”**<br>
父级元素第一个relative子元素参照父级的“内容区域原始点”为原始点，无父级则以 Body 的“内容区域原始点”为原始点，其余依各元素次序顺延下来获得其位置，再受Top、Right、Bottom、Left 属性值影响，且有“撑开或占据高度”的作用。<br>
相对定位与绝对定位的区别在于它的参照点不是左上角的原点，而是该元素本身原先的起点位置。并且即使该元素偏移到了新的位置，也仍然从原始的起点处占据空间。</p>
<p>** 注 **：Absolute定位的子元素宽度不会影响父元素的宽度，而relative定位的子元素可能会撑大父元素。在没有独立设置宽度时，absolute定位的子元素的宽度会自动缩小为内部元素的布局应有的宽度，而relative定位的元素会继承父元素的宽度（甚至超出父元素范围产生覆盖），但不包括边界宽度。</p>
<h2 id="超链接-aa">超链接 <a></a></h2>
<ul>
<li>超链接虽然在网页中占有不可替代的地位, 但是在HTML中创建超链接非常简单, 只需用&lt;a&gt; &lt;/a&gt;标记环绕需要被链接的对象即可。<br>
<code>基本语法格式: &lt;a href-&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式”&gt;文本或图像&lt;/a&gt;</code></li>
<li>在上面的语法中, &lt;a&gt;标记是一个行内标记,用于定义超链接, href和target为其常用属性，具体解释如下:<br>
-- href :用于指定链接目标的url地址。当为&lt;a&gt;标记应用href属性时，它就具有了超链接的功能。<br>
-- target :用于指定链接页面的打开方式，其取值有self和blank两种，其中self为默认值。意为在原窗口中打开，blank为在新窗口中打开。</li>
</ul>
<h2 id="文本居中">文本居中</h2>
<ul>
<li>在将&lt;span&gt;标签style属性设置为vertical-align: middle 后，元素内容并没有垂直居中，在W3C官方中对 vertical-align做了下面的解释：This property affects the vertical positioning inside a line box of the boxes generated by an inline-level element.</li>
<li>事实上，一个Box中由很多行很多元素组成，vertical-align只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。如果把 vertical-align:middle 放到一个单元格元素，即table的td元素中，它的垂直居中显示是没任何问题的，因为它表示相对于该行的垂直高度居中显示。</li>
<li>可以设置&lt;span&gt;元素style中的 line-heght 值为其父元素&lt;div&gt;的height值，这样 vertical-align:middle 就会使&lt;span&gt;元素内容垂直居中。</li>
</ul>
<h2 id="more">More...</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Computer Network 默 · 示 · 录]]></title>
        <id>https://alittlewhiter.github.io/post/computer-network-mo-shi-lu/</id>
        <link href="https://alittlewhiter.github.io/post/computer-network-mo-shi-lu/">
        </link>
        <updated>2020-03-02T12:47:24.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords： WIFI、WLAN、跃点、RJ45、and so on<br>
bie说了，反正天<s>填</s>坑啊！😭😭😭<br>
#- 丢你王忠，你好！🕷 -#</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords： WIFI、WLAN、跃点、RJ45、and so on<br>
bie说了，反正天<s>填</s>坑啊！😭😭😭<br>
#- 丢你王忠，你好！🕷 -#</p>
<!-- more -->
<h2 id="wlan-和wifi-的区别">WLAN 和WIFI 的区别？</h2>
<pre><code>WIFI包含于WLAN中，主要采用802.11b协议的一项技术，是WLAN的一个标准，子集的关系。它们发射信号的功率不同，覆盖范围不同。
WIFI就是一种无线联网的技术，一般都是小范围的， 距离发射器远了就会收不到网络，而wlan覆盖范围就广泛的多
</code></pre>
<h2 id="跃点">跃点：</h2>
<pre><code>即路由。一个路由为一个跃点。传输过程中需要经过多个网络，每个被经过的网络设备点（有能力路由的）叫做一个跃点，地址就是它的ip。跃点数是经过了多少个跃点的累加器，为了防止无用的数据包在网上流散。 为路由指定所需跃点数的整数值（范围是 1 ~ 9999），它用来在路由表里的多个路由中选择与转发包中的目标地址最为匹配的路由, 所选的路由具有最少的跃点数。自动跃点修改方法如下：
</code></pre>
<ul>
<li>进入相关设备的网络设置，再进入internet TCP/IP的属性设置，再进入高级属性设置；</li>
<li>默认情况下是勾选的“自动跃点”，不要选择它，手动输入“接口跃点数”，输入的数字越小，优先级越高，这样可以手动控制哪个路由的优先级了。</li>
</ul>
<h2 id="rj45接口">RJ45接口</h2>
<pre><code>有两类：用于以太网网卡(网卡接口)、路由器以太网接口等的DTE类型，还有用于交换机等的DCE类型。DTE我们可以称做“数据终端设备”，DCE我们可以称做“数据通信设备”。从某种意义来说，DTE设备称为“主动通信设备”，DCE设备称为“被动通信设备”。当两个类型一样的设备使用RJ45接口连接通信时，必须使用交叉线连接。
</code></pre>
<h2 id="ip分配">IP分配</h2>
<pre><code>169.254.0.0/16这样的IP是一个本地链接地址段。RFC3927指出，在IP网络里，每台主机都需要一个IP地址，通常情况下是通过DHCP服务器自动分配，但某些特殊情况下，DHCP分配失败或者没有DHCP服务器时，机器可以自己分配一个IP来完成这个工作。
169.254.X.X是 Windows操作系统 在 DHCP 信息租用失败时自动给客户机分配的IP地址。由于网络连接问题、网线问题,DHCP服务器(其实就是Modem, 路由器, 或提供共享上网的主机)问题等，而令DHCP信息租用失败, 而IP169.254.X.X 的分配可能会令客户机(你自己的计算机,设置了&quot;自动获取IP&quot;)与所处局域网网关(Modem, 路由器, 或提供共享上网的主机) 位于不同的网段中, 而无法与网关通信,而导致无法接入Internet的情况。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[那一天，人类终于回想起曾一度被Ucore支配的恐惧...]]></title>
        <id>https://alittlewhiter.github.io/post/na-yi-tian-ren-lei-zhong-yu-hui-xiang-qi-ceng-yi-du-bei-ucore-zhi-pei-de-kong-ju/</id>
        <link href="https://alittlewhiter.github.io/post/na-yi-tian-ren-lei-zhong-yu-hui-xiang-qi-ceng-yi-du-bei-ucore-zhi-pei-de-kong-ju/">
        </link>
        <updated>2020-03-02T12:02:31.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：Ucore lab0、lab1、lab2实验分析、报告</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：Ucore lab0、lab1、lab2实验分析、报告</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搬点之前的《操作系统》]]></title>
        <id>https://alittlewhiter.github.io/post/ban-dian-zhi-qian-de-lesslesscao-zuo-xi-tong-greatergreater-huan-you-wo-os-da-jpg/</id>
        <link href="https://alittlewhiter.github.io/post/ban-dian-zhi-qian-de-lesslesscao-zuo-xi-tong-greatergreater-huan-you-wo-os-da-jpg/">
        </link>
        <updated>2020-03-02T11:47:06.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：OS管理功能、分类</p>
<p>学啥忘啥、学到老&amp;忘到老...<br>
~（Ko no OS da !）~</p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：OS管理功能、分类</p>
<p>学啥忘啥、学到老&amp;忘到老...<br>
~（Ko no OS da !）~</p>
<!-- more -->
<h1 id="操作系统可以分为五大管理功能部分">操作系统可以分为五大管理功能部分：</h1>
<p>1）设备管理：主要是负责内核与外围设备的数据交互，实质是对硬件设备的管理，包括对输入输出设备的分配，初始化，维护与回收等。例如管理音频输入输出。<br>
2）作业管理：这部分功能主要是负责人机交互，图形界面或者系统任务的管理。<br>
3）文件管理：这部分功能涉及文件的逻辑组织和物理组织，目录结构和管理等。从操作系统的角度来看，文件系统是系统对文件存储器的存储空间进行分配，维护和回收，同时负责文件的索引，共享和权限保护。而从用户的角度来说，文件系统是按照文件目录和文件名来进行存取的。<br>
4）进程管理：说明一个进程存在的唯一标志是pcb（进程控制块），负责维护进程的信息和状态。进程管理实质上是系统采取某些进程调度算法来使处理合理的分配给每个任务使用。<br>
5）存储管理：数据的存储方式和组织结构。</p>
<h1 id="os的分类">OS的分类</h1>
<h3 id="操作系统的类型也可以分为几种批处理系统分时操作系统实时操作系统网络操作系统等-下面将简单的介绍他们各自的特点">操作系统的类型也可以分为几种：批处理系统，分时操作系统，实时操作系统，网络操作系统等。下面将简单的介绍他们各自的特点：</h3>
<p>1）批处理系统：首先，用户提交完作业后并在获得结果之前不会再与操作系统进行数据交互，用户提交的作业由系统外存储存为后备作业；数据是成批处理的，有操作系统负责作业的自动完成；支持多道程序运行。<br>
2）分时操作系统：首先交互性方面，用户可以对程序动态运行时对其加以控制；支持多个用户登录终端，并且每个用户共享CPU和其他系统资源。<br>
3）实时操作系统：会有时钟管理，包括定时处理和延迟处理。实时性要求比较高，某些任务必须优先处理，而有些任务则会被延迟调度完成。<br>
4）网络操作系统：网络操作系统主要有几种基本功能<br>
（1）网络通信：负责在源主机与目标主机之间的数据的可靠通信，这是最基本的功能。<br>
（2）网络服务：系统支持一些电子邮件服务，文件传输，数据共享，设备共享等。<br>
（3）资源管理：对网络中共享的资源进行管理，例如设置权限以保证数据源的安全性。<br>
（4）网络管理：主要任务是实现安全管理，例如通过“存取控制”来确保数据的存取安全性，通过“容错性”来保障服务器故障时数据的安全性。<br>
（5）支持交互操作：在客户/服务器模型的LAN环境下，多种客户机和主机不仅能与服务器进行数据连接通信，并且可以访问服务器的文件系统</p>
<h1 id="下一个">下一个</h1>
<p>。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库の一些笔记]]></title>
        <id>https://alittlewhiter.github.io/post/shu-ju-ku-noyi-xie-bi-ji/</id>
        <link href="https://alittlewhiter.github.io/post/shu-ju-ku-noyi-xie-bi-ji/">
        </link>
        <updated>2020-03-02T11:25:57.000Z</updated>
        <summary type="html"><![CDATA[<p>Keywords：关系的键、DML &amp; DDL、模式、数据库完整性、FD</p>
<p>新冠肺炎宅在家，学习效率那是超像想地low哇<sub>（唉、搬点旧货</sub></p>
]]></summary>
        <content type="html"><![CDATA[<p>Keywords：关系的键、DML &amp; DDL、模式、数据库完整性、FD</p>
<p>新冠肺炎宅在家，学习效率那是超像想地low哇<sub>（唉、搬点旧货</sub></p>
<!-- more -->
<h2 id="有关-键">有关 键</h2>
<p><em>超键（super key， SK）</em><br>
<code>又称“超码”，是在数据库关系模式设计中能唯一标识一个元组的属性或属性集。 包含所有属性的集叫做明显（平凡）超键。</code><br>
<em>候选键（candidate key， CK）</em><br>
<code>又称“候选键“、”极小码“，是在数据库关系模式设计中能能唯一标识一个元组，且其真子集不能唯一标识一个元组的属性或属性集。</code><br>
<em>主键（primary key， PK）</em><br>
<code>又称“主码“，既从候选键中挑选出来的能唯一标识一个元组的属性或属性集。一张表中有且只能有一个主键。</code><br>
<em>外键（foreign key， FK）</em><br>
<code>又称“外码“，若一个关系中的一个属性或属性集是另外一个关系中的主码，则该属性或属性集为这个关系引用另外一个关系的外码。一张表中可以没有外码。</code></p>
<p><em>DML(Data Manipulation Language)数据操纵语言：</em><br>
<code>适用范围：对数据库中的数据进行一些简单操作，数据库表的增删改查，如insert, delete, update, select，call 等（select 可以划分到 DQL，）</code><br>
<em>DDL(Data Definition Language)数据定义语言：</em><br>
<code>适用范围：对数据库中的某些对象(例如，database,table)进行管理，如建库、建表、更改表结构，删库、删表，建索引，设置约束等：Create, Alter 和 Drop.</code><br>
- Create语句：可以创建数据库和数据库的一些对象。<br>
- Drop语句：可以删除数据表、索引、触发程序、条件约束以及数据表的权限等。<br>
- Alter语句：修改数据表定义及属性。</p>
<h3 id="主要区别">主要区别：</h3>
<p>1.DML操作是可以手动控制事务的开启、提交和回滚的。<br>
2.DDL操作是隐性提交的，不能rollback！</p>
<h3 id="此外还有">此外还有：</h3>
<p>DCL（DataControl Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin, dbcreator, db_owner或db_securityadmin等人员才有权力执行DCL<br>
DQL（Data QueryLanguage）：SELECT，数据查询语言</p>
<h2 id="模式schema">模式（Schema）：</h2>
<pre><code>   也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。
</code></pre>
<h3 id="理解">理解：</h3>
<p>① 一个数据库只有一个模式；<br>
② 是数据库数据在逻辑级上的视图；<br>
③ 数据库模式以某一种数据模型为基础；<br>
④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。</p>
<h3 id="外模式external-schema">外模式(external schema)</h3>
<ul>
<li>外模式是用户与数据库系统的接口。</li>
<li>单个用户的视图称为外部视图。一个用户往往只用到数据库的一部分。外部视图由若干外 部记录类型组成，这些外部记录类型和概念记录类型、内部记录类型可能不一样。</li>
<li>用户使用数据操纵语言语句对数据库进行操作.实际上是对外部视图的外部记录进行操作。例如GET操作是读一个外部记录值(实际上是逻辑记录值)，而不是数据库的内部记录值。每个外部视图用 DDL描述后得到的是外模式。描述外部视图的DDL称为“外模式DDL”。</li>
<li>外模式是外部视图 中每个外部记录类型的定义，因此它是面向一个或多个用户需要的那部分数据的描述。在外模 式中还必须定义外模式和概念模式间数据结构的差异。</li>
<li>外模式与概念模式的分离，使数据库系统的灵活性大大增加。外模式是从模式导出的，它必须是导出它的模式的逻辑子集但在外模式里，不仅那些与用户无关的数据可以略去，而且 数据项可以按照用户使用的习惯重新命名，记录类型也可以重新组合和命名。应用程序员不必 再关心整个数据库的全局逻辑结构，他只与外模式发生直接联系，按照外模式存储和操纵数据.</li>
<li>一个数据库可以有多个外模式。由于它是各个用户的数据视图，如果不同用户在应用需求，看待数据的方式，对数据保密的要求等方面存在差异，则其外模式描述就是不同的。即使对模式中同一数据，在外模式中的结构，类型，长度，保密级别等都可以是不同的。</li>
<li>对于一个数据库系统而言，同一外模式也可以为某一用户的多个应用所应用，但任何一个应用程序都必须使用而且只能使用一个外模式，才能对数据库中的数据进行操作。一个模式可以支持若干个外模式，但每一个外模式只能属于一个模式。</li>
</ul>
<h2 id="数据库完整性database-integrity">数据库完整性（Database Integrity）</h2>
<pre><code>  指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。数据库完整性由各种各样的完整性约束来保证，因此可以说数据库完整性设计就是数据库完整性约束的设计。
  
  数据库完整性约束可分为6类：列级静态约束、元组级静态约束、关系级静态约束、列级动态约束、元组级动态约束、关系级动态约束。动态约束通常由应用软件来实现。
  
  关系完整性的用于保证数据库中数据的正确性。系统在进行更新、插入或删除等操作时都要检查数据的完整性，核实其约束条件，即关系模型的完整性规则。
  
  在关系模型中有四类完整性约束：实体完整性、域完整性、参照完整性和用户定义的完整性，其中实体完整性和参照完整性约束条件, 称为关系的两个不变性。
</code></pre>
<ul>
<li>1、实体完整性（Entity Integrity）。实体完整性指表中行的完整性。主要用于保证操作的数据（记录）非空、唯一且不重复。即实体完整性要求每个关系（表）有且仅有一个主键，每一个主键值必须唯一，而且不允许为“空”（NULL）或重复。</li>
<li>2、域完整性（Domain Integrity）是指数据库表中的列必须满足某种特定的数据类型或约束。其中约束又包括取值范围、精度等规定。表中的CHECK、FOREIGN KEY 约束和DEFAULT、 NOT NULL定义都属于域完整性的范畴。</li>
<li>3、参照完整性（Referential Integrity）属于表间规则。对于永久关系的相关表，在更新、插入或删除记录时，如果只改其一，就会影响数据的完整性。如删除父表的某记录后，子表的相应记录未删除，致使这些记录称为孤立记录。对于更新、插入或删除表间数据的完整性，统称为参照完整性。通常，在客观现实中的实体之间存在一定联系，在关系模型中实体及实体间的联系都是以关系进行描述，因此，操作时就可能存在着关系与关系间的关联和引用。</li>
<li>4、用户定义完整性（User-defined Integrity）是对数据表中字段属性的约束，用户定义完整性规则（User-defined integrity）也称域完整性规则。包括字段的值域、字段的类型和字段的有效规则（如小数位数）等约束，是由确定关系结构时所定义的字段的属性决定的。</li>
</ul>
<h2 id="判断关系分解是否保持函数依赖">判断关系分解是否保持函数依赖？</h2>
<p>设有属性集 {ABCDEF}，存在这样的函数依赖集{A-&gt;BC , CD-&gt;E , B-&gt;D , BE-&gt;F , EF-&gt;A},然后有这样的分解{ABC , BD , BEF}。设U1=ABC，A-&gt;BC，U2=BD，B-&gt;D ，U3=BEF，BE-&gt;F ，即我们不能推出 CD-&gt;E ，EF-&gt;A，所以也不具有保持函数依赖的特性。</p>
<h2 id="exists-not-exists">exists / not exists</h2>
<ul>
<li>EXISTS(包括 NOT EXISTS )子句的返回值是一个BOOL值。 EXISTS内部有一个子查询语句(SELECT ... FROM...)， 我将其称为EXIST的内查询语句。其内查询语句返回一个结果集。 EXISTS子句根据其内查询语句的结果集空或者非空，返回一个布尔值。</li>
<li>一种通俗的可以理解为：将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE，这一行行可作为外查询的结果行，否则不能作为结果。</li>
<li>分析器会先看语句的第一个词，当它发现第一个词是SELECT关键字的时候，它会跳到FROM关键字，然后通过FROM关键字找到表名并把表装入内存。接着是找WHERE关键字，如果找不到则返回到SELECT找字段解析，如果找到WHERE，则分析其中的条件，完成后再回到SELECT分析字段。最后形成一张我们要的虚表。</li>
<li>WHERE关键字后面的是条件表达式。条件表达式计算完成后，会有一个返回值，即非0或0，非0即为真(true)，0即为假(false)。同理EXISTS后面的条件也有一个返回值，真或假，来确定接下来执不执行SELECT。</li>
<li>分析器先找到关键字SELECT，然后跳到FROM关键字将STUDENT表导入内存，并通过指针找到第一条记录，接着找到WHERE关键字计算它的条件表达式，如果为真那么把这条记录装到一个虚表当中，指针再指向下一条记录。如果为假那么指针直接指向下一条记录，而不进行其它操作。一直检索完整个表，并把检索出来的虚拟表返回给用户。EXISTS是条件表达式的一部分，它也有一个返回值(true或false)。</li>
<li>exists 与 in 最大的区别在于 in引导的子句只能返回一个字段，exists子句是允许的，但in只允许有一个字段返回。EXISTS与IN的使用效率的问题，通常情况下采用exists要比in效率高，因为IN不走索引，但要看实际情况具体使用：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。</li>
</ul>
<h2 id="and-next">And next</h2>
<p>。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Python 爬虫 - 小记]]></title>
        <id>https://alittlewhiter.github.io/post/guan-yu-python-pa-chong-xiao-ji/</id>
        <link href="https://alittlewhiter.github.io/post/guan-yu-python-pa-chong-xiao-ji/">
        </link>
        <updated>2020-03-02T10:51:21.000Z</updated>
        <summary type="html"><![CDATA[<p>于中国大学MOOC有关<strong>爬虫</strong>网课学习记录<br>
<s>学这玩意儿也不是一次两次了、没一次学进去过的。。。😓</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>于中国大学MOOC有关<strong>爬虫</strong>网课学习记录<br>
<s>学这玩意儿也不是一次两次了、没一次学进去过的。。。😓</s></p>
<!-- more -->
<h2 id="requests库的常用方法">requests库的常用方法：</h2>
<p>requests.request(method, url, **kwargs);   method具体方法，url访问链接，kwargs控制访问参数（可选）<br>
get(url, params=None, **)<br>
head(url, **)<br>
post(url, data, json, **)<br>
put(url, data, **)<br>
patch(url, data, **)<br>
delete(url,  **)</p>
<p>可选访问参数有：params，data，json，headers，cookies，auth，files，timeout，proxies，allow_redirects，stream，verify，cert</p>
<h2 id="通用代码模板">通用代码模板：</h2>
<p>import requests</p>
<p>def getHTMLText(url):<br>
try:<br>
r = requests.get(url, timeout=100)<br>
r.raise_for_status()             # 对状态码不是200的错误状态抛出一个HTTP异常<br>
r.encoding = r.apparent_encoding<br>
return r.text<br>
except:<br>
print(r.status_code)<br>
return &quot;产生异常&quot;</p>
<h1 id="爬虫尺寸">爬虫尺寸：</h1>
<ul>
<li>小规模 --Requests库，数据量小，爬取小型网页数据</li>
<li>中规模 --Scrapy库，数据规模较大，速度敏感，爬取系列网站</li>
<li>大规模 --定制开发库，搜索引擎，爬取速度关键，全网爬取</li>
</ul>
<h1 id="robots协议">Robots协议</h1>
<p>各个网站主页根目录下，给出网站对于各种用户代理访问的反爬规则</p>
<h1 id="beautifulsoup库的使用">BeautifulSoup库的使用</h1>
<p>pip install beautifulsoup4</p>
<p>#- 对HTML页面内容的遍历方法：（构建标签树）<br>
<code>from bs4 import BeautifulSoup</code><br>
<code>soup = BeautifulSoup(aRespaonse.text, 'html.parser')</code><br>
<code>data = soup.prettify()</code><br>
<code>with open('F:/py123.html;, 'wb') as f:</code><br>
<code>f.write(data.encode('utf-8'))</code><br>
<code>f.close()</code><br>
<code>tag = soup.title/a/p/head/body/....</code><br>
<code>tag.attrs // 获取标签内属性，字典</code><br>
<code>tag(.parent)*.name // 标签名，父级标签名</code><br>
<code>tag.string // 标签内字符串</code></p>
<p>#- bs4库的基本元素：<br>
Tag，Name，Attributes，NavigabString，Comment<br>
#- bs4库的遍历功能<br>
.contents,  .parent,  .parents,  .children,   .descendants, .next_sibling,   .previous_sibling,  .next_siblings,  .previous_siblings</p>
<h2 id="信息标记的三种形式">信息标记的三种形式：</h2>
<ul>
<li>1、XML    &lt;<em>&gt;&lt;/</em>&gt;标签类型<br>
Internet上信息交互与传递</li>
<li>2、JSON    &quot;<em>&quot;: [&quot;</em>&quot;, &quot;*&quot;, ..]  有类型的键值对，字符串形式<br>
移动应用云端和节点的信息通信，适于js等，无注释</li>
<li>3、YAML    无类型键值对，缩进表达所属关系<br>
Name:   #comment<br>
name1<br>
name2<br>
各类系统的配置文件，有注释易读</li>
</ul>
<p><code>{soup/&lt;..&gt;}(..) .find_all(name, attrs, recursive, string, **kwargs) :</code><br>
<code>返回一个列表类型，存储查找的结果。</code></p>
<ul>
<li>name：对标签名称检索字符串</li>
<li>attrs：对标签属性值检索字符串，可标注属性检索</li>
<li>recursive：是否对子孙全部检索，默认True</li>
<li>string：对&lt;&gt;...&lt;/&gt;中间的内容进行检索</li>
<li>**kwargs:</li>
<li>···</li>
</ul>
<p>⏳<br>
⏳<br>
⏳<br>
。。。算啦、本辣鸡写不下去了，有缘再见吧 😇</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea - 梦开始的地方]]></title>
        <id>https://alittlewhiter.github.io/post/hello-gridea/</id>
        <link href="https://alittlewhiter.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 是一个静态博客写作客户端，可以用来记录你的生活、心情、知识、笔记、创意...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 是一个静态博客写作客户端，可以用来记录你的生活、心情、知识、笔记、创意...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作<br>
🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片<br>
🏷️  你可以对文章进行标签分组<br>
📋  你可以自定义菜单，甚至可以创建外部链接菜单<br>
💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端<br>
🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台<br>
💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统<br>
🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong><br>
🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力<br>
🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步<br>
🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴（maybe</p>
<p>😘 Enjoy~</p>
<p>What ？怎么会就这样结束呢，好戏正式开始😁</p>
]]></content>
    </entry>
</feed>